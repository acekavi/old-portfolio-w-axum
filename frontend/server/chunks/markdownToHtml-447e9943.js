import * as path__default from 'path';
import path__default__default, { join as join$1 } from 'path';
import fs__default from 'fs';
import { createRequire } from 'module';
import require$$0 from 'util';
import remarkGfm from 'remark-gfm';
import rehypeExternalLinks from 'rehype-external-links';
import remarkGithub from 'remark-github/lib/index.js';
import shiki from 'shiki';

// This file was generated. Do not modify manually!
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

// This file was generated. Do not modify manually!
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];

// This file was generated. Do not modify manually!
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0898-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

// This file was generated. Do not modify manually!
var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ca\ua7d0\ua7d1\ua7d3\ua7d5-\ua7d9\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range.

// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};

var keywordRelationalOperator = /^in(stanceof)?$/;

// ## Character categories

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
  return false
}

// Test whether a given character code starts an identifier.

function isIdentifierStart$1(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords$2 = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords$2[name] = new TokenType(name, options)
}

var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),
  coalesce: binop("??", 1),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
}

function nextLineBreak(code, from, end) {
  if ( end === void 0 ) end = code.length;

  for (var i = from; i < end; i++) {
    var next = code.charCodeAt(i);
    if (isNewLine(next))
      { return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1 }
  }
  return -1
}

var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty$5 = ref.hasOwnProperty;
var toString$1 = ref.toString;

var hasOwn$1 = Object.hasOwn || (function (obj, propName) { return (
  hasOwnProperty$5.call(obj, propName)
); });

var isArray$1 = Array.isArray || (function (obj) { return (
  toString$1.call(obj) === "[object Array]"
); });

function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    var nextBreak = nextLineBreak(input, cur, offset);
    if (nextBreak < 0) { return new Position(line, offset - cur) }
    ++line;
    cur = nextBreak;
  }
}

// A second argument must be given to configure the parser process.
// These options are recognized (only `ecmaVersion` is required):

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};

// Interpret and default an options object

var warnedAboutEcmaVersion = false;

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts && hasOwn$1(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion < 5; }

  if (!opts || opts.allowHashBang == null)
    { options.allowHashBang = options.ecmaVersion >= 14; }

  if (isArray$1(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray$1(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Each scope gets a bitset that may contain these flags
var
    SCOPE_TOP = 1,
    SCOPE_FUNCTION = 2,
    SCOPE_ASYNC = 4,
    SCOPE_GENERATOR = 8,
    SCOPE_ARROW = 16,
    SCOPE_SIMPLE_CATCH = 32,
    SCOPE_SUPER = 64,
    SCOPE_DIRECT_SUPER = 128,
    SCOPE_CLASS_STATIC_BLOCK = 256,
    SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;

function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
}

// Used in checkLVal* and declareName to determine the type of a binding
var
    BIND_NONE = 0, // Not a binding
    BIND_VAR = 1, // Var-style binding
    BIND_LEXICAL = 2, // Let- or const-style binding
    BIND_FUNCTION = 3, // Function declaration
    BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding
    BIND_OUTSIDE = 5; // Special case for function names as bound inside the function

var Parser$2 = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") { reserved += " await"; }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types$1.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;

  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  // Labels in scope.
  this.labels = [];
  // Thus-far undefined exports.
  this.undefinedExports = Object.create(null);

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);

  // For RegExp validation
  this.regexpState = null;

  // The stack of private names.
  // Each element has two properties: 'declared' and 'used'.
  // When it exited from the outermost class definition, all used private names must be declared.
  this.privateNameStack = [];
};

var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },canAwait: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true },allowNewDotTarget: { configurable: true },inClassStaticBlock: { configurable: true } };

Parser$2.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };

prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit };

prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit };

prototypeAccessors.canAwait.get = function () {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var scope = this.scopeStack[i];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) { return false }
    if (scope.flags & SCOPE_FUNCTION) { return (scope.flags & SCOPE_ASYNC) > 0 }
  }
  return (this.inModule && this.options.ecmaVersion >= 13) || this.options.allowAwaitOutsideFunction
};

prototypeAccessors.allowSuper.get = function () {
  var ref = this.currentThisScope();
    var flags = ref.flags;
    var inClassFieldInit = ref.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod
};

prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };

prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

prototypeAccessors.allowNewDotTarget.get = function () {
  var ref = this.currentThisScope();
    var flags = ref.flags;
    var inClassFieldInit = ref.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit
};

prototypeAccessors.inClassStaticBlock.get = function () {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0
};

Parser$2.extend = function extend () {
    var plugins = [], len = arguments.length;
    while ( len-- ) plugins[ len ] = arguments[ len ];

  var cls = this;
  for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
  return cls
};

Parser$2.parse = function parse (input, options) {
  return new this(options, input).parse()
};

Parser$2.parseExpressionAt = function parseExpressionAt (input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression()
};

Parser$2.tokenizer = function tokenizer (input, options) {
  return new this(options, input)
};

Object.defineProperties( Parser$2.prototype, prototypeAccessors );

var pp$9 = Parser$2.prototype;

// ## Parser utilities

var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) { return false }
  for (;;) {
    // Try to find string literal.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" ||
        (lineBreak.test(spaceAfter[0]) &&
         !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "="))
    }
    start += match[0].length;

    // Skip semicolon, if any.
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";")
      { start++; }
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc
};

// Consumes contextual keyword if possible.

pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) { return false }
  this.next();
  return true
};

// Asserts that following token is given contextual keyword.

pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof ||
    this.type === types$1.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

var DestructuringErrors = function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
  this.doubleProto =
    -1;
};

pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern"); }
};

pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) { return false }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
  if (shorthandAssign >= 0)
    { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
  if (doubleProto >= 0)
    { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
};

pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$8 = Parser$2.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$8.parseTopLevel = function(node) {
  var exports = Object.create(null);
  if (!node.body) { node.body = []; }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule)
    { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
      {
        var name = list[i];

        this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
      } }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  // For ambiguous cases, determine if a LexicalDeclaration (or only a
  // Statement) is allowed here. If context is not empty then only a Statement
  // is allowed. However, `let [` is an explicit negative lookahead for
  // ExpressionStatement, so special-case it first.
  if (nextCh === 91 || nextCh === 92) { return true } // '[', '/'
  if (context) { return false }

  if (nextCh === 123 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true } // '{', astral
  if (isIdentifierStart$1(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) { ++pos; }
    if (nextCh === 92 || nextCh > 0xd7ff && nextCh < 0xdc00) { return true }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 === this.input.length ||
     !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 0xd7ff && after < 0xdc00))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types$1._break: case types$1._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types$1._debugger: return this.parseDebuggerStatement(node)
  case types$1._do: return this.parseDoStatement(node)
  case types$1._for: return this.parseForStatement(node)
  case types$1._function:
    // Function as sole body of either an if statement or a labeled statement
    // works, but not when it is part of a labeled statement that is the sole
    // body of an if statement.
    if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false, !context)
  case types$1._class:
    if (context) { this.unexpected(); }
    return this.parseClass(node, true)
  case types$1._if: return this.parseIfStatement(node)
  case types$1._return: return this.parseReturnStatement(node)
  case types$1._switch: return this.parseSwitchStatement(node)
  case types$1._throw: return this.parseThrowStatement(node)
  case types$1._try: return this.parseTryStatement(node)
  case types$1._const: case types$1._var:
    kind = kind || this.value;
    if (context && kind !== "var") { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types$1._while: return this.parseWhileStatement(node)
  case types$1._with: return this.parseWithStatement(node)
  case types$1.braceL: return this.parseBlock(true, node)
  case types$1.semi: return this.parseEmptyStatement(node)
  case types$1._export:
  case types$1._import:
    if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
      skipWhiteSpace.lastIndex = this.pos;
      var skip = skipWhiteSpace.exec(this.input);
      var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
      if (nextCh === 40 || nextCh === 46) // '(' or '.'
        { return this.parseExpressionStatement(node, this.parseExpression()) }
    }

    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
      if (!this.inModule)
        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
    }
    return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction()) {
      if (context) { this.unexpected(); }
      this.next();
      return this.parseFunctionStatement(node, true, !context)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
      { return this.parseLabeledStatement(node, maybeName, expr, context) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types$1.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
      if (node.label && isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    { this.eat(types$1.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = (this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")) ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, null)
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
        } else { node.await = awaitAt > -1; }
      }
      return this.parseForIn(node, init$1)
    }
    if (awaitAt > -1) { this.unexpected(awaitAt); }
    return this.parseFor(node, init$1)
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) { this.unexpected(awaitAt); }
      } else { node.await = awaitAt > -1; }
    }
    if (startsWithLet && isForOf) { this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'."); }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) { this.unexpected(awaitAt); }
  return this.parseFor(node, init)
};

pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
};

pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement")
};

pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types$1.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR;) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) { this.finishNode(cur, "SwitchCase"); }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) { this.unexpected(); }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty$1$1 = [];

pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);

  return param
};

pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) { this.unexpected(); }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$8.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement")
};

pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      // Update information about previous labels on this node
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
  if ( node === void 0 ) node = this.startNode();

  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) { this.enterScope(0); }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (exitStrict) { this.strict = false; }
  this.next();
  if (createNewLexicalScope) { this.exitScope(); }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$8.parseFor = function(node, init) {
  node.init = init;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$8.parseForIn = function(node, init) {
  var isForIn = this.type === types$1._in;
  this.next();

  if (
    init.type === "VariableDeclaration" &&
    init.declarations[0].init != null &&
    (
      !isForIn ||
      this.options.ecmaVersion < 8 ||
      this.strict ||
      init.kind !== "var" ||
      init.declarations[0].id.type !== "Identifier"
    )
  ) {
    this.raise(
      init.start,
      ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
    );
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
};

// Parse a list of variable declarations.

pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
      this.unexpected();
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) { break }
  }
  return node
};

pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};

var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;

// Parse a function declaration or literal (depending on the
// `statement & FUNC_STATEMENT`).

// Remove `allowExpressionBody` for 7.0.0, as it is only called with false
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && (statement & FUNC_HANGING_STATEMENT))
      { this.unexpected(); }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  if (statement & FUNC_STATEMENT) {
    node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT))
      // If it is a regular function declaration in sloppy mode, then it is
      // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding
      // mode depends on properties of the current scope (see
      // treatFunctionsAsVar).
      { this.checkLValSimple(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
  }

  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));

  if (!(statement & FUNC_STATEMENT))
    { node.id = this.type === types$1.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
};

pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$8.parseClass = function(node, isStatement) {
  this.next();

  // ecma-262 14.6 Class Definitions
  // A class definition is always strict mode code.
  var oldStrict = this.strict;
  this.strict = true;

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) { this.raiseRecoverable(element.start, "Duplicate constructor in the same class"); }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, ("Identifier '#" + (element.key.name) + "' has already been declared"));
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) { return null }

  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;

  if (this.eatContextual("static")) {
    // Parse static init block
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }

  // Parse element name
  if (keyName) {
    // 'async', 'get', 'set', or 'static' were not a keyword contextually.
    // The last token is any of those. Make it the element name.
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }

  // Parse element value
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    // Couldn't move this check into the 'parseClassMethod' method for backward compatibility.
    if (isConstructor && kind !== "method") { this.raise(node.key.start, "Constructor can't have get/set modifier"); }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }

  return node
};

pp$8.isClassElementNameStart = function() {
  return (
    this.type === types$1.name ||
    this.type === types$1.privateId ||
    this.type === types$1.num ||
    this.type === types$1.string ||
    this.type === types$1.bracketL ||
    this.type.keyword
  )
};

pp$8.parseClassElementName = function(element) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element.computed = false;
    element.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element);
  }
};

pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  // Check key and flags
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
    if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }

  // Parse value
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);

  // Check value
  if (method.kind === "get" && value.params.length !== 0)
    { this.raiseRecoverable(value.start, "getter should have no params"); }
  if (method.kind === "set" && value.params.length !== 1)
    { this.raiseRecoverable(value.start, "setter should have exactly one param"); }
  if (method.kind === "set" && value.params[0].type === "RestElement")
    { this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params"); }

  return this.finishNode(method, "MethodDefinition")
};

pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }

  if (this.eat(types$1.eq)) {
    // To raise SyntaxError if 'arguments' exists in the initializer.
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();

  return this.finishNode(field, "PropertyDefinition")
};

pp$8.parseClassStaticBlock = function(node) {
  node.body = [];

  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;

  return this.finishNode(node, "StaticBlock")
};

pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement)
      { this.checkLValSimple(node.id, BIND_LEXICAL, false); }
  } else {
    if (isStatement === true)
      { this.unexpected(); }
    node.id = null;
  }
};

pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};

pp$8.enterClassBody = function() {
  var element = {declared: Object.create(null), used: []};
  this.privateNameStack.push(element);
  return element.declared
};

pp$8.exitClassBody = function() {
  var ref = this.privateNameStack.pop();
  var declared = ref.declared;
  var used = ref.used;
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id = used[i];
    if (!hasOwn$1(declared, id.name)) {
      if (parent) {
        parent.used.push(id);
      } else {
        this.raiseRecoverable(id.start, ("Private field '#" + (id.name) + "' must be declared in an enclosing class"));
      }
    }
  }
};

function isPrivateNameConflicted(privateNameMap, element) {
  var name = element.key.name;
  var curr = privateNameMap[name];

  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }

  // `class { get #a(){}; static set #a(_){} }` is also conflict.
  if (
    curr === "iget" && next === "iset" ||
    curr === "iset" && next === "iget" ||
    curr === "sget" && next === "sset" ||
    curr === "sset" && next === "sget"
  ) {
    privateNameMap[name] = "true";
    return false
  } else if (!curr) {
    privateNameMap[name] = next;
    return false
  } else {
    return true
  }
}

function checkKeyName(node, name) {
  var computed = node.computed;
  var key = node.key;
  return !computed && (
    key.type === "Identifier" && key.name === name ||
    key.type === "Literal" && key.value === name
  )
}

// Parses module export declaration.

pp$8.parseExportAllDeclaration = function(node, exports) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node.exported = this.parseModuleExportName();
      this.checkExport(exports, node.exported, this.lastTokStart);
    } else {
      node.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) { this.unexpected(); }
  node.source = this.parseExprAtom();
  this.semicolon();
  return this.finishNode(node, "ExportAllDeclaration")
};

pp$8.parseExport = function(node, exports) {
  this.next();
  // export * from '...'
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node, exports)
  }
  if (this.eat(types$1._default)) { // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    node.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseExportDeclaration(node);
    if (node.declaration.type === "VariableDeclaration")
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) { this.unexpected(); }
      node.source = this.parseExprAtom();
    } else {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        // check for keywords used as local names
        var spec = list[i];

        this.checkUnreserved(spec.local);
        // check if export is defined
        this.checkLocalExport(spec.local);

        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$8.parseExportDeclaration = function(node) {
  return this.parseStatement(null)
};

pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) { this.next(); }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync)
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID")
  } else {
    var declaration = this.parseMaybeAssign();
    this.semicolon();
    return declaration
  }
};

pp$8.checkExport = function(exports, name, pos) {
  if (!exports) { return }
  if (typeof name !== "string")
    { name = name.type === "Identifier" ? name.name : name.value; }
  if (hasOwn$1(exports, name))
    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
  exports[name] = true;
};

pp$8.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier")
    { this.checkExport(exports, pat, pat.start); }
  else if (type === "ObjectPattern")
    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
      {
        var prop = list[i];

        this.checkPatternExport(exports, prop);
      } }
  else if (type === "ArrayPattern")
    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this.checkPatternExport(exports, elt); }
    } }
  else if (type === "Property")
    { this.checkPatternExport(exports, pat.value); }
  else if (type === "AssignmentPattern")
    { this.checkPatternExport(exports, pat.left); }
  else if (type === "RestElement")
    { this.checkPatternExport(exports, pat.argument); }
  else if (type === "ParenthesizedExpression")
    { this.checkPatternExport(exports, pat.expression); }
};

pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) { return }
  for (var i = 0, list = decls; i < list.length; i += 1)
    {
    var decl = list[i];

    this.checkPatternExport(exports, decl.id);
  }
};

pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$8.parseExportSpecifier = function(exports) {
  var node = this.startNode();
  node.local = this.parseModuleExportName();

  node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
  this.checkExport(
    exports,
    node.exported,
    node.exported.start
  );

  return this.finishNode(node, "ExportSpecifier")
};

pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) { break }
    } else { first = false; }

    nodes.push(this.parseExportSpecifier(exports));
  }
  return nodes
};

// Parses import declaration.

pp$8.parseImport = function(node) {
  this.next();

  // import '...'
  if (this.type === types$1.string) {
    node.specifiers = empty$1$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$8.parseImportSpecifier = function() {
  var node = this.startNode();
  node.imported = this.parseModuleExportName();

  if (this.eatContextual("as")) {
    node.local = this.parseIdent();
  } else {
    this.checkUnreserved(node.imported);
    node.local = node.imported;
  }
  this.checkLValSimple(node.local, BIND_LEXICAL);

  return this.finishNode(node, "ImportSpecifier")
};

pp$8.parseImportDefaultSpecifier = function() {
  // import defaultObj, { x, y as z } from '...'
  var node = this.startNode();
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportDefaultSpecifier")
};

pp$8.parseImportNamespaceSpecifier = function() {
  var node = this.startNode();
  this.next();
  this.expectContextual("as");
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportNamespaceSpecifier")
};

pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) { return nodes }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) { break }
    } else { first = false; }

    nodes.push(this.parseImportSpecifier());
  }
  return nodes
};

pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral
  }
  return this.parseIdent(true)
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return (
    this.options.ecmaVersion >= 5 &&
    statement.type === "ExpressionStatement" &&
    statement.expression.type === "Literal" &&
    typeof statement.expression.value === "string" &&
    // Reject parenthesized strings.
    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
  )
};

var pp$7 = Parser$2.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
    case "Identifier":
      if (this.inAsync && node.name === "await")
        { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
      break

    case "ObjectPattern":
    case "ArrayPattern":
    case "AssignmentPattern":
    case "RestElement":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

      this.toAssignable(prop, isBinding);
        // Early error:
        //   AssignmentRestProperty[Yield, Await] :
        //     `...` DestructuringAssignmentTarget[Yield, Await]
        //
        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.
        if (
          prop.type === "RestElement" &&
          (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
        ) {
          this.raise(prop.argument.start, "Unexpected token");
        }
      }
      break

    case "Property":
      // AssignmentProperty has type === "Property"
      if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
      this.toAssignable(node.value, isBinding);
      break

    case "ArrayExpression":
      node.type = "ArrayPattern";
      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
      this.toAssignableList(node.elements, isBinding);
      break

    case "SpreadElement":
      node.type = "RestElement";
      this.toAssignable(node.argument, isBinding);
      if (node.argument.type === "AssignmentPattern")
        { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
      break

    case "AssignmentExpression":
      if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
      node.type = "AssignmentPattern";
      delete node.operator;
      this.toAssignable(node.left, isBinding);
      break

    case "ParenthesizedExpression":
      this.toAssignable(node.expression, isBinding, refDestructuringErrors);
      break

    case "ChainExpression":
      this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
      break

    case "MemberExpression":
      if (!isBinding) { break }

    default:
      this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
  return node
};

// Convert list of expression atoms to binding list.

pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) { this.toAssignable(elt, isBinding); }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
      { this.unexpected(last.argument.start); }
  }
  return exprList
};

// Parses spread element.

pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
    case types$1.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types$1.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern")

    case types$1.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
};

pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this.expect(types$1.comma); }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) { this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"); }
      this.expect(close);
      break
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts
};

pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem
};

pp$7.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// The following three functions all verify that a node is an lvalue —
// something that can be bound, or assigned to. In order to do so, they perform
// a variety of checks:
//
// - Check that none of the bound/assigned-to identifiers are reserved words.
// - Record name declarations for bindings in the appropriate scope.
// - Check duplicate argument names, if checkClashes is set.
//
// If a complex binding pattern is encountered (e.g., object and array
// destructuring), the entire pattern is recursively checked.
//
// There are three versions of checkLVal*() appropriate for different
// circumstances:
//
// - checkLValSimple() shall be used if the syntactic construct supports
//   nothing other than identifiers and member expressions. Parenthesized
//   expressions are also correctly handled. This is generally appropriate for
//   constructs for which the spec says
//
//   > It is a Syntax Error if AssignmentTargetType of [the production] is not
//   > simple.
//
//   It is also appropriate for checking if an identifier is valid and not
//   defined elsewhere, like import declarations or function/class identifiers.
//
//   Examples where this is used include:
//     a += …;
//     import a from '…';
//   where a is the node to be checked.
//
// - checkLValPattern() shall be used if the syntactic construct supports
//   anything checkLValSimple() supports, as well as object and array
//   destructuring patterns. This is generally appropriate for constructs for
//   which the spec says
//
//   > It is a Syntax Error if [the production] is neither an ObjectLiteral nor
//   > an ArrayLiteral and AssignmentTargetType of [the production] is not
//   > simple.
//
//   Examples where this is used include:
//     (a = …);
//     const a = …;
//     try { … } catch (a) { … }
//   where a is the node to be checked.
//
// - checkLValInnerPattern() shall be used if the syntactic construct supports
//   anything checkLValPattern() supports, as well as default assignment
//   patterns, rest elements, and other constructs that may appear within an
//   object or array destructuring pattern.
//
//   As a special case, function parameters also use checkLValInnerPattern(),
//   as they also support defaults and rest constructs.
//
// These functions deliberately support both assignment and binding constructs,
// as the logic for both is exceedingly similar. If the node is the target of
// an assignment, then bindingType should be set to BIND_NONE. Otherwise, it
// should be set to the appropriate BIND_* constant, like BIND_VAR or
// BIND_LEXICAL.
//
// If the function is called with a non-BIND_NONE bindingType, then
// additionally a checkClashes object may be specified to allow checking for
// duplicate argument names. checkClashes is ignored if the provided construct
// is an assignment (i.e., bindingType is BIND_NONE).

pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  var isBind = bindingType !== BIND_NONE;

  switch (expr.type) {
  case "Identifier":
    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
    if (isBind) {
      if (bindingType === BIND_LEXICAL && expr.name === "let")
        { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
      if (checkClashes) {
        if (hasOwn$1(checkClashes, expr.name))
          { this.raiseRecoverable(expr.start, "Argument name clash"); }
        checkClashes[expr.name] = true;
      }
      if (bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
    }
    break

  case "ChainExpression":
    this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
    break

  case "MemberExpression":
    if (isBind) { this.raiseRecoverable(expr.start, "Binding member expression"); }
    break

  case "ParenthesizedExpression":
    if (isBind) { this.raiseRecoverable(expr.start, "Binding parenthesized expression"); }
    return this.checkLValSimple(expr.expression, bindingType, checkClashes)

  default:
    this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};

pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "ObjectPattern":
    for (var i = 0, list = expr.properties; i < list.length; i += 1) {
      var prop = list[i];

    this.checkLValInnerPattern(prop, bindingType, checkClashes);
    }
    break

  case "ArrayPattern":
    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this.checkLValInnerPattern(elem, bindingType, checkClashes); }
    }
    break

  default:
    this.checkLValSimple(expr, bindingType, checkClashes);
  }
};

pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if ( bindingType === void 0 ) bindingType = BIND_NONE;

  switch (expr.type) {
  case "Property":
    // AssignmentProperty has type === "Property"
    this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
    break

  case "AssignmentPattern":
    this.checkLValPattern(expr.left, bindingType, checkClashes);
    break

  case "RestElement":
    this.checkLValPattern(expr.argument, bindingType, checkClashes);
    break

  default:
    this.checkLValPattern(expr, bindingType, checkClashes);
  }
};

// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design


var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$2 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$6 = Parser$2.prototype;

pp$6.initialContext = function() {
  return [types$2.b_stat]
};

pp$6.curContext = function() {
  return this.context[this.context.length - 1]
};

pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types$2.f_expr || parent === types$2.f_stat)
    { return true }
  if (prevType === types$1.colon && (parent === types$2.b_stat || parent === types$2.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)
    { return true }
  if (prevType === types$1.braceL)
    { return parent === types$2.b_stat }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)
    { return false }
  return !this.exprAllowed
};

pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function")
      { return context.generator }
  }
  return false
};

pp$6.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types$1.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
};

// Used to handle egde cases when token context could not be inferred correctly during tokenization phase

pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};

// Token-specific context update code

types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types$2.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$2.b_stat : types$2.b_expr);
  this.exprAllowed = true;
};

types$1.dollarBraceL.updateContext = function() {
  this.context.push(types$2.b_tmpl);
  this.exprAllowed = true;
};

types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types$2.p_stat : types$2.p_expr);
  this.exprAllowed = true;
};

types$1.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else &&
      !(prevType === types$1.semi && this.curContext() !== types$2.p_stat) &&
      !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
      !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types$2.b_stat))
    { this.context.push(types$2.f_expr); }
  else
    { this.context.push(types$2.f_stat); }
  this.exprAllowed = false;
};

types$1.backQuote.updateContext = function() {
  if (this.curContext() === types$2.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types$2.q_tmpl); }
  this.exprAllowed = false;
};

types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types$2.f_expr)
      { this.context[index] = types$2.f_expr_gen; }
    else
      { this.context[index] = types$2.f_gen; }
  }
  this.exprAllowed = true;
};

types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed ||
        this.value === "yield" && this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts — that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser


var pp$5 = Parser$2.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
    { return }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, "Redefinition of property"); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) { node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors)); }
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) { return this.parseYield(forInit) }
    // The tokenizer will assume an expression is allowed after
    // `yield`, but this isn't that kind of yield
    else { this.exprAllowed = false; }
  }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq)
      { left = this.toAssignable(left, false, refDestructuringErrors); }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start)
      { refDestructuringErrors.shorthandAssign = -1; } // reset because shorthand default was used correctly
    if (this.type === types$1.eq)
      { this.checkLValPattern(left); }
    else
      { this.checkLValSimple(left); }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) { refDestructuringErrors.doubleProto = oldDoubleProto; }
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.
        // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if ((logical && this.type === types$1.coalesce) || (coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit)
    }
  }
  return left
};

pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") { this.raise(right.start, "Private identifier can only be left side of binary expression"); }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLValSimple(node.argument); }
    else if (this.strict && node.operator === "delete" &&
             node.argument.type === "Identifier")
      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
    else if (node.operator === "delete" && isPrivateFieldAccess(node.argument))
      { this.raiseRecoverable(node.start, "Private fields can not be deleted"); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if (forInit || this.privateNameStack.length === 0) { this.unexpected(); }
    expr = this.parsePrivateIdent();
    // only could be private fields in 'in', such as #x in obj
    if (this.type !== types$1._in) { this.unexpected(); }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary)
      { this.unexpected(this.lastTokStart); }
    else
      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false) }
  } else {
    return expr
  }
};

function isPrivateFieldAccess(node) {
  return (
    node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" ||
    node.type === "ChainExpression" && isPrivateFieldAccess(node.expression)
  )
}

// Parse call, dot, and `[]`-subscript expressions.

pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
    { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
    if (refDestructuringErrors.trailingComma >= result.start) { refDestructuringErrors.trailingComma = -1; }
  }
  return result
};

pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
      this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 &&
      this.potentialArrowAt === base.start;
  var optionalChained = false;

  while (true) {
    var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);

    if (element.optional) { optionalChained = true; }
    if (element === base || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element
    }

    base = element;
  }
};

pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow)
};

pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit)
};

pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) { this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions"); }

  var computed = this.eat(types$1.bracketL);
  if (computed || (optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0)
        { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit)
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({isTagged: true});
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  // If a division operator appears in an expression position, the
  // tokenizer got confused, and we force it to read a regexp instead.
  if (this.type === types$1.slash) { this.readRegexp(); }

  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
  case types$1._super:
    if (!this.allowSuper)
      { this.raise(this.start, "'super' keyword outside a method"); }
    node = this.startNode();
    this.next();
    if (this.type === types$1.parenL && !this.allowDirectSuper)
      { this.raise(node.start, "super() call outside constructor of a subclass"); }
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super ( Arguments )
    if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)
      { this.unexpected(); }
    return this.finishNode(node, "Super")

  case types$1._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, "ThisExpression")

  case types$1.name:
    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
    var id = this.parseIdent(false);
    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
      this.overrideContext(types$2.f_expr);
      return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit)
    }
    if (canBeArrow && !this.canInsertSemicolon()) {
      if (this.eat(types$1.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit) }
      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc &&
          (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
        id = this.parseIdent(false);
        if (this.canInsertSemicolon() || !this.eat(types$1.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit)
      }
    }
    return id

  case types$1.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types$1.num: case types$1.string:
    return this.parseLiteral(this.value)

  case types$1._null: case types$1._true: case types$1._false:
    node = this.startNode();
    node.value = this.type === types$1._null ? null : this.type === types$1._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, "Literal")

  case types$1.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind < 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types$1.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, "ArrayExpression")

  case types$1.braceL:
    this.overrideContext(types$2.b_expr);
    return this.parseObj(false, refDestructuringErrors)

  case types$1._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, 0)

  case types$1._class:
    return this.parseClass(this.startNode(), false)

  case types$1._new:
    return this.parseNew()

  case types$1.backQuote:
    return this.parseTemplate()

  case types$1._import:
    if (this.options.ecmaVersion >= 11) {
      return this.parseExprImport(forNew)
    } else {
      return this.unexpected()
    }

  default:
    return this.parseExprAtomDefault()
  }
};

pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};

pp$5.parseExprImport = function(forNew) {
  var node = this.startNode();

  // Consume `import` as an identifier for `import.meta`.
  // Because `this.parseIdent(true)` doesn't check escape sequences, it needs the check of `this.containsEsc`.
  if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword import"); }
  var meta = this.parseIdent(true);

  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node)
  } else if (this.type === types$1.dot) {
    node.meta = meta;
    return this.parseImportMeta(node)
  } else {
    this.unexpected();
  }
};

pp$5.parseDynamicImport = function(node) {
  this.next(); // skip `(`

  // Parse node.source.
  node.source = this.parseMaybeAssign();

  // Verify ending.
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }

  return this.finishNode(node, "ImportExpression")
};

pp$5.parseImportMeta = function(node) {
  this.next(); // skip `.`

  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);

  if (node.property.name !== "meta")
    { this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'"); }
  if (containsEsc)
    { this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters"); }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere)
    { this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module"); }

  return this.finishNode(node, "MetaProperty")
};

pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1).replace(/_/g, ""); }
  this.next();
  return this.finishNode(node, "Literal")
};

pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val
};

pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon()
};

pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    // Do not save awaitIdentPos to allow checking awaits nested in parameters
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);

    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
};

pp$5.parseParenItem = function(item) {
  return item
};

pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty$4 = [];

pp$5.parseNew = function() {
  if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
    node.meta = meta;
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target")
      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'"); }
    if (containsEsc)
      { this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters"); }
    if (!this.allowNewDotTarget)
      { this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block"); }
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) { node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false); }
  else { node.arguments = empty$4; }
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$5.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$5.parseTemplate = function(ref) {
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) { this.raise(this.pos, "Unterminated template literal"); }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
    (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) { break }
    } else { first = false; }

    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement")
    }
    // Parse argument.
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    // To disallow trailing comma via `this.toAssignable()`.
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    // Finish
    return this.finishNode(prop, "SpreadElement")
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types$1.star); }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property")
};

pp$5.parseGetterSetter = function(prop) {
  prop.kind = prop.key.name;
  this.parsePropertyName(prop);
  prop.value = this.parseMethod(false);
  var paramCount = prop.kind === "get" ? 0 : 1;
  if (prop.value.params.length !== paramCount) {
    var start = prop.value.start;
    if (prop.kind === "get")
      { this.raiseRecoverable(start, "getter should have no params"); }
    else
      { this.raiseRecoverable(start, "setter should have exactly one param"); }
  } else {
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
      { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
  }
};

pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon)
    { this.unexpected(); }

  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc &&
             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
             (prop.key.name === "get" || prop.key.name === "set") &&
             (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.parseGetterSetter(prop);
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) { this.unexpected(); }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = startPos; }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
};

// Initialize empty function node.

pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
  if (this.options.ecmaVersion >= 8) { node.async = false; }
};

// Parse object or class method.

pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);

  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict && nonSimple)
        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
    if (this.strict && node.id) { this.checkLValSimple(node.id, BIND_OUTSIDE); }
    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};

pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== "Identifier") { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = Object.create(null);
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty && this.type === types$1.comma)
      { elt = null; }
    else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)
        { refDestructuringErrors.trailingComma = this.start; }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

pp$5.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield")
    { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
  if (this.inAsync && name === "await")
    { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
  if (this.currentThisScope().inClassFieldInit && name === "arguments")
    { this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer"); }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await"))
    { this.raise(start, ("Cannot use " + name + " in class static initialization block")); }
  if (this.keywords.test(name))
    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
  if (this.options.ecmaVersion < 6 &&
    this.input.slice(start, end).indexOf("\\") !== -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await")
      { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
    this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
  }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$5.parseIdent = function(liberal) {
  var node = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos)
      { this.awaitIdentPos = node.start; }
  }
  return node
};

pp$5.parseIdentNode = function() {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/acornjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === "class" || node.name === "function") &&
      (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  return node
};

pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");

  // For validating existence
  if (this.privateNameStack.length === 0) {
    this.raise(node.start, ("Private field '#" + (node.name) + "' must be declared in an enclosing class"));
  } else {
    this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
  }

  return node
};

// Parses yield expression inside generator.

pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || (this.type !== types$1.star && !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression")
};

pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser$2.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$3 = Parser$2.prototype;

var Scope = function Scope(flags) {
  this.flags = flags;
  // A list of var-declared names in the current lexical scope
  this.var = [];
  // A list of lexically-declared names in the current lexical scope
  this.lexical = [];
  // A list of lexically-declared FunctionDeclaration names in the current lexical scope
  this.functions = [];
  // A switch to disallow the identifier reference 'arguments'
  this.inClassFieldInit = false;
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};

pp$3.exitScope = function() {
  this.scopeStack.pop();
};

// The spec says:
// > At the top level of a function, or script, function declarations are
// > treated like var declarations rather than like lexical declarations.
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
};

pp$3.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && (scope.flags & SCOPE_TOP))
      { delete this.undefinedExports[name]; }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar)
      { redeclared = scope$2.lexical.indexOf(name) > -1; }
    else
      { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
          !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break
      }
      scope$3.var.push(name);
      if (this.inModule && (scope$3.flags & SCOPE_TOP))
        { delete this.undefinedExports[name]; }
      if (scope$3.flags & SCOPE_VAR) { break }
    }
  }
  if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
};

pp$3.checkLocalExport = function(id) {
  // scope.functions must be empty as Module code is always strict.
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
      this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};

pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1]
};

pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) { return scope }
  }
};

// Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
  }
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$2 = Parser$2.prototype;

pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    { node.loc.end = loc; }
  if (this.options.ranges)
    { node.range[1] = pos; }
  return node
}

pp$2.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$2.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop in node) { newNode[prop] = node[prop]; }
  return newNode
};

// This file contains Unicode properties extracted from the ECMAScript specification.
// The lists are extracted like so:
// $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)

// #table-binary-unicode-properties
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;

var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};

// #table-binary-unicode-properties-of-strings
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";

var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};

// #table-unicode-general-category-values
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

// #table-unicode-script-values
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";

var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};

var data$1 = {};
function buildUnicodeData(ecmaVersion) {
  var d = data$1[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;

  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}

for (var i$1 = 0, list$3 = [9, 10, 11, 12, 13, 14]; i$1 < list$3.length; i$1 += 1) {
  var ecmaVersion = list$3[i$1];

  buildUnicodeData(ecmaVersion);
}

var pp$1 = Parser$2.prototype;

var RegExpValidationState = function RegExpValidationState(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data$1[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};

RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};

RegExpValidationState.prototype.raise = function raise (message) {
  this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
};

// If u flag is given, this returns the code point at the index (it combines a surrogate pair).
// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).
RegExpValidationState.prototype.at = function at (i, forceU) {
    if ( forceU === void 0 ) forceU = false;

  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1
  }
  var c = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
    return c
  }
  var next = s.charCodeAt(i + 1);
  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
};

RegExpValidationState.prototype.nextIndex = function nextIndex (i, forceU) {
    if ( forceU === void 0 ) forceU = false;

  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l
  }
  var c = s.charCodeAt(i), next;
  if (!(forceU || this.switchU) || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
    return i + 1
  }
  return i + 2
};

RegExpValidationState.prototype.current = function current (forceU) {
    if ( forceU === void 0 ) forceU = false;

  return this.at(this.pos, forceU)
};

RegExpValidationState.prototype.lookahead = function lookahead (forceU) {
    if ( forceU === void 0 ) forceU = false;

  return this.at(this.nextIndex(this.pos, forceU), forceU)
};

RegExpValidationState.prototype.advance = function advance (forceU) {
    if ( forceU === void 0 ) forceU = false;

  this.pos = this.nextIndex(this.pos, forceU);
};

RegExpValidationState.prototype.eat = function eat (ch, forceU) {
    if ( forceU === void 0 ) forceU = false;

  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true
  }
  return false
};

RegExpValidationState.prototype.eatChars = function eatChars (chs, forceU) {
    if ( forceU === void 0 ) forceU = false;

  var pos = this.pos;
  for (var i = 0, list = chs; i < list.length; i += 1) {
    var ch = list[i];

      var current = this.at(pos, forceU);
    if (current === -1 || current !== ch) {
      return false
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true
};

/**
 * Validate the flags part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;

  var u = false;
  var v = false;

  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") { u = true; }
    if (flag === "v") { v = true; }
  }
  if (this.options.ecmaVersion >= 15 && u && v) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};

/**
 * Validate the pattern part of a given RegExpLiteral.
 *
 * @param {RegExpValidationState} state The state to validate RegExp.
 * @returns {void}
 */
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);

  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of
  // parsing contains a |GroupName|, reparse with the goal symbol
  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*
  // exception if _P_ did not conform to the grammar, if any elements of _P_
  // were not matched by the parse, or if any Early Error conditions exist.
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;

  this.regexp_disjunction(state);

  if (state.pos !== state.source.length) {
    // Make the same messages as V8.
    if (state.eat(0x29 /* ) */)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(0x5D /* ] */) || state.eat(0x7D /* } */)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];

    if (state.groupNames.indexOf(name) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction
pp$1.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(0x7C /* | */)) {
    this.regexp_alternative(state);
  }

  // Make the same message as V8.
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(0x7B /* { */)) {
    state.raise("Lone quantifier brackets");
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state))
    { }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    // Handle `QuantifiableAssertion Quantifier` alternative.
    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion
    // is a QuantifiableAssertion.
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      // Make the same message as V8.
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true
  }

  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;

  // ^, $
  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {
    return true
  }

  // \b \B
  if (state.eat(0x5C /* \ */)) {
    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {
      return true
    }
    state.pos = start;
  }

  // Lookahead / Lookbehind
  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(0x3C /* < */);
    }
    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {
      this.regexp_disjunction(state);
      if (!state.eat(0x29 /* ) */)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true
    }
  }

  state.pos = start;
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier
pp$1.regexp_eatQuantifier = function(state, noError) {
  if ( noError === void 0 ) noError = false;

  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(0x3F /* ? */);
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return (
    state.eat(0x2A /* * */) ||
    state.eat(0x2B /* + */) ||
    state.eat(0x3F /* ? */) ||
    this.regexp_eatBracedQuantifier(state, noError)
  )
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(0x7B /* { */)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(0x7D /* } */)) {
        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom
pp$1.regexp_eatAtom = function(state) {
  return (
    this.regexp_eatPatternCharacters(state) ||
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state)
  )
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(0x28 /* ( */)) {
    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {
      this.regexp_disjunction(state);
      if (state.eat(0x29 /* ) */)) {
        return true
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(0x28 /* ( */)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 0x3F /* ? */) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(0x29 /* ) */)) {
      state.numCapturingParens += 1;
      return true
    }
    state.raise("Unterminated group");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom
pp$1.regexp_eatExtendedAtom = function(state) {
  return (
    state.eat(0x2E /* . */) ||
    this.regexp_eatReverseSolidusAtomEscape(state) ||
    this.regexp_eatCharacterClass(state) ||
    this.regexp_eatUncapturingGroup(state) ||
    this.regexp_eatCapturingGroup(state) ||
    this.regexp_eatInvalidBracedQuantifier(state) ||
    this.regexp_eatExtendedPatternCharacter(state)
  )
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};
function isSyntaxCharacter(ch) {
  return (
    ch === 0x24 /* $ */ ||
    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||
    ch === 0x2E /* . */ ||
    ch === 0x3F /* ? */ ||
    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||
    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter
// But eat eager.
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (
    ch !== -1 &&
    ch !== 0x24 /* $ */ &&
    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&
    ch !== 0x2E /* . */ &&
    ch !== 0x3F /* ? */ &&
    ch !== 0x5B /* [ */ &&
    ch !== 0x5E /* ^ */ &&
    ch !== 0x7C /* | */
  ) {
    state.advance();
    return true
  }
  return false
};

// GroupSpecifier ::
//   [empty]
//   `?` GroupName
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(0x3F /* ? */)) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return
    }
    state.raise("Invalid group");
  }
};

// GroupName ::
//   `<` RegExpIdentifierName `>`
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(0x3C /* < */)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {
      return true
    }
    state.raise("Invalid capture group name");
  }
  return false
};

// RegExpIdentifierName ::
//   RegExpIdentifierStart
//   RegExpIdentifierName RegExpIdentifierPart
// Note: this updates `state.lastStringValue` property with the eaten name.
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true
  }
  return false
};

// RegExpIdentifierStart ::
//   UnicodeIDStart
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[+U]
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart$1(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */
}

// RegExpIdentifierPart ::
//   UnicodeIDContinue
//   `$`
//   `_`
//   `\` RegExpUnicodeEscapeSequence[+U]
//   <ZWNJ>
//   <ZWJ>
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);

  if (ch === 0x5C /* \ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true
  }

  state.pos = start;
  return false
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape
pp$1.regexp_eatAtomEscape = function(state) {
  if (
    this.regexp_eatBackReference(state) ||
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state) ||
    (state.switchN && this.regexp_eatKGroupName(state))
  ) {
    return true
  }
  if (state.switchU) {
    // Make the same message as V8.
    if (state.current() === 0x63 /* c */) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true
    }
    if (n <= state.numCapturingParens) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(0x6B /* k */)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true
    }
    state.raise("Invalid named reference");
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape
pp$1.regexp_eatCharacterEscape = function(state) {
  return (
    this.regexp_eatControlEscape(state) ||
    this.regexp_eatCControlLetter(state) ||
    this.regexp_eatZero(state) ||
    this.regexp_eatHexEscapeSequence(state) ||
    this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
    this.regexp_eatIdentityEscape(state)
  )
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(0x63 /* c */)) {
    if (this.regexp_eatControlLetter(state)) {
      return true
    }
    state.pos = start;
  }
  return false
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 0x74 /* t */) {
    state.lastIntValue = 0x09; /* \t */
    state.advance();
    return true
  }
  if (ch === 0x6E /* n */) {
    state.lastIntValue = 0x0A; /* \n */
    state.advance();
    return true
  }
  if (ch === 0x76 /* v */) {
    state.lastIntValue = 0x0B; /* \v */
    state.advance();
    return true
  }
  if (ch === 0x66 /* f */) {
    state.lastIntValue = 0x0C; /* \f */
    state.advance();
    return true
  }
  if (ch === 0x72 /* r */) {
    state.lastIntValue = 0x0D; /* \r */
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};
function isControlLetter(ch) {
  return (
    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||
    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if ( forceU === void 0 ) forceU = false;

  var start = state.pos;
  var switchU = forceU || state.switchU;

  if (state.eat(0x75 /* u */)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 0xD800 && lead <= 0xDBFF) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(0x5C /* \ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 0xDC00 && trail <= 0xDFFF) {
            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
            return true
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true
    }
    if (
      switchU &&
      state.eat(0x7B /* { */) &&
      this.regexp_eatHexDigits(state) &&
      state.eat(0x7D /* } */) &&
      isValidUnicode(state.lastIntValue)
    ) {
      return true
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }

  return false
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 0x10FFFF
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true
    }
    if (state.eat(0x2F /* / */)) {
      state.lastIntValue = 0x2F; /* / */
      return true
    }
    return false
  }

  var ch = state.current();
  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
      state.advance();
    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)
    return true
  }
  return false
};

// Return values used by character set parsing methods, needed to
// forbid negation of sets that can match strings.
var CharSetNone = 0; // Nothing parsed
var CharSetOk = 1; // Construct parsed, cannot contain strings
var CharSetString = 2; // Construct parsed, can contain strings

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();

  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk
  }

  var negate = false;
  if (
    state.switchU &&
    this.options.ecmaVersion >= 9 &&
    ((negate = ch === 0x50 /* P */) || ch === 0x70 /* p */)
  ) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (
      state.eat(0x7B /* { */) &&
      (result = this.regexp_eatUnicodePropertyValueExpression(state)) &&
      state.eat(0x7D /* } */)
    ) {
      if (negate && result === CharSetString) { state.raise("Invalid property name"); }
      return result
    }
    state.raise("Invalid property name");
  }

  return CharSetNone
};

function isCharacterClassEscape(ch) {
  return (
    ch === 0x64 /* d */ ||
    ch === 0x44 /* D */ ||
    ch === 0x73 /* s */ ||
    ch === 0x53 /* S */ ||
    ch === 0x77 /* w */ ||
    ch === 0x57 /* W */
  )
}

// UnicodePropertyValueExpression ::
//   UnicodePropertyName `=` UnicodePropertyValue
//   LoneUnicodePropertyNameOrValue
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;

  // UnicodePropertyName `=` UnicodePropertyValue
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return CharSetOk
    }
  }
  state.pos = start;

  // LoneUnicodePropertyNameOrValue
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue)
  }
  return CharSetNone
};

pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!hasOwn$1(state.unicodeProperties.nonBinary, name))
    { state.raise("Invalid property name"); }
  if (!state.unicodeProperties.nonBinary[name].test(value))
    { state.raise("Invalid property value"); }
};

pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) { return CharSetOk }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) { return CharSetString }
  state.raise("Invalid property name");
};

// UnicodePropertyName ::
//   UnicodePropertyNameCharacters
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};

function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 0x5F /* _ */
}

// UnicodePropertyValue ::
//   UnicodePropertyValueCharacters
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== ""
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
}

// LoneUnicodePropertyNameOrValue ::
//   UnicodePropertyValueCharacters
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state)
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(0x5B /* [ */)) {
    var negate = state.eat(0x5E /* ^ */);
    var result = this.regexp_classContents(state);
    if (!state.eat(0x5D /* ] */))
      { state.raise("Unterminated character class"); }
    if (negate && result === CharSetString)
      { state.raise("Negated character class may contain strings"); }
    return true
  }
  return false
};

// https://tc39.es/ecma262/#prod-ClassContents
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges
pp$1.regexp_classContents = function(state) {
  if (state.current() === 0x5D /* ] */) { return CharSetOk }
  if (state.switchV) { return this.regexp_classSetExpression(state) }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges
// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom
// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;

  if (state.eat(0x5C /* \ */)) {
    if (this.regexp_eatClassEscape(state)) {
      return true
    }
    if (state.switchU) {
      // Make the same message as V8.
      var ch$1 = state.current();
      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }

  var ch = state.current();
  if (ch !== 0x5D /* ] */) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }

  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;

  if (state.eat(0x62 /* b */)) {
    state.lastIntValue = 0x08; /* <BS> */
    return true
  }

  if (state.switchU && state.eat(0x2D /* - */)) {
    state.lastIntValue = 0x2D; /* - */
    return true
  }

  if (!state.switchU && state.eat(0x63 /* c */)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true
    }
    state.pos = start;
  }

  return (
    this.regexp_eatCharacterClassEscape(state) ||
    this.regexp_eatCharacterEscape(state)
  )
};

// https://tc39.es/ecma262/#prod-ClassSetExpression
// https://tc39.es/ecma262/#prod-ClassUnion
// https://tc39.es/ecma262/#prod-ClassIntersection
// https://tc39.es/ecma262/#prod-ClassSubtraction
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state)) ; else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) { result = CharSetString; }
    // https://tc39.es/ecma262/#prod-ClassIntersection
    var start = state.pos;
    while (state.eatChars([0x26, 0x26] /* && */)) {
      if (
        state.current() !== 0x26 /* & */ &&
        (subResult = this.regexp_eatClassSetOperand(state))
      ) {
        if (subResult !== CharSetString) { result = CharSetOk; }
        continue
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) { return result }
    // https://tc39.es/ecma262/#prod-ClassSubtraction
    while (state.eatChars([0x2D, 0x2D] /* -- */)) {
      if (this.regexp_eatClassSetOperand(state)) { continue }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) { return result }
  } else {
    state.raise("Invalid character in character class");
  }
  // https://tc39.es/ecma262/#prod-ClassUnion
  for (;;) {
    if (this.regexp_eatClassSetRange(state)) { continue }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) { return result }
    if (subResult === CharSetString) { result = CharSetString; }
  }
};

// https://tc39.es/ecma262/#prod-ClassSetRange
pp$1.regexp_eatClassSetRange = function(state) {
  var start = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(0x2D /* - */) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true
    }
    state.pos = start;
  }
  return false
};

// https://tc39.es/ecma262/#prod-ClassSetOperand
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) { return CharSetOk }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state)
};

// https://tc39.es/ecma262/#prod-NestedClass
pp$1.regexp_eatNestedClass = function(state) {
  var start = state.pos;
  if (state.eat(0x5B /* [ */)) {
    var negate = state.eat(0x5E /* ^ */);
    var result = this.regexp_classContents(state);
    if (state.eat(0x5D /* ] */)) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result
    }
    state.pos = start;
  }
  if (state.eat(0x5C /* \ */)) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1
    }
    state.pos = start;
  }
  return null
};

// https://tc39.es/ecma262/#prod-ClassStringDisjunction
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start = state.pos;
  if (state.eatChars([0x5C, 0x71] /* \q */)) {
    if (state.eat(0x7B /* { */)) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(0x7D /* } */)) {
        return result
      }
    } else {
      // Make the same message as V8.
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return null
};

// https://tc39.es/ecma262/#prod-ClassStringDisjunctionContents
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(0x7C /* | */)) {
    if (this.regexp_classString(state) === CharSetString) { result = CharSetString; }
  }
  return result
};

// https://tc39.es/ecma262/#prod-ClassString
// https://tc39.es/ecma262/#prod-NonEmptyClassString
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) { count++; }
  return count === 1 ? CharSetOk : CharSetString
};

// https://tc39.es/ecma262/#prod-ClassSetCharacter
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start = state.pos;
  if (state.eat(0x5C /* \ */)) {
    if (
      this.regexp_eatCharacterEscape(state) ||
      this.regexp_eatClassSetReservedPunctuator(state)
    ) {
      return true
    }
    if (state.eat(0x62 /* b */)) {
      state.lastIntValue = 0x08; /* <BS> */
      return true
    }
    state.pos = start;
    return false
  }
  var ch = state.current();
  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) { return false }
  if (isClassSetSyntaxCharacter(ch)) { return false }
  state.advance();
  state.lastIntValue = ch;
  return true
};

// https://tc39.es/ecma262/#prod-ClassSetReservedDoublePunctuator
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return (
    ch === 0x21 /* ! */ ||
    ch >= 0x23 /* # */ && ch <= 0x26 /* & */ ||
    ch >= 0x2A /* * */ && ch <= 0x2C /* , */ ||
    ch === 0x2E /* . */ ||
    ch >= 0x3A /* : */ && ch <= 0x40 /* @ */ ||
    ch === 0x5E /* ^ */ ||
    ch === 0x60 /* ` */ ||
    ch === 0x7E /* ~ */
  )
}

// https://tc39.es/ecma262/#prod-ClassSetSyntaxCharacter
function isClassSetSyntaxCharacter(ch) {
  return (
    ch === 0x28 /* ( */ ||
    ch === 0x29 /* ) */ ||
    ch === 0x2D /* - */ ||
    ch === 0x2F /* / */ ||
    ch >= 0x5B /* [ */ && ch <= 0x5D /* ] */ ||
    ch >= 0x7B /* { */ && ch <= 0x7D /* } */
  )
}

// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch = state.current();
  if (isClassSetReservedPunctuator(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true
  }
  return false
};

// https://tc39.es/ecma262/#prod-ClassSetReservedPunctuator
function isClassSetReservedPunctuator(ch) {
  return (
    ch === 0x21 /* ! */ ||
    ch === 0x23 /* # */ ||
    ch === 0x25 /* % */ ||
    ch === 0x26 /* & */ ||
    ch === 0x2C /* , */ ||
    ch === 0x2D /* - */ ||
    ch >= 0x3A /* : */ && ch <= 0x3E /* > */ ||
    ch === 0x40 /* @ */ ||
    ch === 0x60 /* ` */ ||
    ch === 0x7E /* ~ */
  )
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {
    state.lastIntValue = ch % 0x20;
    state.advance();
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(0x78 /* x */)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);
    state.advance();
  }
  return state.pos !== start
};
function isDecimalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit$1(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start
};
function isHexDigit$1(ch) {
  return (
    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||
    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||
    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)
  )
}
function hexToInt(ch) {
  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {
    return 10 + (ch - 0x41 /* A */)
  }
  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {
    return 10 + (ch - 0x61 /* a */)
  }
  return ch - 0x30 /* 0 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence
// Allows only 0-377(octal) i.e. 0-255(decimal).
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true
  }
  return false
};

// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 0x30; /* 0 */
    state.advance();
    return true
  }
  state.lastIntValue = 0;
  return false
};
function isOctalDigit(ch) {
  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */
}

// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits
// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit
// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit$1(ch)) {
      state.pos = start;
      return false
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
};

// ## Tokenizer

var pp = Parser$2.prototype;

// Move to the next token

pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
    { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp.getToken = function() {
  this.next();
  return new Token(this)
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined")
  { pp[Symbol.iterator] = function() {
    var this$1$1 = this;

    return {
      next: function () {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        }
      }
    }
  }; }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

// Read a single token, updating the parser object's token-related
// properties.

pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos >= this.input.length) { return this.finishToken(types$1.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp.readToken = function(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart$1(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
};

pp.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xdc00) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 0xdbff || next >= 0xe000 ? code : (code << 10) + next - 0x35fdc00
};

pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = (void 0), pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
};

pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
    case 32: case 160: // ' '
      ++this.pos;
      break
    case 13:
      if (this.input.charCodeAt(this.pos + 1) === 10) {
        ++this.pos;
      }
    case 10: case 8232: case 8233:
      ++this.pos;
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      break
    case 47: // '/'
      switch (this.input.charCodeAt(this.pos + 1)) {
      case 42: // '*'
        this.skipBlockComment();
        break
      case 47:
        this.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this.pos;
      } else {
        break loop
      }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types$1.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot)
  }
};

pp.readToken_slash = function() { // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types$1.assign, 2) }
  return this.finishOp(types$1.slash, 1)
};

pp.readToken_mult_modulo_exp = function(code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types$1.star : types$1.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types$1.assign, size + 1) }
  return this.finishOp(tokentype, size)
};

pp.readToken_pipe_amp = function(code) { // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) { return this.finishOp(types$1.assign, 3) }
    }
    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2)
  }
  if (next === 61) { return this.finishOp(types$1.assign, 2) }
  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1)
};

pp.readToken_caret = function() { // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types$1.assign, 2) }
  return this.finishOp(types$1.bitwiseXOR, 1)
};

pp.readToken_plus_min = function(code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types$1.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types$1.assign, 2) }
  return this.finishOp(types$1.plusMin, 1)
};

pp.readToken_lt_gt = function(code) { // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types$1.assign, size + 1) }
    return this.finishOp(types$1.bitShift, size)
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
      this.input.charCodeAt(this.pos + 3) === 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types$1.relational, size)
};

pp.readToken_eq_excl = function(code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
    this.pos += 2;
    return this.finishToken(types$1.arrow)
  }
  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1)
};

pp.readToken_question = function() { // '?'
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) { return this.finishOp(types$1.questionDot, 2) }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) { return this.finishOp(types$1.assign, 3) }
      }
      return this.finishOp(types$1.coalesce, 2)
    }
  }
  return this.finishOp(types$1.question, 1)
};

pp.readToken_numberSign = function() { // '#'
  var ecmaVersion = this.options.ecmaVersion;
  var code = 35; // '#'
  if (ecmaVersion >= 13) {
    ++this.pos;
    code = this.fullCharCodeAtPos();
    if (isIdentifierStart$1(code, true) || code === 92 /* '\' */) {
      return this.finishToken(types$1.privateId, this.readWord1())
    }
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp.getTokenFromCode = function(code) {
  switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
  case 46: // '.'
    return this.readToken_dot()

  // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types$1.parenL)
  case 41: ++this.pos; return this.finishToken(types$1.parenR)
  case 59: ++this.pos; return this.finishToken(types$1.semi)
  case 44: ++this.pos; return this.finishToken(types$1.comma)
  case 91: ++this.pos; return this.finishToken(types$1.bracketL)
  case 93: ++this.pos; return this.finishToken(types$1.bracketR)
  case 123: ++this.pos; return this.finishToken(types$1.braceL)
  case 125: ++this.pos; return this.finishToken(types$1.braceR)
  case 58: ++this.pos; return this.finishToken(types$1.colon)

  case 96: // '`'
    if (this.options.ecmaVersion < 6) { break }
    ++this.pos;
    return this.finishToken(types$1.backQuote)

  case 48: // '0'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
    if (this.options.ecmaVersion >= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
    }

  // Anything else beginning with a digit is an integer, octal
  // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

  // Quotes produce strings.
  case 34: case 39: // '"', "'"
    return this.readString(code)

  // Operators are parsed inline in tiny state machines. '=' (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.
  case 47: // '/'
    return this.readToken_slash()

  case 37: case 42: // '%*'
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&'
    return this.readToken_pipe_amp(code)

  case 94: // '^'
    return this.readToken_caret()

  case 43: case 45: // '+-'
    return this.readToken_plus_min(code)

  case 60: case 62: // '<>'
    return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
    return this.readToken_eq_excl(code)

  case 63: // '?'
    return this.readToken_question()

  case 126: // '~'
    return this.finishOp(types$1.prefix, 1)

  case 35: // '#'
    return this.readToken_numberSign()
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

pp.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
    if (!escaped) {
      if (ch === "[") { inClass = true; }
      else if (ch === "]" && inClass) { inClass = false; }
      else if (ch === "/" && !inClass) { break }
      escaped = ch === "\\";
    } else { escaped = false; }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) { this.unexpected(flagsStart); }

  // Validate pattern
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);

  // Create Literal#value property value.
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
    // ESTree requires null if it failed to instantiate RegExp object.
    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral
  }

  return this.finishToken(types$1.regexp, {pattern: pattern, flags: flags, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  // `len` is used for character escape sequences. In that case, disallow separators.
  var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;

  // `maybeLegacyOctalNumericLiteral` is true if it doesn't have prefix (0x,0o,0b)
  // and isn't fraction part nor exponent part. In that case, if the first digit
  // is zero then disallow separators.
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;

  var start = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val = (void 0);

    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"); }
      if (lastCode === 95) { this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"); }
      if (i === 0) { this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"); }
      lastCode = code;
      continue
    }

    if (code >= 97) { val = code - 97 + 10; } // a
    else if (code >= 65) { val = code - 65 + 10; } // A
    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val >= radix) { break }
    lastCode = code;
    total = total * radix + val;
  }

  if (allowSeparators && lastCode === 95) { this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"); }
  if (this.pos === start || len != null && this.pos - start !== len) { return null }

  return total
};

function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8)
  }

  // `parseFloat(value)` stops parsing at the first numeric separator then returns a wrong value.
  return parseFloat(str.replace(/_/g, ""))
}

function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null
  }

  // `BigInt(value)` throws syntax error if the string contains numeric separators.
  return BigInt(str.replace(/_/g, ""))
}

pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart$1(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  return this.finishToken(types$1.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, undefined, true) === null) { this.raise(start, "Invalid number"); }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) { this.raise(start, "Invalid number"); }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart$1(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
    return this.finishToken(types$1.num, val$1)
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
  if (next === 46 && !octal) { // '.'
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) { // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // '+-'
    if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  }
  if (isIdentifierStart$1(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // '{'
    if (this.options.ecmaVersion < 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) { break }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 0x2028 || ch === 0x2029) {
      if (this.options.ecmaVersion < 10) { this.raise(this.start, "Unterminated string constant"); }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) { this.raise(this.start, "Unterminated string constant"); }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out)
};

// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};

pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
};

pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (;;) {
    if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL)
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote)
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out)
    }
    if (ch === 92) { // '\'
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
      case 13:
        if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
      case 10:
        out += "\n";
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};

// Reads a template token to search for the end, without validating any escape sequences
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
    case "\\":
      ++this.pos;
      break

    case "$":
      if (this.input[this.pos + 1] !== "{") {
        break
      }

    // falls through
    case "`":
      return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos))

    // no default
    }
  }
  this.raise(this.start, "Unterminated template");
};

// Used to read escaped characters

pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return "\n" // 'n' -> '\n'
  case 114: return "\r" // 'r' -> '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -> '\t'
  case 98: return "\b" // 'b' -> '\b'
  case 118: return "\u000b" // 'v' -> '\u000b'
  case 102: return "\f" // 'f' -> '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
  case 10: // ' \n'
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return ""
  case 56:
  case 57:
    if (this.strict) {
      this.invalidStringToken(
        this.pos - 1,
        "Invalid escape sequence"
      );
    }
    if (inTemplate) {
      var codePos = this.pos - 1;

      this.invalidStringToken(
        codePos,
        "Invalid escape sequence in template string"
      );
    }
  default:
    if (ch >= 48 && ch <= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal > 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      this.pos += octalStr.length - 1;
      ch = this.input.charCodeAt(this.pos);
      if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
        this.invalidStringToken(
          this.pos - 1 - octalStr.length,
          inTemplate
            ? "Octal literal in template string"
            : "Octal literal in strict mode"
        );
      }
      return String.fromCharCode(octal)
    }
    if (isNewLine(ch)) {
      // Unicode new line characters after \ get removed from output in both
      // template literals and strings
      return ""
    }
    return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) { // "\"
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) // "u"
        { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart$1 : isIdentifierChar)(esc, astral))
        { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords$2[word];
  }
  return this.finishToken(type, word)
};

// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/acornjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/acornjs/acorn/issues
//
// [walk]: util/walk.js


var version = "8.9.0";

Parser$2.acorn = {
  Parser: Parser$2,
  version: version,
  defaultOptions: defaultOptions,
  Position: Position,
  SourceLocation: SourceLocation,
  getLineInfo: getLineInfo,
  Node: Node,
  TokenType: TokenType,
  tokTypes: types$1,
  keywordTypes: keywords$2,
  TokContext: TokContext,
  tokContexts: types$2,
  isIdentifierChar: isIdentifierChar,
  isIdentifierStart: isIdentifierStart$1,
  Token: Token,
  isNewLine: isNewLine,
  lineBreak: lineBreak,
  lineBreakG: lineBreakG,
  nonASCIIwhitespace: nonASCIIwhitespace
};

// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse$_(input, options) {
  return Parser$2.parse(input, options)
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt$1(input, pos, options) {
  return Parser$2.parseExpressionAt(input, pos, options)
}

const regex_whitespace = /\s/;
const regex_starts_with_whitespaces = /^[ \t\r\n]*/;
const regex_ends_with_whitespaces = /[ \t\r\n]*$/;
const regex_not_newline_characters = /[^\n]/g;

const regex_svelte_ignore = /^\s*svelte-ignore\s+([\s\S]+)\s*$/m;

/**
 * @param {string} text
 * @returns {string[]}
 */
function extract_svelte_ignore(text) {
	const match = regex_svelte_ignore.exec(text);
	return match
		? match[1]
				.split(regex_whitespace)
				.map((x) => x.trim())
				.filter(Boolean)
		: [];
}

/**
 * @param {string} name
 * @param {string[]} names
 */
function fuzzymatch(name, names) {
	const set = new FuzzySet(names);
	const matches = set.get(name);
	return matches && matches[0] && matches[0][0] > 0.7 ? matches[0][1] : null;
}

// adapted from https://github.com/Glench/fuzzyset.js/blob/master/lib/fuzzyset.js
// BSD Licensed
const GRAM_SIZE_LOWER = 2;
const GRAM_SIZE_UPPER = 3;
// return an edit distance from 0 to 1

/**
 * @param {string} str1
 * @param {string} str2
 */
function _distance(str1, str2) {
	if (str1 === null && str2 === null) {
		throw 'Trying to compare two null values';
	}
	if (str1 === null || str2 === null) return 0;
	str1 = String(str1);
	str2 = String(str2);
	const distance = levenshtein(str1, str2);
	if (str1.length > str2.length) {
		return 1 - distance / str1.length;
	} else {
		return 1 - distance / str2.length;
	}
}

// helper functions

/**
 * @param {string} str1
 * @param {string} str2
 */
function levenshtein(str1, str2) {
	/**
	 * @type {number[]}
	 */
	const current = [];
	let prev;
	let value;
	for (let i = 0; i <= str2.length; i++) {
		for (let j = 0; j <= str1.length; j++) {
			if (i && j) {
				if (str1.charAt(j - 1) === str2.charAt(i - 1)) {
					value = prev;
				} else {
					value = Math.min(current[j], current[j - 1], prev) + 1;
				}
			} else {
				value = i + j;
			}
			prev = current[j];
			current[j] = value;
		}
	}
	return current.pop();
}

const non_word_regex = /[^\w, ]+/;

/**
 * @param {string} value
 * @param {any} gram_size
 */
function iterate_grams(value, gram_size = 2) {
	const simplified = '-' + value.toLowerCase().replace(non_word_regex, '') + '-';
	const len_diff = gram_size - simplified.length;
	const results = [];
	if (len_diff > 0) {
		for (let i = 0; i < len_diff; ++i) {
			value += '-';
		}
	}
	for (let i = 0; i < simplified.length - gram_size + 1; ++i) {
		results.push(simplified.slice(i, i + gram_size));
	}
	return results;
}

/**
 * @param {string} value
 * @param {any} gram_size
 */
function gram_counter(value, gram_size = 2) {
	// return an object where key=gram, value=number of occurrences
	const result = {};
	const grams = iterate_grams(value, gram_size);
	let i = 0;
	for (i; i < grams.length; ++i) {
		if (grams[i] in result) {
			result[grams[i]] += 1;
		} else {
			result[grams[i]] = 1;
		}
	}
	return result;
}

/**
 * @param {any} a
 * @param {any} b
 */
function sort_descending(a, b) {
	return b[0] - a[0];
}

class FuzzySet {
	exact_set = {};
	match_dict = {};
	items = {};

	/**
	 * @param {string[]} arr
	 */
	constructor(arr) {
		// initialization
		for (let i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i) {
			this.items[i] = [];
		}
		// add all the items to the set
		for (let i = 0; i < arr.length; ++i) {
			this.add(arr[i]);
		}
	}

	/**
	 * @param {string} value
	 */
	add(value) {
		const normalized_value = value.toLowerCase();
		if (normalized_value in this.exact_set) {
			return false;
		}
		let i = GRAM_SIZE_LOWER;
		for (i; i < GRAM_SIZE_UPPER + 1; ++i) {
			this._add(value, i);
		}
	}

	/**
	 * @param {string} value
	 * @param {number} gram_size
	 */
	_add(value, gram_size) {
		const normalized_value = value.toLowerCase();
		const items = this.items[gram_size] || [];
		const index = items.length;
		items.push(0);
		const gram_counts = gram_counter(normalized_value, gram_size);
		let sum_of_square_gram_counts = 0;
		let gram;
		let gram_count;
		for (gram in gram_counts) {
			gram_count = gram_counts[gram];
			sum_of_square_gram_counts += Math.pow(gram_count, 2);
			if (gram in this.match_dict) {
				this.match_dict[gram].push([index, gram_count]);
			} else {
				this.match_dict[gram] = [[index, gram_count]];
			}
		}
		const vector_normal = Math.sqrt(sum_of_square_gram_counts);
		items[index] = [vector_normal, normalized_value];
		this.items[gram_size] = items;
		this.exact_set[normalized_value] = value;
	}

	/**
	 * @param {string} value
	 */
	get(value) {
		const normalized_value = value.toLowerCase();
		const result = this.exact_set[normalized_value];
		if (result) {
			return [[1, result]];
		}
		let results = [];
		// start with high gram size and if there are no results, go to lower gram sizes
		for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) {
			results = this.__get(value, gram_size);
			if (results) {
				return results;
			}
		}
		return null;
	}

	/**
	 * @param {string} value
	 * @param {number} gram_size
	 */
	__get(value, gram_size) {
		const normalized_value = value.toLowerCase();
		const matches = {};
		const gram_counts = gram_counter(normalized_value, gram_size);
		const items = this.items[gram_size];
		let sum_of_square_gram_counts = 0;
		let gram;
		let gram_count;
		let i;
		let index;
		let other_gram_count;
		for (gram in gram_counts) {
			gram_count = gram_counts[gram];
			sum_of_square_gram_counts += Math.pow(gram_count, 2);
			if (gram in this.match_dict) {
				for (i = 0; i < this.match_dict[gram].length; ++i) {
					index = this.match_dict[gram][i][0];
					other_gram_count = this.match_dict[gram][i][1];
					if (index in matches) {
						matches[index] += gram_count * other_gram_count;
					} else {
						matches[index] = gram_count * other_gram_count;
					}
				}
			}
		}
		const vector_normal = Math.sqrt(sum_of_square_gram_counts);
		let results = [];
		let match_score;
		// build a results list of [score, str]
		for (const match_index in matches) {
			match_score = matches[match_index];
			results.push([match_score / (vector_normal * items[match_index][0]), items[match_index][1]]);
		}
		results.sort(sort_descending);
		let new_results = [];
		const end_index = Math.min(50, results.length);
		// truncate somewhat arbitrarily to 50
		for (let i = 0; i < end_index; ++i) {
			new_results.push([_distance(results[i][1], normalized_value), results[i][1]]);
		}
		results = new_results;
		results.sort(sort_descending);
		new_results = [];
		for (let i = 0; i < results.length; ++i) {
			if (results[i][0] == results[0][0]) {
				new_results.push([results[i][0], this.exact_set[results[i][1]]]);
			}
		}
		return new_results;
	}
}

/** regex of all html void element names */
const void_element_names =
	/^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;

/**
 * @param {string} name
 * @returns {boolean}
 */
function is_void(name) {
	return void_element_names.test(name) || name.toLowerCase() === '!doctype';
}

/**
 * @param {string[]} items
 * @param {string} [conjunction]
 */
function list$2(items, conjunction = 'or') {
	if (items.length === 1) return items[0];
	return `${items.slice(0, -1).join(', ')} ${conjunction} ${items[items.length - 1]}`;
}

// All parser errors should be listed and accessed from here

/**
 * @internal
 */
var parser_errors = {
	/**
	 * @param {string} message
	 */
	css_syntax_error: (message) => ({
		code: 'css-syntax-error',
		message
	}),
	duplicate_attribute: {
		code: 'duplicate-attribute',
		message: 'Attributes need to be unique'
	},
	/**
	 * @param {string} slug
	 * @param {string} name
	 */
	duplicate_element: (slug, name) => ({
		code: `duplicate-${slug}`,
		message: `A component can only have one <${name}> tag`
	}),
	duplicate_style: {
		code: 'duplicate-style',
		message: 'You can only have one top-level <style> tag per component'
	},
	empty_attribute_shorthand: {
		code: 'empty-attribute-shorthand',
		message: 'Attribute shorthand cannot be empty'
	},
	/**
	 * @param {string} type
	 */
	empty_directive_name: (type) => ({
		code: 'empty-directive-name',
		message: `${type} name cannot be empty`
	}),
	empty_global_selector: {
		code: 'css-syntax-error',
		message: ':global() must contain a selector'
	},
	expected_block_type: {
		code: 'expected-block-type',
		message: 'Expected if, each or await'
	},
	expected_name: {
		code: 'expected-name',
		message: 'Expected name'
	},
	/** @param {string} block */
	invalid_catch_placement_unclosed_block: (block) => ({
		code: 'invalid-catch-placement',
		message: `Expected to close ${block} before seeing {:catch} block`
	}),
	invalid_catch_placement_without_await: {
		code: 'invalid-catch-placement',
		message: 'Cannot have an {:catch} block outside an {#await ...} block'
	},
	invalid_component_definition: {
		code: 'invalid-component-definition',
		message: 'invalid component definition'
	},
	/**
	 * @param {string} name
	 */
	invalid_closing_tag_unopened: (name) => ({
		code: 'invalid-closing-tag',
		message: `</${name}> attempted to close an element that was not open`
	}),
	/**
	 * @param {string} name
	 * @param {string} reason
	 */
	invalid_closing_tag_autoclosed: (name, reason) => ({
		code: 'invalid-closing-tag',
		message: `</${name}> attempted to close <${name}> that was already automatically closed by <${reason}>`
	}),
	invalid_debug_args: {
		code: 'invalid-debug-args',
		message: '{@debug ...} arguments must be identifiers, not arbitrary expressions'
	},
	invalid_declaration: {
		code: 'invalid-declaration',
		message: 'Declaration cannot be empty'
	},
	invalid_directive_value: {
		code: 'invalid-directive-value',
		message: 'Directive value must be a JavaScript expression enclosed in curly braces'
	},
	invalid_elseif: {
		code: 'invalid-elseif',
		message: "'elseif' should be 'else if'"
	},
	invalid_elseif_placement_outside_if: {
		code: 'invalid-elseif-placement',
		message: 'Cannot have an {:else if ...} block outside an {#if ...} block'
	},
	/**
	 * @param {string} block
	 */
	invalid_elseif_placement_unclosed_block: (block) => ({
		code: 'invalid-elseif-placement',
		message: `Expected to close ${block} before seeing {:else if ...} block`
	}),
	invalid_else_placement_outside_if: {
		code: 'invalid-else-placement',
		message: 'Cannot have an {:else} block outside an {#if ...} or {#each ...} block'
	},
	/**
	 * @param {string} block
	 */
	invalid_else_placement_unclosed_block: (block) => ({
		code: 'invalid-else-placement',
		message: `Expected to close ${block} before seeing {:else} block`
	}),
	/**
	 * @param {string} slug
	 * @param {string} name
	 */
	invalid_element_content: (slug, name) => ({
		code: `invalid-${slug}-content`,
		message: `<${name}> cannot have children`
	}),
	invalid_element_definition: {
		code: 'invalid-element-definition',
		message: 'Invalid element definition'
	},
	/**
	 * @param {string} slug
	 * @param {string} name
	 */
	invalid_element_placement: (slug, name) => ({
		code: `invalid-${slug}-placement`,
		message: `<${name}> tags cannot be inside elements or blocks`
	}),
	/**
	 * @param {string} location
	 * @param {string} name
	 */
	invalid_logic_block_placement: (location, name) => ({
		code: 'invalid-logic-block-placement',
		message: `{#${name}} logic block cannot be ${location}`
	}),
	/**
	 * @param {string} location
	 * @param {string} name
	 */
	invalid_tag_placement: (location, name) => ({
		code: 'invalid-tag-placement',
		message: `{@${name}} tag cannot be ${location}`
	}),
	/**
	 * @param {string} name
	 */
	invalid_ref_directive: (name) => ({
		code: 'invalid-ref-directive',
		message: `The ref directive is no longer supported — use \`bind:this={${name}}\` instead`
	}),
	invalid_ref_selector: {
		code: 'invalid-ref-selector',
		message: 'ref selectors are no longer supported'
	},
	invalid_self_placement: {
		code: 'invalid-self-placement',
		message:
			'<svelte:self> components can only exist inside {#if} blocks, {#each} blocks, or slots passed to components'
	},
	invalid_script_instance: {
		code: 'invalid-script',
		message: 'A component can only have one instance-level <script> element'
	},
	invalid_script_module: {
		code: 'invalid-script',
		message: 'A component can only have one <script context="module"> element'
	},
	invalid_script_context_attribute: {
		code: 'invalid-script',
		message: 'context attribute must be static'
	},
	invalid_script_context_value: {
		code: 'invalid-script',
		message: 'If the context attribute is supplied, its value must be "module"'
	},
	invalid_tag_name: {
		code: 'invalid-tag-name',
		message: 'Expected valid tag name'
	},
	/**
	 * @param {string[]} tags
	 * @param {string} match
	 */
	invalid_tag_name_svelte_element: (tags, match) => ({
		code: 'invalid-tag-name',
		message: `Valid <svelte:...> tag names are ${list$2(tags)}${
			match ? ' (did you mean ' + match + '?)' : ''
		}`
	}),
	/** @param {string} block */
	invalid_then_placement_unclosed_block: (block) => ({
		code: 'invalid-then-placement',
		message: `Expected to close ${block} before seeing {:then} block`
	}),
	invalid_then_placement_without_await: {
		code: 'invalid-then-placement',
		message: 'Cannot have an {:then} block outside an {#await ...} block'
	},
	/**
	 * @param {string} name
	 */
	invalid_void_content: (name) => ({
		code: 'invalid-void-content',
		message: `<${name}> is a void element and cannot have children, or a closing tag`
	}),
	missing_component_definition: {
		code: 'missing-component-definition',
		message: "<svelte:component> must have a 'this' attribute"
	},
	missing_attribute_value: {
		code: 'missing-attribute-value',
		message: 'Expected value for the attribute'
	},
	missing_element_definition: {
		code: 'missing-element-definition',
		message: "<svelte:element> must have a 'this' attribute"
	},
	unclosed_script: {
		code: 'unclosed-script',
		message: '<script> must have a closing tag'
	},
	unclosed_style: {
		code: 'unclosed-style',
		message: '<style> must have a closing tag'
	},
	unclosed_comment: {
		code: 'unclosed-comment',
		message: 'comment was left open, expected -->'
	},
	/**
	 * @param {string} token
	 */
	unclosed_attribute_value: (token) => ({
		code: 'unclosed-attribute-value',
		message: `Expected to close the attribute value with ${token}`
	}),
	unexpected_block_close: {
		code: 'unexpected-block-close',
		message: 'Unexpected block closing tag'
	},
	unexpected_eof: {
		code: 'unexpected-eof',
		message: 'Unexpected end of input'
	},
	/**
	 * @param {string} token
	 */
	unexpected_eof_token: (token) => ({
		code: 'unexpected-eof',
		message: `Unexpected ${token}`
	}),
	/**
	 * @param {string} token
	 */
	unexpected_token: (token) => ({
		code: 'unexpected-token',
		message: `Expected ${token}`
	}),
	unexpected_token_destructure: {
		code: 'unexpected-token',
		message: 'Expected identifier or destructure pattern'
	}
};

/**
 * @typedef { import('estree').Node} Node
 * @typedef {{
 *   skip: () => void;
 *   remove: () => void;
 *   replace: (node: Node) => void;
 * }} WalkerContext
 */

class WalkerBase {
	constructor() {
		/** @type {boolean} */
		this.should_skip = false;

		/** @type {boolean} */
		this.should_remove = false;

		/** @type {Node | null} */
		this.replacement = null;

		/** @type {WalkerContext} */
		this.context = {
			skip: () => (this.should_skip = true),
			remove: () => (this.should_remove = true),
			replace: (node) => (this.replacement = node)
		};
	}

	/**
	 * @template {Node} Parent
	 * @param {Parent | null | undefined} parent
	 * @param {keyof Parent | null | undefined} prop
	 * @param {number | null | undefined} index
	 * @param {Node} node
	 */
	replace(parent, prop, index, node) {
		if (parent && prop) {
			if (index != null) {
				/** @type {Array<Node>} */ (parent[prop])[index] = node;
			} else {
				/** @type {Node} */ (parent[prop]) = node;
			}
		}
	}

	/**
	 * @template {Node} Parent
	 * @param {Parent | null | undefined} parent
	 * @param {keyof Parent | null | undefined} prop
	 * @param {number | null | undefined} index
	 */
	remove(parent, prop, index) {
		if (parent && prop) {
			if (index !== null && index !== undefined) {
				/** @type {Array<Node>} */ (parent[prop]).splice(index, 1);
			} else {
				delete parent[prop];
			}
		}
	}
}

/**
 * @typedef { import('estree').Node} Node
 * @typedef { import('./walker.js').WalkerContext} WalkerContext
 * @typedef {(
 *    this: WalkerContext,
 *    node: Node,
 *    parent: Node | null,
 *    key: string | number | symbol | null | undefined,
 *    index: number | null | undefined
 * ) => void} SyncHandler
 */

class SyncWalker extends WalkerBase {
	/**
	 *
	 * @param {SyncHandler} [enter]
	 * @param {SyncHandler} [leave]
	 */
	constructor(enter, leave) {
		super();

		/** @type {boolean} */
		this.should_skip = false;

		/** @type {boolean} */
		this.should_remove = false;

		/** @type {Node | null} */
		this.replacement = null;

		/** @type {WalkerContext} */
		this.context = {
			skip: () => (this.should_skip = true),
			remove: () => (this.should_remove = true),
			replace: (node) => (this.replacement = node)
		};

		/** @type {SyncHandler | undefined} */
		this.enter = enter;

		/** @type {SyncHandler | undefined} */
		this.leave = leave;
	}

	/**
	 * @template {Node} Parent
	 * @param {Node} node
	 * @param {Parent | null} parent
	 * @param {keyof Parent} [prop]
	 * @param {number | null} [index]
	 * @returns {Node | null}
	 */
	visit(node, parent, prop, index) {
		if (node) {
			if (this.enter) {
				const _should_skip = this.should_skip;
				const _should_remove = this.should_remove;
				const _replacement = this.replacement;
				this.should_skip = false;
				this.should_remove = false;
				this.replacement = null;

				this.enter.call(this.context, node, parent, prop, index);

				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}

				if (this.should_remove) {
					this.remove(parent, prop, index);
				}

				const skipped = this.should_skip;
				const removed = this.should_remove;

				this.should_skip = _should_skip;
				this.should_remove = _should_remove;
				this.replacement = _replacement;

				if (skipped) return node;
				if (removed) return null;
			}

			/** @type {keyof Node} */
			let key;

			for (key in node) {
				/** @type {unknown} */
				const value = node[key];

				if (value && typeof value === 'object') {
					if (Array.isArray(value)) {
						const nodes = /** @type {Array<unknown>} */ (value);
						for (let i = 0; i < nodes.length; i += 1) {
							const item = nodes[i];
							if (isNode(item)) {
								if (!this.visit(item, node, key, i)) {
									// removed
									i--;
								}
							}
						}
					} else if (isNode(value)) {
						this.visit(value, node, key, null);
					}
				}
			}

			if (this.leave) {
				const _replacement = this.replacement;
				const _should_remove = this.should_remove;
				this.replacement = null;
				this.should_remove = false;

				this.leave.call(this.context, node, parent, prop, index);

				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}

				if (this.should_remove) {
					this.remove(parent, prop, index);
				}

				const removed = this.should_remove;

				this.replacement = _replacement;
				this.should_remove = _should_remove;

				if (removed) return null;
			}
		}

		return node;
	}
}

/**
 * Ducktype a node.
 *
 * @param {unknown} value
 * @returns {value is Node}
 */
function isNode(value) {
	return (
		value !== null && typeof value === 'object' && 'type' in value && typeof value.type === 'string'
	);
}

/**
 * @typedef {import('estree').Node} Node
 * @typedef {import('./sync.js').SyncHandler} SyncHandler
 * @typedef {import('./async.js').AsyncHandler} AsyncHandler
 */

/**
 * @param {Node} ast
 * @param {{
 *   enter?: SyncHandler
 *   leave?: SyncHandler
 * }} walker
 * @returns {Node | null}
 */
function walk$2(ast, { enter, leave }) {
	const instance = new SyncWalker(enter, leave);
	return instance.visit(ast, null);
}

// generate an ID that is, to all intents and purposes, unique
const id = Math.round(Math.random() * 1e20).toString(36);
const re$4 = new RegExp(`_${id}_(?:(\\d+)|(AT)|(HASH))_(\\w+)?`, 'g');

/** @typedef {import('estree').Comment} Comment */
/** @typedef {import('estree').Node} Node */

/**
 * @typedef {Node & {
 *   start: number;
 *   end: number;
 *   has_trailing_newline?: boolean
 * }} NodeWithLocation
 */

/**
 * @typedef {Comment & {
 *   start: number;
 *   end: number;
 *   has_trailing_newline?: boolean
 * }} CommentWithLocation
 */

/**
 * @param {CommentWithLocation[]} comments
 * @param {string} raw
 */
const get_comment_handlers = (comments, raw) => ({
	// pass to acorn options
	/**
	 * @param {boolean} block
	 * @param {string} value
	 * @param {number} start
	 * @param {number} end
	 */
	onComment: (block, value, start, end) => {
		if (block && /\n/.test(value)) {
			let a = start;
			while (a > 0 && raw[a - 1] !== '\n') a -= 1;

			let b = a;
			while (/[ \t]/.test(raw[b])) b += 1;

			const indentation = raw.slice(a, b);
			value = value.replace(new RegExp(`^${indentation}`, 'gm'), '');
		}

		comments.push({ type: block ? 'Block' : 'Line', value, start, end });
	},

	// pass to estree-walker options
	/** @param {NodeWithLocation} node */
	enter(node) {
		let comment;

		while (comments[0] && comments[0].start < node.start) {
			comment = comments.shift();

			comment.value = comment.value.replace(
				re$4,
				(match, id, at, hash, value) => {
					if (hash) return `#${value}`;
					if (at) return `@${value}`;

					return match;
				}
			);

			const next = comments[0] || node;
			comment.has_trailing_newline =
				comment.type === 'Line' ||
				/\n/.test(raw.slice(comment.end, next.start));

			(node.leadingComments || (node.leadingComments = [])).push(comment);
		}
	},

	/** @param {NodeWithLocation} node */
	leave(node) {
		if (comments[0]) {
			const slice = raw.slice(node.end, comments[0].start);

			if (/^[,) \t]*$/.test(slice)) {
				node.trailingComments = [comments.shift()];
			}
		}
	}
});

const chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const intToChar$1 = new Uint8Array(64); // 64 possible chars.
const charToInt$1 = new Uint8Array(128); // z is 122 in ASCII
for (let i = 0; i < chars$1.length; i++) {
    const c = chars$1.charCodeAt(i);
    intToChar$1[i] = c;
    charToInt$1[c] = i;
}

/** @typedef {import('estree').Expression} Expression */
/** @typedef {import('estree').Node} Node */
/** @typedef {import('estree').ObjectExpression} ObjectExpression */
/** @typedef {import('estree').Property} Property */
/** @typedef {import('estree').SpreadElement} SpreadElement */

/** @typedef {import('./utils/comments').CommentWithLocation} CommentWithLocation */

/** @type {Record<string, string>} */
const sigils = {
	'@': 'AT',
	'#': 'HASH'
};

/** @param {TemplateStringsArray} strings */
const join = (strings) => {
	let str = strings[0];
	for (let i = 1; i < strings.length; i += 1) {
		str += `_${id}_${i - 1}_${strings[i]}`;
	}
	return str.replace(
		/([@#])(\w+)/g,
		(_m, sigil, name) => `_${id}_${sigils[sigil]}_${name}`
	);
};

/**
 * @param {any[]} array
 * @param {any[]} target
 */
const flatten_body = (array, target) => {
	for (let i = 0; i < array.length; i += 1) {
		const statement = array[i];
		if (Array.isArray(statement)) {
			flatten_body(statement, target);
			continue;
		}

		if (statement.type === 'ExpressionStatement') {
			if (statement.expression === EMPTY) continue;

			if (Array.isArray(statement.expression)) {
				// TODO this is hacktacular
				let node = statement.expression[0];
				while (Array.isArray(node)) node = node[0];
				if (node) node.leadingComments = statement.leadingComments;

				flatten_body(statement.expression, target);
				continue;
			}

			if (/(Expression|Literal)$/.test(statement.expression.type)) {
				target.push(statement);
				continue;
			}

			if (statement.leadingComments)
				statement.expression.leadingComments = statement.leadingComments;
			if (statement.trailingComments)
				statement.expression.trailingComments = statement.trailingComments;

			target.push(statement.expression);
			continue;
		}

		target.push(statement);
	}

	return target;
};

/**
 * @param {any[]} array
 * @param {any[]} target
 */
const flatten_properties = (array, target) => {
	for (let i = 0; i < array.length; i += 1) {
		const property = array[i];

		if (property.value === EMPTY) continue;

		if (property.key === property.value && Array.isArray(property.key)) {
			flatten_properties(property.key, target);
			continue;
		}

		target.push(property);
	}

	return target;
};

/**
 * @param {any[]} nodes
 * @param {any[]} target
 */
const flatten = (nodes, target) => {
	for (let i = 0; i < nodes.length; i += 1) {
		const node = nodes[i];

		if (node === EMPTY) continue;

		if (Array.isArray(node)) {
			flatten(node, target);
			continue;
		}

		target.push(node);
	}

	return target;
};

const EMPTY = { type: 'Empty' };

/**
 *
 * @param {CommentWithLocation[]} comments
 * @param {string} raw
 * @returns {any}
 */
const acorn_opts = (comments, raw) => {
	const { onComment } = get_comment_handlers(comments, raw);
	return {
		ecmaVersion: 2022,
		sourceType: 'module',
		allowAwaitOutsideFunction: true,
		allowImportExportEverywhere: true,
		allowReturnOutsideFunction: true,
		onComment
	};
};

/**
 * @param {string} raw
 * @param {Node} node
 * @param {any[]} values
 * @param {CommentWithLocation[]} comments
 */
const inject = (raw, node, values, comments) => {
	comments.forEach((comment) => {
		comment.value = comment.value.replace(re$4, (m, i) =>
			+i in values ? values[+i] : m
		);
	});

	const { enter, leave } = get_comment_handlers(comments, raw);

	return walk$2(node, {
		enter,

		/** @param {any} node */
		leave(node) {
			if (node.type === 'Identifier') {
				re$4.lastIndex = 0;
				const match = re$4.exec(node.name);

				if (match) {
					if (match[1]) {
						if (+match[1] in values) {
							let value = values[+match[1]];

							if (typeof value === 'string') {
								value = {
									type: 'Identifier',
									name: value,
									leadingComments: node.leadingComments,
									trailingComments: node.trailingComments
								};
							} else if (typeof value === 'number') {
								value = {
									type: 'Literal',
									value,
									leadingComments: node.leadingComments,
									trailingComments: node.trailingComments
								};
							}

							this.replace(value || EMPTY);
						}
					} else {
						node.name = `${match[2] ? `@` : `#`}${match[4]}`;
					}
				}
			}

			if (node.type === 'Literal') {
				if (typeof node.value === 'string') {
					re$4.lastIndex = 0;
					const new_value = /** @type {string} */ (node.value).replace(
						re$4,
						(m, i) => (+i in values ? values[+i] : m)
					);
					const has_changed = new_value !== node.value;
					node.value = new_value;
					if (has_changed && node.raw) {
						// preserve the quotes
						node.raw = `${node.raw[0]}${JSON.stringify(node.value).slice(
							1,
							-1
						)}${node.raw[node.raw.length - 1]}`;
					}
				}
			}

			if (node.type === 'TemplateElement') {
				re$4.lastIndex = 0;
				node.value.raw = /** @type {string} */ (node.value.raw).replace(
					re$4,
					(m, i) => (+i in values ? values[+i] : m)
				);
			}

			if (node.type === 'Program' || node.type === 'BlockStatement') {
				node.body = flatten_body(node.body, []);
			}

			if (node.type === 'ObjectExpression' || node.type === 'ObjectPattern') {
				node.properties = flatten_properties(node.properties, []);
			}

			if (node.type === 'ArrayExpression' || node.type === 'ArrayPattern') {
				node.elements = flatten(node.elements, []);
			}

			if (
				node.type === 'FunctionExpression' ||
				node.type === 'FunctionDeclaration' ||
				node.type === 'ArrowFunctionExpression'
			) {
				node.params = flatten(node.params, []);
			}

			if (node.type === 'CallExpression' || node.type === 'NewExpression') {
				node.arguments = flatten(node.arguments, []);
			}

			if (
				node.type === 'ImportDeclaration' ||
				node.type === 'ExportNamedDeclaration'
			) {
				node.specifiers = flatten(node.specifiers, []);
			}

			if (node.type === 'ForStatement') {
				node.init = node.init === EMPTY ? null : node.init;
				node.test = node.test === EMPTY ? null : node.test;
				node.update = node.update === EMPTY ? null : node.update;
			}

			leave(node);
		}
	});
};

/**
 *
 * @param {TemplateStringsArray} strings
 * @param  {any[]} values
 * @returns {Expression & { start: Number, end: number }}
 */
function x(strings, ...values) {
	const str = join(strings);

	/** @type {CommentWithLocation[]} */
	const comments = [];

	try {
		let expression =
			/** @type {Expression & { start: Number, end: number }} */ (
				parseExpressionAt$1(str, 0, acorn_opts(comments, str))
			);
		const match = /\S+/.exec(str.slice(expression.end));
		if (match) {
			throw new Error(`Unexpected token '${match[0]}'`);
		}

		expression = /** @type {Expression & { start: Number, end: number }} */ (
			inject(str, expression, values, comments)
		);

		return expression;
	} catch (err) {
		handle_error(str, err);
	}
}

/**
 * @param {string} str
 * @param {Error} err
 */
function handle_error(str, err) {
	// TODO location/code frame

	re$4.lastIndex = 0;

	str = str.replace(re$4, (m, i, at, hash, name) => {
		if (at) return `@${name}`;
		if (hash) return `#${name}`;

		return '${...}';
	});

	console.log(`failed to parse:\n${str}`);
	throw err;
}

/**
 * @param {string} source
 * @param {any} opts
 */
const parse$Z = (source, opts) => {
	/** @type {CommentWithLocation[]} */
	const comments = [];
	const { onComment, enter, leave } = get_comment_handlers(comments, source);
	const ast = /** @type {any} */ (parse$_(source, { onComment, ...opts }));
	walk$2(ast, { enter, leave });
	return ast;
};

/**
 * @param {string} source
 * @param {number} index
 * @param {any} opts
 */
const parseExpressionAt = (source, index, opts) => {
	/** @type {CommentWithLocation[]} */
	const comments = [];
	const { onComment, enter, leave } = get_comment_handlers(comments, source);
	const ast = /** @type {any} */ (
		parseExpressionAt$1(source, index, { onComment, ...opts })
	);
	walk$2(ast, { enter, leave });
	return ast;
};

/**
 * @param {string} source
 */
const parse$Y = (source) =>
	parse$Z(source, {
		sourceType: 'module',
		ecmaVersion: 13,
		locations: true
	});

/**
 * @param {string} source
 * @param {number} index
 */
const parse_expression_at = (source, index) =>
	parseExpressionAt(source, index, {
		sourceType: 'module',
		ecmaVersion: 13,
		locations: true
	});

/**
 * @param {import('../index.js').Parser} parser
 * @returns {import('estree').Node | undefined}
 */
function read_expression(parser) {
	try {
		const node = parse_expression_at(parser.template, parser.index);

		let num_parens = 0;

		for (let i = parser.index; i < node.start; i += 1) {
			if (parser.template[i] === '(') num_parens += 1;
		}

		let index = node.end;
		while (num_parens > 0) {
			const char = parser.template[index];

			if (char === ')') {
				num_parens -= 1;
			} else if (!regex_whitespace.test(char)) {
				parser.error(parser_errors.unexpected_token(')'), index);
			}

			index += 1;
		}

		parser.index = index;

		return node;
	} catch (err) {
		parser.acorn_error(err);
	}
}

const regex_closing_script_tag = /<\/script\s*>/;
const regex_starts_with_closing_script_tag = /^<\/script\s*>/;

/**
 * @param {import('../index.js').Parser} parser
 * @param {any[]} attributes
 * @param {number} start
 * @returns {string}
 */
function get_context(parser, attributes, start) {
	const context = attributes.find((attribute) => attribute.name === 'context');
	if (!context) return 'default';
	if (context.value.length !== 1 || context.value[0].type !== 'Text') {
		parser.error(parser_errors.invalid_script_context_attribute, start);
	}
	const value = context.value[0].data;
	if (value !== 'module') {
		parser.error(parser_errors.invalid_script_context_value, context.start);
	}
	return value;
}

/**
 * @param {import('../index.js').Parser} parser
 * @param {number} start
 * @param {import('estree').Node[]} attributes
 * @returns {import('../../interfaces.js').Script}
 */
function read_script(parser, start, attributes) {
	const script_start = parser.index;
	const data = parser.read_until(regex_closing_script_tag, parser_errors.unclosed_script);
	if (parser.index >= parser.template.length) {
		parser.error(parser_errors.unclosed_script);
	}
	const source =
		parser.template.slice(0, script_start).replace(regex_not_newline_characters, ' ') + data;
	parser.read(regex_starts_with_closing_script_tag);

	/**
	 * @type {import('estree').Program}
	 */
	let ast;
	try {
		ast = parse$Y(source);
	} catch (err) {
		parser.acorn_error(err);
	}
	// TODO is this necessary?
	/** @type {any} */ (ast).start = script_start;
	return {
		type: 'Script',
		start,
		end: parser.index,
		context: get_context(parser, attributes, start),
		content: ast
	};
}

// CSS Syntax Module Level 3
// https://www.w3.org/TR/css-syntax-3/
const EOF$1 = 0;                 // <EOF-token>
const Ident = 1;               // <ident-token>
const Function$2 = 2;            // <function-token>
const AtKeyword = 3;           // <at-keyword-token>
const Hash$1 = 4;                // <hash-token>
const String$2 = 5;              // <string-token>
const BadString = 6;           // <bad-string-token>
const Url$1 = 7;                 // <url-token>
const BadUrl = 8;              // <bad-url-token>
const Delim = 9;               // <delim-token>
const Number$2 = 10;             // <number-token>
const Percentage$1 = 11;         // <percentage-token>
const Dimension$1 = 12;          // <dimension-token>
const WhiteSpace$1 = 13;         // <whitespace-token>
const CDO$1 = 14;                // <CDO-token>
const CDC$1 = 15;                // <CDC-token>
const Colon$1 = 16;              // <colon-token>     :
const Semicolon = 17;          // <semicolon-token> ;
const Comma = 18;              // <comma-token>     ,
const LeftSquareBracket = 19;  // <[-token>
const RightSquareBracket = 20; // <]-token>
const LeftParenthesis = 21;    // <(-token>
const RightParenthesis = 22;   // <)-token>
const LeftCurlyBracket = 23;   // <{-token>
const RightCurlyBracket = 24;  // <}-token>
const Comment$1 = 25;

const EOF = 0;

// https://drafts.csswg.org/css-syntax-3/
// § 4.2. Definitions

// digit
// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
function isDigit(code) {
    return code >= 0x0030 && code <= 0x0039;
}

// hex digit
// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
function isHexDigit(code) {
    return (
        isDigit(code) || // 0 .. 9
        (code >= 0x0041 && code <= 0x0046) || // A .. F
        (code >= 0x0061 && code <= 0x0066)    // a .. f
    );
}

// uppercase letter
// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
function isUppercaseLetter(code) {
    return code >= 0x0041 && code <= 0x005A;
}

// lowercase letter
// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
function isLowercaseLetter(code) {
    return code >= 0x0061 && code <= 0x007A;
}

// letter
// An uppercase letter or a lowercase letter.
function isLetter(code) {
    return isUppercaseLetter(code) || isLowercaseLetter(code);
}

// non-ASCII code point
// A code point with a value equal to or greater than U+0080 <control>.
function isNonAscii(code) {
    return code >= 0x0080;
}

// name-start code point
// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
function isNameStart(code) {
    return isLetter(code) || isNonAscii(code) || code === 0x005F;
}

// name code point
// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
function isName(code) {
    return isNameStart(code) || isDigit(code) || code === 0x002D;
}

// non-printable code point
// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
function isNonPrintable(code) {
    return (
        (code >= 0x0000 && code <= 0x0008) ||
        (code === 0x000B) ||
        (code >= 0x000E && code <= 0x001F) ||
        (code === 0x007F)
    );
}

// newline
// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
// as they are converted to U+000A LINE FEED during preprocessing.
// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
function isNewline(code) {
    return code === 0x000A || code === 0x000D || code === 0x000C;
}

// whitespace
// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
function isWhiteSpace(code) {
    return isNewline(code) || code === 0x0020 || code === 0x0009;
}

// § 4.3.8. Check if two code points are a valid escape
function isValidEscape(first, second) {
    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
    if (first !== 0x005C) {
        return false;
    }

    // Otherwise, if the second code point is a newline or EOF, return false.
    if (isNewline(second) || second === EOF) {
        return false;
    }

    // Otherwise, return true.
    return true;
}

// § 4.3.9. Check if three code points would start an identifier
function isIdentifierStart(first, second, third) {
    // Look at the first code point:

    // U+002D HYPHEN-MINUS
    if (first === 0x002D) {
        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
        // or the second and third code points are a valid escape, return true. Otherwise, return false.
        return (
            isNameStart(second) ||
            second === 0x002D ||
            isValidEscape(second, third)
        );
    }

    // name-start code point
    if (isNameStart(first)) {
        // Return true.
        return true;
    }

    // U+005C REVERSE SOLIDUS (\)
    if (first === 0x005C) {
        // If the first and second code points are a valid escape, return true. Otherwise, return false.
        return isValidEscape(first, second);
    }

    // anything else
    // Return false.
    return false;
}

// § 4.3.10. Check if three code points would start a number
function isNumberStart(first, second, third) {
    // Look at the first code point:

    // U+002B PLUS SIGN (+)
    // U+002D HYPHEN-MINUS (-)
    if (first === 0x002B || first === 0x002D) {
        // If the second code point is a digit, return true.
        if (isDigit(second)) {
            return 2;
        }

        // Otherwise, if the second code point is a U+002E FULL STOP (.)
        // and the third code point is a digit, return true.
        // Otherwise, return false.
        return second === 0x002E && isDigit(third) ? 3 : 0;
    }

    // U+002E FULL STOP (.)
    if (first === 0x002E) {
        // If the second code point is a digit, return true. Otherwise, return false.
        return isDigit(second) ? 2 : 0;
    }

    // digit
    if (isDigit(first)) {
        // Return true.
        return 1;
    }

    // anything else
    // Return false.
    return 0;
}

//
// Misc
//

// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
function isBOM(code) {
    // UTF-16BE
    if (code === 0xFEFF) {
        return 1;
    }

    // UTF-16LE
    if (code === 0xFFFE) {
        return 1;
    }

    return 0;
}

// Fast code category
// Only ASCII code points has a special meaning, that's why we define a maps for 0..127 codes only
const CATEGORY = new Array(0x80);
const EofCategory = 0x80;
const WhiteSpaceCategory = 0x82;
const DigitCategory = 0x83;
const NameStartCategory = 0x84;
const NonPrintableCategory = 0x85;

for (let i = 0; i < CATEGORY.length; i++) {
    CATEGORY[i] =
        isWhiteSpace(i) && WhiteSpaceCategory ||
        isDigit(i) && DigitCategory ||
        isNameStart(i) && NameStartCategory ||
        isNonPrintable(i) && NonPrintableCategory ||
        i || EofCategory;
}

function charCodeCategory(code) {
    return code < 0x80 ? CATEGORY[code] : NameStartCategory;
}

function getCharCode(source, offset) {
    return offset < source.length ? source.charCodeAt(offset) : 0;
}

function getNewlineLength(source, offset, code) {
    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
        return 2;
    }

    return 1;
}

function cmpChar(testStr, offset, referenceCode) {
    let code = testStr.charCodeAt(offset);

    // code.toLowerCase() for A..Z
    if (isUppercaseLetter(code)) {
        code = code | 32;
    }

    return code === referenceCode;
}

function cmpStr(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
        return false;
    }

    if (start < 0 || end > testStr.length) {
        return false;
    }

    for (let i = start; i < end; i++) {
        const referenceCode = referenceStr.charCodeAt(i - start);
        let testCode = testStr.charCodeAt(i);

        // testCode.toLowerCase() for A..Z
        if (isUppercaseLetter(testCode)) {
            testCode = testCode | 32;
        }

        if (testCode !== referenceCode) {
            return false;
        }
    }

    return true;
}

function findWhiteSpaceStart(source, offset) {
    for (; offset >= 0; offset--) {
        if (!isWhiteSpace(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset + 1;
}

function findWhiteSpaceEnd(source, offset) {
    for (; offset < source.length; offset++) {
        if (!isWhiteSpace(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset;
}

function findDecimalNumberEnd(source, offset) {
    for (; offset < source.length; offset++) {
        if (!isDigit(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset;
}

// § 4.3.7. Consume an escaped code point
function consumeEscaped(source, offset) {
    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
    // that the next input code point has already been verified to be part of a valid escape.
    offset += 2;

    // hex digit
    if (isHexDigit(getCharCode(source, offset - 1))) {
        // Consume as many hex digits as possible, but no more than 5.
        // Note that this means 1-6 hex digits have been consumed in total.
        for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
            if (!isHexDigit(getCharCode(source, offset))) {
                break;
            }
        }

        // If the next input code point is whitespace, consume it as well.
        const code = getCharCode(source, offset);
        if (isWhiteSpace(code)) {
            offset += getNewlineLength(source, offset, code);
        }
    }

    return offset;
}

// §4.3.11. Consume a name
// Note: This algorithm does not do the verification of the first few code points that are necessary
// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
// ensure that the stream starts with an identifier before calling this algorithm.
function consumeName(source, offset) {
    // Let result initially be an empty string.
    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
        const code = source.charCodeAt(offset);

        // name code point
        if (isName(code)) {
            // Append the code point to result.
            continue;
        }

        // the stream starts with a valid escape
        if (isValidEscape(code, getCharCode(source, offset + 1))) {
            // Consume an escaped code point. Append the returned code point to result.
            offset = consumeEscaped(source, offset) - 1;
            continue;
        }

        // anything else
        // Reconsume the current input code point. Return result.
        break;
    }

    return offset;
}

// §4.3.12. Consume a number
function consumeNumber$1(source, offset) {
    let code = source.charCodeAt(offset);

    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
    // consume it and append it to repr.
    if (code === 0x002B || code === 0x002D) {
        code = source.charCodeAt(offset += 1);
    }

    // 3. While the next input code point is a digit, consume it and append it to repr.
    if (isDigit(code)) {
        offset = findDecimalNumberEnd(source, offset + 1);
        code = source.charCodeAt(offset);
    }

    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
    if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {
        // 4.1 Consume them.
        // 4.2 Append them to repr.
        offset += 2;

        // 4.3 Set type to "number".
        // TODO

        // 4.4 While the next input code point is a digit, consume it and append it to repr.

        offset = findDecimalNumberEnd(source, offset);
    }

    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
    if (cmpChar(source, offset, 101 /* e */)) {
        let sign = 0;
        code = source.charCodeAt(offset + 1);

        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
        if (code === 0x002D || code === 0x002B) {
            sign = 1;
            code = source.charCodeAt(offset + 2);
        }

        // ... followed by a digit
        if (isDigit(code)) {
            // 5.1 Consume them.
            // 5.2 Append them to repr.

            // 5.3 Set type to "number".
            // TODO

            // 5.4 While the next input code point is a digit, consume it and append it to repr.
            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
        }
    }

    return offset;
}

// § 4.3.14. Consume the remnants of a bad url
// ... its sole use is to consume enough of the input stream to reach a recovery point
// where normal tokenizing can resume.
function consumeBadUrlRemnants(source, offset) {
    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
        const code = source.charCodeAt(offset);

        // U+0029 RIGHT PARENTHESIS ())
        // EOF
        if (code === 0x0029) {
            // Return.
            offset++;
            break;
        }

        if (isValidEscape(code, getCharCode(source, offset + 1))) {
            // Consume an escaped code point.
            // Note: This allows an escaped right parenthesis ("\)") to be encountered
            // without ending the <bad-url-token>. This is otherwise identical to
            // the "anything else" clause.
            offset = consumeEscaped(source, offset);
        }
    }

    return offset;
}

// § 4.3.7. Consume an escaped code point
// Note: This algorithm assumes that escaped is valid without leading U+005C REVERSE SOLIDUS (\)
function decodeEscaped(escaped) {
    // Single char escaped that's not a hex digit
    if (escaped.length === 1 && !isHexDigit(escaped.charCodeAt(0))) {
        return escaped[0];
    }

    // Interpret the hex digits as a hexadecimal number.
    let code = parseInt(escaped, 16);

    if (
        (code === 0) ||                       // If this number is zero,
        (code >= 0xD800 && code <= 0xDFFF) || // or is for a surrogate,
        (code > 0x10FFFF)                     // or is greater than the maximum allowed code point
    ) {
        // ... return U+FFFD REPLACEMENT CHARACTER
        code = 0xFFFD;
    }

    // Otherwise, return the code point with that value.
    return String.fromCodePoint(code);
}

var tokenNames = [
    'EOF-token',
    'ident-token',
    'function-token',
    'at-keyword-token',
    'hash-token',
    'string-token',
    'bad-string-token',
    'url-token',
    'bad-url-token',
    'delim-token',
    'number-token',
    'percentage-token',
    'dimension-token',
    'whitespace-token',
    'CDO-token',
    'CDC-token',
    'colon-token',
    'semicolon-token',
    'comma-token',
    '[-token',
    ']-token',
    '(-token',
    ')-token',
    '{-token',
    '}-token'
];

const MIN_SIZE = 16 * 1024;

function adoptBuffer(buffer = null, size) {
    if (buffer === null || buffer.length < size) {
        return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
    }

    return buffer;
}

const N$4 = 10;
const F$2 = 12;
const R$2 = 13;

function computeLinesAndColumns(host) {
    const source = host.source;
    const sourceLength = source.length;
    const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
    const lines = adoptBuffer(host.lines, sourceLength);
    const columns = adoptBuffer(host.columns, sourceLength);
    let line = host.startLine;
    let column = host.startColumn;

    for (let i = startOffset; i < sourceLength; i++) {
        const code = source.charCodeAt(i);

        lines[i] = line;
        columns[i] = column++;

        if (code === N$4 || code === R$2 || code === F$2) {
            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$4) {
                i++;
                lines[i] = line;
                columns[i] = column;
            }

            line++;
            column = 1;
        }
    }

    lines[sourceLength] = line;
    columns[sourceLength] = column;

    host.lines = lines;
    host.columns = columns;
    host.computed = true;
}

class OffsetToLocation {
    constructor() {
        this.lines = null;
        this.columns = null;
        this.computed = false;
    }
    setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
        this.source = source;
        this.startOffset = startOffset;
        this.startLine = startLine;
        this.startColumn = startColumn;
        this.computed = false;
    }
    getLocation(offset, filename) {
        if (!this.computed) {
            computeLinesAndColumns(this);
        }

        return {
            source: filename,
            offset: this.startOffset + offset,
            line: this.lines[offset],
            column: this.columns[offset]
        };
    }
    getLocationRange(start, end, filename) {
        if (!this.computed) {
            computeLinesAndColumns(this);
        }

        return {
            source: filename,
            start: {
                offset: this.startOffset + start,
                line: this.lines[start],
                column: this.columns[start]
            },
            end: {
                offset: this.startOffset + end,
                line: this.lines[end],
                column: this.columns[end]
            }
        };
    }
}

const OFFSET_MASK = 0x00FFFFFF;
const TYPE_SHIFT = 24;
const balancePair$1 = new Map([
    [Function$2, RightParenthesis],
    [LeftParenthesis, RightParenthesis],
    [LeftSquareBracket, RightSquareBracket],
    [LeftCurlyBracket, RightCurlyBracket]
]);

class TokenStream {
    constructor(source, tokenize) {
        this.setSource(source, tokenize);
    }
    reset() {
        this.eof = false;
        this.tokenIndex = -1;
        this.tokenType = 0;
        this.tokenStart = this.firstCharOffset;
        this.tokenEnd = this.firstCharOffset;
    }
    setSource(source = '', tokenize = () => {}) {
        source = String(source || '');

        const sourceLength = source.length;
        const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1); // +1 because of eof-token
        const balance = adoptBuffer(this.balance, source.length + 1);
        let tokenCount = 0;
        let balanceCloseType = 0;
        let balanceStart = 0;
        let firstCharOffset = -1;

        // capture buffers
        this.offsetAndType = null;
        this.balance = null;

        tokenize(source, (type, start, end) => {
            switch (type) {
                default:
                    balance[tokenCount] = sourceLength;
                    break;

                case balanceCloseType: {
                    let balancePrev = balanceStart & OFFSET_MASK;
                    balanceStart = balance[balancePrev];
                    balanceCloseType = balanceStart >> TYPE_SHIFT;
                    balance[tokenCount] = balancePrev;
                    balance[balancePrev++] = tokenCount;
                    for (; balancePrev < tokenCount; balancePrev++) {
                        if (balance[balancePrev] === sourceLength) {
                            balance[balancePrev] = tokenCount;
                        }
                    }
                    break;
                }

                case LeftParenthesis:
                case Function$2:
                case LeftSquareBracket:
                case LeftCurlyBracket:
                    balance[tokenCount] = balanceStart;
                    balanceCloseType = balancePair$1.get(type);
                    balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                    break;
            }

            offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | end;
            if (firstCharOffset === -1) {
                firstCharOffset = start;
            }
        });

        // finalize buffers
        offsetAndType[tokenCount] = (EOF$1 << TYPE_SHIFT) | sourceLength; // <EOF-token>
        balance[tokenCount] = sourceLength;
        balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
        while (balanceStart !== 0) {
            const balancePrev = balanceStart & OFFSET_MASK;
            balanceStart = balance[balancePrev];
            balance[balancePrev] = sourceLength;
        }

        this.source = source;
        this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
        this.tokenCount = tokenCount;
        this.offsetAndType = offsetAndType;
        this.balance = balance;

        this.reset();
        this.next();
    }

    lookupType(offset) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset] >> TYPE_SHIFT;
        }

        return EOF$1;
    }
    lookupOffset(offset) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset - 1] & OFFSET_MASK;
        }

        return this.source.length;
    }
    lookupValue(offset, referenceStr) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return cmpStr(
                this.source,
                this.offsetAndType[offset - 1] & OFFSET_MASK,
                this.offsetAndType[offset] & OFFSET_MASK,
                referenceStr
            );
        }

        return false;
    }
    getTokenStart(tokenIndex) {
        if (tokenIndex === this.tokenIndex) {
            return this.tokenStart;
        }

        if (tokenIndex > 0) {
            return tokenIndex < this.tokenCount
                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
        }

        return this.firstCharOffset;
    }
    substrToCursor(start) {
        return this.source.substring(start, this.tokenStart);
    }

    isBalanceEdge(pos) {
        return this.balance[this.tokenIndex] < pos;
    }
    isDelim(code, offset) {
        if (offset) {
            return (
                this.lookupType(offset) === Delim &&
                this.source.charCodeAt(this.lookupOffset(offset)) === code
            );
        }

        return (
            this.tokenType === Delim &&
            this.source.charCodeAt(this.tokenStart) === code
        );
    }

    skip(tokenCount) {
        let next = this.tokenIndex + tokenCount;

        if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.tokenIndex = this.tokenCount;
            this.next();
        }
    }
    next() {
        let next = this.tokenIndex + 1;

        if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.tokenEnd;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.eof = true;
            this.tokenIndex = this.tokenCount;
            this.tokenType = EOF$1;
            this.tokenStart = this.tokenEnd = this.source.length;
        }
    }
    skipSC() {
        while (this.tokenType === WhiteSpace$1 || this.tokenType === Comment$1) {
            this.next();
        }
    }
    skipUntilBalanced(startToken, stopConsume) {
        let cursor = startToken;
        let balanceEnd;
        let offset;

        loop:
        for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];

            // stop scanning on balance edge that points to offset before start token
            if (balanceEnd < startToken) {
                break loop;
            }

            offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;

            // check stop condition
            switch (stopConsume(this.source.charCodeAt(offset))) {
                case 1: // just stop
                    break loop;

                case 2: // stop & included
                    cursor++;
                    break loop;

                default:
                    // fast forward to the end of balanced block
                    if (this.balance[balanceEnd] === cursor) {
                        cursor = balanceEnd;
                    }
            }
        }

        this.skip(cursor - this.tokenIndex);
    }

    forEachToken(fn) {
        for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
            const start = offset;
            const item = this.offsetAndType[i];
            const end = item & OFFSET_MASK;
            const type = item >> TYPE_SHIFT;

            offset = end;

            fn(type, start, end, i);
        }
    }
    dump() {
        const tokens = new Array(this.tokenCount);

        this.forEachToken((type, start, end, index) => {
            tokens[index] = {
                idx: index,
                type: tokenNames[type],
                chunk: this.source.substring(start, end),
                balance: this.balance[index]
            };
        });

        return tokens;
    }
}

function tokenize$2(source, onToken) {
    function getCharCode(offset) {
        return offset < sourceLength ? source.charCodeAt(offset) : 0;
    }

    // § 4.3.3. Consume a numeric token
    function consumeNumericToken() {
        // Consume a number and let number be the result.
        offset = consumeNumber$1(source, offset);

        // If the next 3 input code points would start an identifier, then:
        if (isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
            // Consume a name. Set the <dimension-token>’s unit to the returned value.
            // Return the <dimension-token>.
            type = Dimension$1;
            offset = consumeName(source, offset);
            return;
        }

        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
        if (getCharCode(offset) === 0x0025) {
            // Create a <percentage-token> with the same value as number, and return it.
            type = Percentage$1;
            offset++;
            return;
        }

        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
        type = Number$2;
    }

    // § 4.3.4. Consume an ident-like token
    function consumeIdentLikeToken() {
        const nameStartOffset = offset;

        // Consume a name, and let string be the result.
        offset = consumeName(source, offset);

        // If string’s value is an ASCII case-insensitive match for "url",
        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
        if (cmpStr(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
            // While the next two input code points are whitespace, consume the next input code point.
            offset = findWhiteSpaceEnd(source, offset + 1);

            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
            // then create a <function-token> with its value set to string and return it.
            if (getCharCode(offset) === 0x0022 ||
                getCharCode(offset) === 0x0027) {
                type = Function$2;
                offset = nameStartOffset + 4;
                return;
            }

            // Otherwise, consume a url token, and return it.
            consumeUrlToken();
            return;
        }

        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
        // Create a <function-token> with its value set to string and return it.
        if (getCharCode(offset) === 0x0028) {
            type = Function$2;
            offset++;
            return;
        }

        // Otherwise, create an <ident-token> with its value set to string and return it.
        type = Ident;
    }

    // § 4.3.5. Consume a string token
    function consumeStringToken(endingCodePoint) {
        // This algorithm may be called with an ending code point, which denotes the code point
        // that ends the string. If an ending code point is not specified,
        // the current input code point is used.
        if (!endingCodePoint) {
            endingCodePoint = getCharCode(offset++);
        }

        // Initially create a <string-token> with its value set to the empty string.
        type = String$2;

        // Repeatedly consume the next input code point from the stream:
        for (; offset < source.length; offset++) {
            const code = source.charCodeAt(offset);

            switch (charCodeCategory(code)) {
                // ending code point
                case endingCodePoint:
                    // Return the <string-token>.
                    offset++;
                    return;

                    // EOF
                    // case EofCategory:
                    // This is a parse error. Return the <string-token>.
                    // return;

                // newline
                case WhiteSpaceCategory:
                    if (isNewline(code)) {
                        // This is a parse error. Reconsume the current input code point,
                        // create a <bad-string-token>, and return it.
                        offset += getNewlineLength(source, offset, code);
                        type = BadString;
                        return;
                    }
                    break;

                // U+005C REVERSE SOLIDUS (\)
                case 0x005C:
                    // If the next input code point is EOF, do nothing.
                    if (offset === source.length - 1) {
                        break;
                    }

                    const nextCode = getCharCode(offset + 1);

                    // Otherwise, if the next input code point is a newline, consume it.
                    if (isNewline(nextCode)) {
                        offset += getNewlineLength(source, offset + 1, nextCode);
                    } else if (isValidEscape(code, nextCode)) {
                        // Otherwise, (the stream starts with a valid escape) consume
                        // an escaped code point and append the returned code point to
                        // the <string-token>’s value.
                        offset = consumeEscaped(source, offset) - 1;
                    }
                    break;

                // anything else
                // Append the current input code point to the <string-token>’s value.
            }
        }
    }

    // § 4.3.6. Consume a url token
    // Note: This algorithm assumes that the initial "url(" has already been consumed.
    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
    function consumeUrlToken() {
        // Initially create a <url-token> with its value set to the empty string.
        type = Url$1;

        // Consume as much whitespace as possible.
        offset = findWhiteSpaceEnd(source, offset);

        // Repeatedly consume the next input code point from the stream:
        for (; offset < source.length; offset++) {
            const code = source.charCodeAt(offset);

            switch (charCodeCategory(code)) {
                // U+0029 RIGHT PARENTHESIS ())
                case 0x0029:
                    // Return the <url-token>.
                    offset++;
                    return;

                    // EOF
                    // case EofCategory:
                    // This is a parse error. Return the <url-token>.
                    // return;

                // whitespace
                case WhiteSpaceCategory:
                    // Consume as much whitespace as possible.
                    offset = findWhiteSpaceEnd(source, offset);

                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
                    // consume it and return the <url-token>
                    // (if EOF was encountered, this is a parse error);
                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
                        if (offset < source.length) {
                            offset++;
                        }
                        return;
                    }

                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
                    // and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = BadUrl;
                    return;

                // U+0022 QUOTATION MARK (")
                // U+0027 APOSTROPHE (')
                // U+0028 LEFT PARENTHESIS (()
                // non-printable code point
                case 0x0022:
                case 0x0027:
                case 0x0028:
                case NonPrintableCategory:
                    // This is a parse error. Consume the remnants of a bad url,
                    // create a <bad-url-token>, and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = BadUrl;
                    return;

                // U+005C REVERSE SOLIDUS (\)
                case 0x005C:
                    // If the stream starts with a valid escape, consume an escaped code point and
                    // append the returned code point to the <url-token>’s value.
                    if (isValidEscape(code, getCharCode(offset + 1))) {
                        offset = consumeEscaped(source, offset) - 1;
                        break;
                    }

                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
                    // create a <bad-url-token>, and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = BadUrl;
                    return;

                // anything else
                // Append the current input code point to the <url-token>’s value.
            }
        }
    }

    // ensure source is a string
    source = String(source || '');

    const sourceLength = source.length;
    let start = isBOM(getCharCode(0));
    let offset = start;
    let type;

    // https://drafts.csswg.org/css-syntax-3/#consume-token
    // § 4.3.1. Consume a token
    while (offset < sourceLength) {
        const code = source.charCodeAt(offset);

        switch (charCodeCategory(code)) {
            // whitespace
            case WhiteSpaceCategory:
                // Consume as much whitespace as possible. Return a <whitespace-token>.
                type = WhiteSpace$1;
                offset = findWhiteSpaceEnd(source, offset + 1);
                break;

            // U+0022 QUOTATION MARK (")
            case 0x0022:
                // Consume a string token and return it.
                consumeStringToken();
                break;

            // U+0023 NUMBER SIGN (#)
            case 0x0023:
                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
                if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // Create a <hash-token>.
                    type = Hash$1;

                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                    //     // TODO: set id flag
                    // }

                    // Consume a name, and set the <hash-token>’s value to the returned string.
                    offset = consumeName(source, offset + 1);

                    // Return the <hash-token>.
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = Delim;
                    offset++;
                }

                break;

            // U+0027 APOSTROPHE (')
            case 0x0027:
                // Consume a string token and return it.
                consumeStringToken();
                break;

            // U+0028 LEFT PARENTHESIS (()
            case 0x0028:
                // Return a <(-token>.
                type = LeftParenthesis;
                offset++;
                break;

            // U+0029 RIGHT PARENTHESIS ())
            case 0x0029:
                // Return a <)-token>.
                type = RightParenthesis;
                offset++;
                break;

            // U+002B PLUS SIGN (+)
            case 0x002B:
                // If the input stream starts with a number, ...
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // ... reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = Delim;
                    offset++;
                }
                break;

            // U+002C COMMA (,)
            case 0x002C:
                // Return a <comma-token>.
                type = Comma;
                offset++;
                break;

            // U+002D HYPHEN-MINUS (-)
            case 0x002D:
                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    consumeNumericToken();
                } else {
                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
                    if (getCharCode(offset + 1) === 0x002D &&
                        getCharCode(offset + 2) === 0x003E) {
                        type = CDC$1;
                        offset = offset + 3;
                    } else {
                        // Otherwise, if the input stream starts with an identifier, ...
                        if (isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                            // ... reconsume the current input code point, consume an ident-like token, and return it.
                            consumeIdentLikeToken();
                        } else {
                            // Otherwise, return a <delim-token> with its value set to the current input code point.
                            type = Delim;
                            offset++;
                        }
                    }
                }
                break;

            // U+002E FULL STOP (.)
            case 0x002E:
                // If the input stream starts with a number, ...
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // ... reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = Delim;
                    offset++;
                }

                break;

            // U+002F SOLIDUS (/)
            case 0x002F:
                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
                if (getCharCode(offset + 1) === 0x002A) {
                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
                    type = Comment$1;
                    offset = source.indexOf('*/', offset + 2);
                    offset = offset === -1 ? source.length : offset + 2;
                } else {
                    type = Delim;
                    offset++;
                }
                break;

            // U+003A COLON (:)
            case 0x003A:
                // Return a <colon-token>.
                type = Colon$1;
                offset++;
                break;

            // U+003B SEMICOLON (;)
            case 0x003B:
                // Return a <semicolon-token>.
                type = Semicolon;
                offset++;
                break;

            // U+003C LESS-THAN SIGN (<)
            case 0x003C:
                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
                if (getCharCode(offset + 1) === 0x0021 &&
                    getCharCode(offset + 2) === 0x002D &&
                    getCharCode(offset + 3) === 0x002D) {
                    // ... consume them and return a <CDO-token>.
                    type = CDO$1;
                    offset = offset + 4;
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = Delim;
                    offset++;
                }

                break;

            // U+0040 COMMERCIAL AT (@)
            case 0x0040:
                // If the next 3 input code points would start an identifier, ...
                if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
                    type = AtKeyword;
                    offset = consumeName(source, offset + 1);
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = Delim;
                    offset++;
                }

                break;

            // U+005B LEFT SQUARE BRACKET ([)
            case 0x005B:
                // Return a <[-token>.
                type = LeftSquareBracket;
                offset++;
                break;

            // U+005C REVERSE SOLIDUS (\)
            case 0x005C:
                // If the input stream starts with a valid escape, ...
                if (isValidEscape(code, getCharCode(offset + 1))) {
                    // ... reconsume the current input code point, consume an ident-like token, and return it.
                    consumeIdentLikeToken();
                } else {
                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
                    type = Delim;
                    offset++;
                }
                break;

            // U+005D RIGHT SQUARE BRACKET (])
            case 0x005D:
                // Return a <]-token>.
                type = RightSquareBracket;
                offset++;
                break;

            // U+007B LEFT CURLY BRACKET ({)
            case 0x007B:
                // Return a <{-token>.
                type = LeftCurlyBracket;
                offset++;
                break;

            // U+007D RIGHT CURLY BRACKET (})
            case 0x007D:
                // Return a <}-token>.
                type = RightCurlyBracket;
                offset++;
                break;

            // digit
            case DigitCategory:
                // Reconsume the current input code point, consume a numeric token, and return it.
                consumeNumericToken();
                break;

            // name-start code point
            case NameStartCategory:
                // Reconsume the current input code point, consume an ident-like token, and return it.
                consumeIdentLikeToken();
                break;

                // EOF
                // case EofCategory:
                // Return an <EOF-token>.
                // break;

            // anything else
            default:
                // Return a <delim-token> with its value set to the current input code point.
                type = Delim;
                offset++;
        }

        // put token to stream
        onToken(type, start, start = offset);
    }
}

//
//                              list
//                            ┌──────┐
//             ┌──────────────┼─head │
//             │              │ tail─┼──────────────┐
//             │              └──────┘              │
//             ▼                                    ▼
//            item        item        item        item
//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
//          │ data │    │ data │    │ data │    │ data │
//          └──────┘    └──────┘    └──────┘    └──────┘
//

let releasedCursors = null;

class List {
    static createItem(data) {
        return {
            prev: null,
            next: null,
            data
        };
    }

    constructor() {
        this.head = null;
        this.tail = null;
        this.cursor = null;
    }
    createItem(data) {
        return List.createItem(data);
    }

    // cursor helpers
    allocateCursor(prev, next) {
        let cursor;

        if (releasedCursors !== null) {
            cursor = releasedCursors;
            releasedCursors = releasedCursors.cursor;
            cursor.prev = prev;
            cursor.next = next;
            cursor.cursor = this.cursor;
        } else {
            cursor = {
                prev,
                next,
                cursor: this.cursor
            };
        }

        this.cursor = cursor;

        return cursor;
    }
    releaseCursor() {
        const { cursor } = this;

        this.cursor = cursor.cursor;
        cursor.prev = null;
        cursor.next = null;
        cursor.cursor = releasedCursors;
        releasedCursors = cursor;
    }
    updateCursors(prevOld, prevNew, nextOld, nextNew) {
        let { cursor } = this;

        while (cursor !== null) {
            if (cursor.prev === prevOld) {
                cursor.prev = prevNew;
            }

            if (cursor.next === nextOld) {
                cursor.next = nextNew;
            }

            cursor = cursor.cursor;
        }
    }
    *[Symbol.iterator]() {
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            yield cursor.data;
        }
    }

    // getters
    get size() {
        let size = 0;

        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            size++;
        }

        return size;
    }
    get isEmpty() {
        return this.head === null;
    }
    get first() {
        return this.head && this.head.data;
    }
    get last() {
        return this.tail && this.tail.data;
    }

    // convertors
    fromArray(array) {
        let cursor = null;
        this.head = null;

        for (let data of array) {
            const item = List.createItem(data);

            if (cursor !== null) {
                cursor.next = item;
            } else {
                this.head = item;
            }

            item.prev = cursor;
            cursor = item;
        }

        this.tail = cursor;
        return this;
    }
    toArray() {
        return [...this];
    }
    toJSON() {
        return [...this];
    }

    // array-like methods
    forEach(fn, thisArg = this) {
        // push cursor
        const cursor = this.allocateCursor(null, this.head);

        while (cursor.next !== null) {
            const item = cursor.next;
            cursor.next = item.next;
            fn.call(thisArg, item.data, item, this);
        }

        // pop cursor
        this.releaseCursor();
    }
    forEachRight(fn, thisArg = this) {
        // push cursor
        const cursor = this.allocateCursor(this.tail, null);

        while (cursor.prev !== null) {
            const item = cursor.prev;
            cursor.prev = item.prev;
            fn.call(thisArg, item.data, item, this);
        }

        // pop cursor
        this.releaseCursor();
    }
    reduce(fn, initialValue, thisArg = this) {
        // push cursor
        let cursor = this.allocateCursor(null, this.head);
        let acc = initialValue;
        let item;

        while (cursor.next !== null) {
            item = cursor.next;
            cursor.next = item.next;

            acc = fn.call(thisArg, acc, item.data, item, this);
        }

        // pop cursor
        this.releaseCursor();

        return acc;
    }
    reduceRight(fn, initialValue, thisArg = this) {
        // push cursor
        let cursor = this.allocateCursor(this.tail, null);
        let acc = initialValue;
        let item;

        while (cursor.prev !== null) {
            item = cursor.prev;
            cursor.prev = item.prev;

            acc = fn.call(thisArg, acc, item.data, item, this);
        }

        // pop cursor
        this.releaseCursor();

        return acc;
    }
    some(fn, thisArg = this) {
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            if (fn.call(thisArg, cursor.data, cursor, this)) {
                return true;
            }
        }

        return false;
    }
    map(fn, thisArg = this) {
        const result = new List();

        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            result.appendData(fn.call(thisArg, cursor.data, cursor, this));
        }

        return result;
    }
    filter(fn, thisArg = this) {
        const result = new List();

        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            if (fn.call(thisArg, cursor.data, cursor, this)) {
                result.appendData(cursor.data);
            }
        }

        return result;
    }

    nextUntil(start, fn, thisArg = this) {
        if (start === null) {
            return;
        }

        // push cursor
        const cursor = this.allocateCursor(null, start);

        while (cursor.next !== null) {
            const item = cursor.next;
            cursor.next = item.next;
            if (fn.call(thisArg, item.data, item, this)) {
                break;
            }
        }

        // pop cursor
        this.releaseCursor();
    }
    prevUntil(start, fn, thisArg = this) {
        if (start === null) {
            return;
        }

        // push cursor
        const cursor = this.allocateCursor(start, null);

        while (cursor.prev !== null) {
            const item = cursor.prev;
            cursor.prev = item.prev;
            if (fn.call(thisArg, item.data, item, this)) {
                break;
            }
        }

        // pop cursor
        this.releaseCursor();
    }

    // mutation
    clear() {
        this.head = null;
        this.tail = null;
    }
    copy() {
        const result = new List();

        for (let data of this) {
            result.appendData(data);
        }

        return result;
    }
    prepend(item) {
        //      head
        //    ^
        // item
        this.updateCursors(null, item, this.head, item);

        // insert to the beginning of the list
        if (this.head !== null) {
            // new item <- first item
            this.head.prev = item;
            // new item -> first item
            item.next = this.head;
        } else {
            // if list has no head, then it also has no tail
            // in this case tail points to the new item
            this.tail = item;
        }

        // head always points to new item
        this.head = item;
        return this;
    }
    prependData(data) {
        return this.prepend(List.createItem(data));
    }
    append(item) {
        return this.insert(item);
    }
    appendData(data) {
        return this.insert(List.createItem(data));
    }
    insert(item, before = null) {
        if (before !== null) {
            // prev   before
            //      ^
            //     item
            this.updateCursors(before.prev, item, before, item);

            if (before.prev === null) {
                // insert to the beginning of list
                if (this.head !== before) {
                    throw new Error('before doesn\'t belong to list');
                }
                // since head points to before therefore list doesn't empty
                // no need to check tail
                this.head = item;
                before.prev = item;
                item.next = before;
                this.updateCursors(null, item);
            } else {
                // insert between two items
                before.prev.next = item;
                item.prev = before.prev;
                before.prev = item;
                item.next = before;
            }
        } else {
            // tail
            //      ^
            //      item
            this.updateCursors(this.tail, item, null, item);

            // insert to the ending of the list
            if (this.tail !== null) {
                // last item -> new item
                this.tail.next = item;
                // last item <- new item
                item.prev = this.tail;
            } else {
                // if list has no tail, then it also has no head
                // in this case head points to new item
                this.head = item;
            }

            // tail always points to new item
            this.tail = item;
        }

        return this;
    }
    insertData(data, before) {
        return this.insert(List.createItem(data), before);
    }
    remove(item) {
        //      item
        //       ^
        // prev     next
        this.updateCursors(item, item.prev, item, item.next);

        if (item.prev !== null) {
            item.prev.next = item.next;
        } else {
            if (this.head !== item) {
                throw new Error('item doesn\'t belong to list');
            }

            this.head = item.next;
        }

        if (item.next !== null) {
            item.next.prev = item.prev;
        } else {
            if (this.tail !== item) {
                throw new Error('item doesn\'t belong to list');
            }

            this.tail = item.prev;
        }

        item.prev = null;
        item.next = null;

        return item;
    }
    push(data) {
        this.insert(List.createItem(data));
    }
    pop() {
        return this.tail !== null ? this.remove(this.tail) : null;
    }
    unshift(data) {
        this.prepend(List.createItem(data));
    }
    shift() {
        return this.head !== null ? this.remove(this.head) : null;
    }
    prependList(list) {
        return this.insertList(list, this.head);
    }
    appendList(list) {
        return this.insertList(list);
    }
    insertList(list, before) {
        // ignore empty lists
        if (list.head === null) {
            return this;
        }

        if (before !== undefined && before !== null) {
            this.updateCursors(before.prev, list.tail, before, list.head);

            // insert in the middle of dist list
            if (before.prev !== null) {
                // before.prev <-> list.head
                before.prev.next = list.head;
                list.head.prev = before.prev;
            } else {
                this.head = list.head;
            }

            before.prev = list.tail;
            list.tail.next = before;
        } else {
            this.updateCursors(this.tail, list.tail, null, list.head);

            // insert to end of the list
            if (this.tail !== null) {
                // if destination list has a tail, then it also has a head,
                // but head doesn't change
                // dest tail -> source head
                this.tail.next = list.head;
                // dest tail <- source head
                list.head.prev = this.tail;
            } else {
                // if list has no a tail, then it also has no a head
                // in this case points head to new item
                this.head = list.head;
            }

            // tail always start point to new item
            this.tail = list.tail;
        }

        list.head = null;
        list.tail = null;
        return this;
    }
    replace(oldItem, newItemOrList) {
        if ('head' in newItemOrList) {
            this.insertList(newItemOrList, oldItem);
        } else {
            this.insert(newItemOrList, oldItem);
        }

        this.remove(oldItem);
    }
}

function createCustomError(name, message) {
    // use Object.create(), because some VMs prevent setting line/column otherwise
    // (iOS Safari 10 even throws an exception)
    const error = Object.create(SyntaxError.prototype);
    const errorStack = new Error();

    return Object.assign(error, {
        name,
        message,
        get stack() {
            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, `${name}: ${message}\n`);
        }
    });
}

const MAX_LINE_LENGTH = 100;
const OFFSET_CORRECTION = 60;
const TAB_REPLACEMENT = '    ';

function sourceFragment({ source, line, column }, extraLines) {
    function processLines(start, end) {
        return lines
            .slice(start, end)
            .map((line, idx) =>
                String(start + idx + 1).padStart(maxNumLength) + ' |' + line
            ).join('\n');
    }

    const lines = source.split(/\r\n?|\n|\f/);
    const startLine = Math.max(1, line - extraLines) - 1;
    const endLine = Math.min(line + extraLines, lines.length + 1);
    const maxNumLength = Math.max(4, String(endLine).length) + 1;
    let cutLeft = 0;

    // column correction according to replaced tab before column
    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

    if (column > MAX_LINE_LENGTH) {
        cutLeft = column - OFFSET_CORRECTION + 3;
        column = OFFSET_CORRECTION - 2;
    }

    for (let i = startLine; i <= endLine; i++) {
        if (i >= 0 && i < lines.length) {
            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
            lines[i] =
                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
        }
    }

    return [
        processLines(startLine, line),
        new Array(column + maxNumLength + 2).join('-') + '^',
        processLines(line, endLine)
    ].filter(Boolean).join('\n');
}

function SyntaxError$2(message, source, offset, line, column) {
    const error = Object.assign(createCustomError('SyntaxError', message), {
        source,
        offset,
        line,
        column,
        sourceFragment(extraLines) {
            return sourceFragment({ source, line, column }, isNaN(extraLines) ? 0 : extraLines);
        },
        get formattedMessage() {
            return (
                `Parse error: ${message}\n` +
                sourceFragment({ source, line, column }, 2)
            );
        }
    });

    return error;
}

function readSequence$1(recognizer) {
    const children = this.createList();
    let space = false;
    const context = {
        recognizer
    };

    while (!this.eof) {
        switch (this.tokenType) {
            case Comment$1:
                this.next();
                continue;

            case WhiteSpace$1:
                space = true;
                this.next();
                continue;
        }

        let child = recognizer.getNode.call(this, context);

        if (child === undefined) {
            break;
        }

        if (space) {
            if (recognizer.onWhiteSpace) {
                recognizer.onWhiteSpace.call(this, child, children, context);
            }
            space = false;
        }

        children.push(child);
    }

    if (space && recognizer.onWhiteSpace) {
        recognizer.onWhiteSpace.call(this, null, children, context);
    }

    return children;
}

const NOOP = () => {};
const EXCLAMATIONMARK$3 = 0x0021;  // U+0021 EXCLAMATION MARK (!)
const NUMBERSIGN$4 = 0x0023;       // U+0023 NUMBER SIGN (#)
const SEMICOLON = 0x003B;        // U+003B SEMICOLON (;)
const LEFTCURLYBRACKET$1 = 0x007B; // U+007B LEFT CURLY BRACKET ({)
const NULL$1 = 0;

function createParseContext(name) {
    return function() {
        return this[name]();
    };
}

function fetchParseValues(dict) {
    const result = Object.create(null);

    for (const name in dict) {
        const item = dict[name];
        const fn = item.parse || item;

        if (fn) {
            result[name] = fn;
        }
    }

    return result;
}

function processConfig(config) {
    const parseConfig = {
        context: Object.create(null),
        scope: Object.assign(Object.create(null), config.scope),
        atrule: fetchParseValues(config.atrule),
        pseudo: fetchParseValues(config.pseudo),
        node: fetchParseValues(config.node)
    };

    for (const name in config.parseContext) {
        switch (typeof config.parseContext[name]) {
            case 'function':
                parseConfig.context[name] = config.parseContext[name];
                break;

            case 'string':
                parseConfig.context[name] = createParseContext(config.parseContext[name]);
                break;
        }
    }

    return {
        config: parseConfig,
        ...parseConfig,
        ...parseConfig.node
    };
}

function createParser(config) {
    let source = '';
    let filename = '<unknown>';
    let needPositions = false;
    let onParseError = NOOP;
    let onParseErrorThrow = false;

    const locationMap = new OffsetToLocation();
    const parser = Object.assign(new TokenStream(), processConfig(config || {}), {
        parseAtrulePrelude: true,
        parseRulePrelude: true,
        parseValue: true,
        parseCustomProperty: false,

        readSequence: readSequence$1,

        consumeUntilBalanceEnd: () => 0,
        consumeUntilLeftCurlyBracket(code) {
            return code === LEFTCURLYBRACKET$1 ? 1 : 0;
        },
        consumeUntilLeftCurlyBracketOrSemicolon(code) {
            return code === LEFTCURLYBRACKET$1 || code === SEMICOLON ? 1 : 0;
        },
        consumeUntilExclamationMarkOrSemicolon(code) {
            return code === EXCLAMATIONMARK$3 || code === SEMICOLON ? 1 : 0;
        },
        consumeUntilSemicolonIncluded(code) {
            return code === SEMICOLON ? 2 : 0;
        },

        createList() {
            return new List();
        },
        createSingleNodeList(node) {
            return new List().appendData(node);
        },
        getFirstListNode(list) {
            return list && list.first;
        },
        getLastListNode(list) {
            return list && list.last;
        },

        parseWithFallback(consumer, fallback) {
            const startToken = this.tokenIndex;

            try {
                return consumer.call(this);
            } catch (e) {
                if (onParseErrorThrow) {
                    throw e;
                }

                const fallbackNode = fallback.call(this, startToken);

                onParseErrorThrow = true;
                onParseError(e, fallbackNode);
                onParseErrorThrow = false;

                return fallbackNode;
            }
        },

        lookupNonWSType(offset) {
            let type;

            do {
                type = this.lookupType(offset++);
                if (type !== WhiteSpace$1) {
                    return type;
                }
            } while (type !== NULL$1);

            return NULL$1;
        },

        charCodeAt(offset) {
            return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
        },
        substring(offsetStart, offsetEnd) {
            return source.substring(offsetStart, offsetEnd);
        },
        substrToCursor(start) {
            return this.source.substring(start, this.tokenStart);
        },

        cmpChar(offset, charCode) {
            return cmpChar(source, offset, charCode);
        },
        cmpStr(offsetStart, offsetEnd, str) {
            return cmpStr(source, offsetStart, offsetEnd, str);
        },

        consume(tokenType) {
            const start = this.tokenStart;

            this.eat(tokenType);

            return this.substrToCursor(start);
        },
        consumeFunctionName() {
            const name = source.substring(this.tokenStart, this.tokenEnd - 1);

            this.eat(Function$2);

            return name;
        },
        consumeNumber(type) {
            const number = source.substring(this.tokenStart, consumeNumber$1(source, this.tokenStart));

            this.eat(type);

            return number;
        },

        eat(tokenType) {
            if (this.tokenType !== tokenType) {
                const tokenName = tokenNames[tokenType].slice(0, -6).replace(/-/g, ' ').replace(/^./, m => m.toUpperCase());
                let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
                let offset = this.tokenStart;

                // tweak message and offset
                switch (tokenType) {
                    case Ident:
                        // when identifier is expected but there is a function or url
                        if (this.tokenType === Function$2 || this.tokenType === Url$1) {
                            offset = this.tokenEnd - 1;
                            message = 'Identifier is expected but function found';
                        } else {
                            message = 'Identifier is expected';
                        }
                        break;

                    case Hash$1:
                        if (this.isDelim(NUMBERSIGN$4)) {
                            this.next();
                            offset++;
                            message = 'Name is expected';
                        }
                        break;

                    case Percentage$1:
                        if (this.tokenType === Number$2) {
                            offset = this.tokenEnd;
                            message = 'Percent sign is expected';
                        }
                        break;
                }

                this.error(message, offset);
            }

            this.next();
        },
        eatIdent(name) {
            if (this.tokenType !== Ident || this.lookupValue(0, name) === false) {
                this.error(`Identifier "${name}" is expected`);
            }

            this.next();
        },
        eatDelim(code) {
            if (!this.isDelim(code)) {
                this.error(`Delim "${String.fromCharCode(code)}" is expected`);
            }

            this.next();
        },

        getLocation(start, end) {
            if (needPositions) {
                return locationMap.getLocationRange(
                    start,
                    end,
                    filename
                );
            }

            return null;
        },
        getLocationFromList(list) {
            if (needPositions) {
                const head = this.getFirstListNode(list);
                const tail = this.getLastListNode(list);
                return locationMap.getLocationRange(
                    head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,
                    tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,
                    filename
                );
            }

            return null;
        },

        error(message, offset) {
            const location = typeof offset !== 'undefined' && offset < source.length
                ? locationMap.getLocation(offset)
                : this.eof
                    ? locationMap.getLocation(findWhiteSpaceStart(source, source.length - 1))
                    : locationMap.getLocation(this.tokenStart);

            throw new SyntaxError$2(
                message || 'Unexpected input',
                source,
                location.offset,
                location.line,
                location.column
            );
        }
    });

    const parse = function(source_, options) {
        source = source_;
        options = options || {};

        parser.setSource(source, tokenize$2);
        locationMap.setSource(
            source,
            options.offset,
            options.line,
            options.column
        );

        filename = options.filename || '<unknown>';
        needPositions = Boolean(options.positions);
        onParseError = typeof options.onParseError === 'function' ? options.onParseError : NOOP;
        onParseErrorThrow = false;

        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

        const { context = 'default', onComment } = options;

        if (context in parser.context === false) {
            throw new Error('Unknown context `' + context + '`');
        }

        if (typeof onComment === 'function') {
            parser.forEachToken((type, start, end) => {
                if (type === Comment$1) {
                    const loc = parser.getLocation(start, end);
                    const value = cmpStr(source, end - 2, end, '*/')
                        ? source.slice(start + 2, end - 2)
                        : source.slice(start + 2, end);

                    onComment(value, loc);
                }
            });
        }

        const ast = parser.context[context].call(parser, options);

        if (!parser.eof) {
            parser.error();
        }

        return ast;
    };

    return Object.assign(parse, {
        SyntaxError: SyntaxError$2,
        config: parser.config
    });
}

var sourceMapGenerator = {};

var base64Vlq = {};

var base64 = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBase64;

function requireBase64 () {
	if (hasRequiredBase64) return base64;
	hasRequiredBase64 = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	base64.encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	base64.decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};
	return base64;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredBase64Vlq;

function requireBase64Vlq () {
	if (hasRequiredBase64Vlq) return base64Vlq;
	hasRequiredBase64Vlq = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	var base64 = requireBase64();

	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	base64Vlq.encode = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};
	return base64Vlq;
}

var util = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	(function (exports) {
		/*
		 * Copyright 2011 Mozilla Foundation and contributors
		 * Licensed under the New BSD license. See LICENSE or:
		 * http://opensource.org/licenses/BSD-3-Clause
		 */

		/**
		 * This is a helper function for getting values from parameter/options
		 * objects.
		 *
		 * @param args The object we are extracting values from
		 * @param name The name of the property we are getting.
		 * @param defaultValue An optional value to return if the property is missing
		 * from the object. If this is not specified and the property is missing, an
		 * error will be thrown.
		 */
		function getArg(aArgs, aName, aDefaultValue) {
		  if (aName in aArgs) {
		    return aArgs[aName];
		  } else if (arguments.length === 3) {
		    return aDefaultValue;
		  } else {
		    throw new Error('"' + aName + '" is a required argument.');
		  }
		}
		exports.getArg = getArg;

		var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
		var dataUrlRegexp = /^data:.+\,.+$/;

		function urlParse(aUrl) {
		  var match = aUrl.match(urlRegexp);
		  if (!match) {
		    return null;
		  }
		  return {
		    scheme: match[1],
		    auth: match[2],
		    host: match[3],
		    port: match[4],
		    path: match[5]
		  };
		}
		exports.urlParse = urlParse;

		function urlGenerate(aParsedUrl) {
		  var url = '';
		  if (aParsedUrl.scheme) {
		    url += aParsedUrl.scheme + ':';
		  }
		  url += '//';
		  if (aParsedUrl.auth) {
		    url += aParsedUrl.auth + '@';
		  }
		  if (aParsedUrl.host) {
		    url += aParsedUrl.host;
		  }
		  if (aParsedUrl.port) {
		    url += ":" + aParsedUrl.port;
		  }
		  if (aParsedUrl.path) {
		    url += aParsedUrl.path;
		  }
		  return url;
		}
		exports.urlGenerate = urlGenerate;

		var MAX_CACHED_INPUTS = 32;

		/**
		 * Takes some function `f(input) -> result` and returns a memoized version of
		 * `f`.
		 *
		 * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
		 * memoization is a dumb-simple, linear least-recently-used cache.
		 */
		function lruMemoize(f) {
		  var cache = [];

		  return function(input) {
		    for (var i = 0; i < cache.length; i++) {
		      if (cache[i].input === input) {
		        var temp = cache[0];
		        cache[0] = cache[i];
		        cache[i] = temp;
		        return cache[0].result;
		      }
		    }

		    var result = f(input);

		    cache.unshift({
		      input,
		      result,
		    });

		    if (cache.length > MAX_CACHED_INPUTS) {
		      cache.pop();
		    }

		    return result;
		  };
		}

		/**
		 * Normalizes a path, or the path portion of a URL:
		 *
		 * - Replaces consecutive slashes with one slash.
		 * - Removes unnecessary '.' parts.
		 * - Removes unnecessary '<dir>/..' parts.
		 *
		 * Based on code in the Node.js 'path' core module.
		 *
		 * @param aPath The path or url to normalize.
		 */
		var normalize = lruMemoize(function normalize(aPath) {
		  var path = aPath;
		  var url = urlParse(aPath);
		  if (url) {
		    if (!url.path) {
		      return aPath;
		    }
		    path = url.path;
		  }
		  var isAbsolute = exports.isAbsolute(path);
		  // Split the path into parts between `/` characters. This is much faster than
		  // using `.split(/\/+/g)`.
		  var parts = [];
		  var start = 0;
		  var i = 0;
		  while (true) {
		    start = i;
		    i = path.indexOf("/", start);
		    if (i === -1) {
		      parts.push(path.slice(start));
		      break;
		    } else {
		      parts.push(path.slice(start, i));
		      while (i < path.length && path[i] === "/") {
		        i++;
		      }
		    }
		  }

		  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
		    part = parts[i];
		    if (part === '.') {
		      parts.splice(i, 1);
		    } else if (part === '..') {
		      up++;
		    } else if (up > 0) {
		      if (part === '') {
		        // The first part is blank if the path is absolute. Trying to go
		        // above the root is a no-op. Therefore we can remove all '..' parts
		        // directly after the root.
		        parts.splice(i + 1, up);
		        up = 0;
		      } else {
		        parts.splice(i, 2);
		        up--;
		      }
		    }
		  }
		  path = parts.join('/');

		  if (path === '') {
		    path = isAbsolute ? '/' : '.';
		  }

		  if (url) {
		    url.path = path;
		    return urlGenerate(url);
		  }
		  return path;
		});
		exports.normalize = normalize;

		/**
		 * Joins two paths/URLs.
		 *
		 * @param aRoot The root path or URL.
		 * @param aPath The path or URL to be joined with the root.
		 *
		 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
		 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
		 *   first.
		 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
		 *   is updated with the result and aRoot is returned. Otherwise the result
		 *   is returned.
		 *   - If aPath is absolute, the result is aPath.
		 *   - Otherwise the two paths are joined with a slash.
		 * - Joining for example 'http://' and 'www.example.com' is also supported.
		 */
		function join(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }
		  if (aPath === "") {
		    aPath = ".";
		  }
		  var aPathUrl = urlParse(aPath);
		  var aRootUrl = urlParse(aRoot);
		  if (aRootUrl) {
		    aRoot = aRootUrl.path || '/';
		  }

		  // `join(foo, '//www.example.org')`
		  if (aPathUrl && !aPathUrl.scheme) {
		    if (aRootUrl) {
		      aPathUrl.scheme = aRootUrl.scheme;
		    }
		    return urlGenerate(aPathUrl);
		  }

		  if (aPathUrl || aPath.match(dataUrlRegexp)) {
		    return aPath;
		  }

		  // `join('http://', 'www.example.com')`
		  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
		    aRootUrl.host = aPath;
		    return urlGenerate(aRootUrl);
		  }

		  var joined = aPath.charAt(0) === '/'
		    ? aPath
		    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

		  if (aRootUrl) {
		    aRootUrl.path = joined;
		    return urlGenerate(aRootUrl);
		  }
		  return joined;
		}
		exports.join = join;

		exports.isAbsolute = function (aPath) {
		  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
		};

		/**
		 * Make a path relative to a URL or another path.
		 *
		 * @param aRoot The root path or URL.
		 * @param aPath The path or URL to be made relative to aRoot.
		 */
		function relative(aRoot, aPath) {
		  if (aRoot === "") {
		    aRoot = ".";
		  }

		  aRoot = aRoot.replace(/\/$/, '');

		  // It is possible for the path to be above the root. In this case, simply
		  // checking whether the root is a prefix of the path won't work. Instead, we
		  // need to remove components from the root one by one, until either we find
		  // a prefix that fits, or we run out of components to remove.
		  var level = 0;
		  while (aPath.indexOf(aRoot + '/') !== 0) {
		    var index = aRoot.lastIndexOf("/");
		    if (index < 0) {
		      return aPath;
		    }

		    // If the only part of the root that is left is the scheme (i.e. http://,
		    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
		    // have exhausted all components, so the path is not relative to the root.
		    aRoot = aRoot.slice(0, index);
		    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
		      return aPath;
		    }

		    ++level;
		  }

		  // Make sure we add a "../" for each component we removed from the root.
		  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
		}
		exports.relative = relative;

		var supportsNullProto = (function () {
		  var obj = Object.create(null);
		  return !('__proto__' in obj);
		}());

		function identity (s) {
		  return s;
		}

		/**
		 * Because behavior goes wacky when you set `__proto__` on objects, we
		 * have to prefix all the strings in our set with an arbitrary character.
		 *
		 * See https://github.com/mozilla/source-map/pull/31 and
		 * https://github.com/mozilla/source-map/issues/30
		 *
		 * @param String aStr
		 */
		function toSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return '$' + aStr;
		  }

		  return aStr;
		}
		exports.toSetString = supportsNullProto ? identity : toSetString;

		function fromSetString(aStr) {
		  if (isProtoString(aStr)) {
		    return aStr.slice(1);
		  }

		  return aStr;
		}
		exports.fromSetString = supportsNullProto ? identity : fromSetString;

		function isProtoString(s) {
		  if (!s) {
		    return false;
		  }

		  var length = s.length;

		  if (length < 9 /* "__proto__".length */) {
		    return false;
		  }

		  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
		      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
		      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
		      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
		      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
		      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
		      s.charCodeAt(length - 9) !== 95  /* '_' */) {
		    return false;
		  }

		  for (var i = length - 10; i >= 0; i--) {
		    if (s.charCodeAt(i) !== 36 /* '$' */) {
		      return false;
		    }
		  }

		  return true;
		}

		/**
		 * Comparator between two mappings where the original positions are compared.
		 *
		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
		 * mappings with the same original source/line/column, but different generated
		 * line and column the same. Useful when searching for a mapping with a
		 * stubbed out mapping.
		 */
		function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
		  var cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0 || onlyCompareOriginal) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByOriginalPositions = compareByOriginalPositions;

		function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
		  var cmp;

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0 || onlyCompareOriginal) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;

		/**
		 * Comparator between two mappings with deflated source and name indices where
		 * the generated positions are compared.
		 *
		 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
		 * mappings with the same generated line and column, but different
		 * source/name/original line and column the same. Useful when searching for a
		 * mapping with a stubbed out mapping.
		 */
		function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0 || onlyCompareGenerated) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

		function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
		  var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0 || onlyCompareGenerated) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;

		function strcmp(aStr1, aStr2) {
		  if (aStr1 === aStr2) {
		    return 0;
		  }

		  if (aStr1 === null) {
		    return 1; // aStr2 !== null
		  }

		  if (aStr2 === null) {
		    return -1; // aStr1 !== null
		  }

		  if (aStr1 > aStr2) {
		    return 1;
		  }

		  return -1;
		}

		/**
		 * Comparator between two mappings with inflated source and name strings where
		 * the generated positions are compared.
		 */
		function compareByGeneratedPositionsInflated(mappingA, mappingB) {
		  var cmp = mappingA.generatedLine - mappingB.generatedLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = strcmp(mappingA.source, mappingB.source);
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalLine - mappingB.originalLine;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  cmp = mappingA.originalColumn - mappingB.originalColumn;
		  if (cmp !== 0) {
		    return cmp;
		  }

		  return strcmp(mappingA.name, mappingB.name);
		}
		exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

		/**
		 * Strip any JSON XSSI avoidance prefix from the string (as documented
		 * in the source maps specification), and then parse the string as
		 * JSON.
		 */
		function parseSourceMapInput(str) {
		  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
		}
		exports.parseSourceMapInput = parseSourceMapInput;

		/**
		 * Compute the URL of a source given the the source root, the source's
		 * URL, and the source map's URL.
		 */
		function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
		  sourceURL = sourceURL || '';

		  if (sourceRoot) {
		    // This follows what Chrome does.
		    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
		      sourceRoot += '/';
		    }
		    // The spec says:
		    //   Line 4: An optional source root, useful for relocating source
		    //   files on a server or removing repeated values in the
		    //   “sources” entry.  This value is prepended to the individual
		    //   entries in the “source” field.
		    sourceURL = sourceRoot + sourceURL;
		  }

		  // Historically, SourceMapConsumer did not take the sourceMapURL as
		  // a parameter.  This mode is still somewhat supported, which is why
		  // this code block is conditional.  However, it's preferable to pass
		  // the source map URL to SourceMapConsumer, so that this function
		  // can implement the source URL resolution algorithm as outlined in
		  // the spec.  This block is basically the equivalent of:
		  //    new URL(sourceURL, sourceMapURL).toString()
		  // ... except it avoids using URL, which wasn't available in the
		  // older releases of node still supported by this library.
		  //
		  // The spec says:
		  //   If the sources are not absolute URLs after prepending of the
		  //   “sourceRoot”, the sources are resolved relative to the
		  //   SourceMap (like resolving script src in a html document).
		  if (sourceMapURL) {
		    var parsed = urlParse(sourceMapURL);
		    if (!parsed) {
		      throw new Error("sourceMapURL could not be parsed");
		    }
		    if (parsed.path) {
		      // Strip the last path component, but keep the "/".
		      var index = parsed.path.lastIndexOf('/');
		      if (index >= 0) {
		        parsed.path = parsed.path.substring(0, index + 1);
		      }
		    }
		    sourceURL = join(urlGenerate(parsed), sourceURL);
		  }

		  return normalize(sourceURL);
		}
		exports.computeSourceURL = computeSourceURL; 
	} (util));
	return util;
}

var arraySet = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredArraySet;

function requireArraySet () {
	if (hasRequiredArraySet) return arraySet;
	hasRequiredArraySet = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = requireUtil();
	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	arraySet.ArraySet = ArraySet;
	return arraySet;
}

var mappingList = {};

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredMappingList;

function requireMappingList () {
	if (hasRequiredMappingList) return mappingList;
	hasRequiredMappingList = 1;
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = requireUtil();

	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	mappingList.MappingList = MappingList;
	return mappingList;
}

/* -*- Mode: js; js-indent-level: 2; -*- */

var hasRequiredSourceMapGenerator;

function requireSourceMapGenerator () {
	if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
	hasRequiredSourceMapGenerator = 1;
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var base64VLQ = requireBase64Vlq();
	var util = requireUtil();
	var ArraySet = requireArraySet().ArraySet;
	var MappingList = requireMappingList().MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	  this._mappings = new MappingList();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet();
	    var newNames = new ArraySet();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64VLQ.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64VLQ.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64VLQ.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64VLQ.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64VLQ.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
	return sourceMapGenerator;
}

var sourceMapGeneratorExports = requireSourceMapGenerator();

const trackNodes = new Set(['Atrule', 'Selector', 'Declaration']);

function generateSourceMap(handlers) {
    const map = new sourceMapGeneratorExports.SourceMapGenerator();
    const generated = {
        line: 1,
        column: 0
    };
    const original = {
        line: 0, // should be zero to add first mapping
        column: 0
    };
    const activatedGenerated = {
        line: 1,
        column: 0
    };
    const activatedMapping = {
        generated: activatedGenerated
    };
    let line = 1;
    let column = 0;
    let sourceMappingActive = false;

    const origHandlersNode = handlers.node;
    handlers.node = function(node) {
        if (node.loc && node.loc.start && trackNodes.has(node.type)) {
            const nodeLine = node.loc.start.line;
            const nodeColumn = node.loc.start.column - 1;

            if (original.line !== nodeLine ||
                original.column !== nodeColumn) {
                original.line = nodeLine;
                original.column = nodeColumn;

                generated.line = line;
                generated.column = column;

                if (sourceMappingActive) {
                    sourceMappingActive = false;
                    if (generated.line !== activatedGenerated.line ||
                        generated.column !== activatedGenerated.column) {
                        map.addMapping(activatedMapping);
                    }
                }

                sourceMappingActive = true;
                map.addMapping({
                    source: node.loc.source,
                    original,
                    generated
                });
            }
        }

        origHandlersNode.call(this, node);

        if (sourceMappingActive && trackNodes.has(node.type)) {
            activatedGenerated.line = line;
            activatedGenerated.column = column;
        }
    };

    const origHandlersEmit = handlers.emit;
    handlers.emit = function(value, type, auto) {
        for (let i = 0; i < value.length; i++) {
            if (value.charCodeAt(i) === 10) { // \n
                line++;
                column = 0;
            } else {
                column++;
            }
        }

        origHandlersEmit(value, type, auto);
    };

    const origHandlersResult = handlers.result;
    handlers.result = function() {
        if (sourceMappingActive) {
            map.addMapping(activatedMapping);
        }

        return {
            css: origHandlersResult(),
            map
        };
    };

    return handlers;
}

const PLUSSIGN$9 = 0x002B;    // U+002B PLUS SIGN (+)
const HYPHENMINUS$6 = 0x002D; // U+002D HYPHEN-MINUS (-)

const code$1 = (type, value) => {
    if (type === Delim) {
        type = value;
    }

    if (typeof type === 'string') {
        const charCode = type.charCodeAt(0);
        return charCode > 0x7F ? 0x8000 : charCode << 8;
    }

    return type;
};

// https://www.w3.org/TR/css-syntax-3/#serialization
// The only requirement for serialization is that it must "round-trip" with parsing,
// that is, parsing the stylesheet must produce the same data structures as parsing,
// serializing, and parsing again, except for consecutive <whitespace-token>s,
// which may be collapsed into a single token.

const specPairs = [
    [Ident, Ident],
    [Ident, Function$2],
    [Ident, Url$1],
    [Ident, BadUrl],
    [Ident, '-'],
    [Ident, Number$2],
    [Ident, Percentage$1],
    [Ident, Dimension$1],
    [Ident, CDC$1],
    [Ident, LeftParenthesis],

    [AtKeyword, Ident],
    [AtKeyword, Function$2],
    [AtKeyword, Url$1],
    [AtKeyword, BadUrl],
    [AtKeyword, '-'],
    [AtKeyword, Number$2],
    [AtKeyword, Percentage$1],
    [AtKeyword, Dimension$1],
    [AtKeyword, CDC$1],

    [Hash$1, Ident],
    [Hash$1, Function$2],
    [Hash$1, Url$1],
    [Hash$1, BadUrl],
    [Hash$1, '-'],
    [Hash$1, Number$2],
    [Hash$1, Percentage$1],
    [Hash$1, Dimension$1],
    [Hash$1, CDC$1],

    [Dimension$1, Ident],
    [Dimension$1, Function$2],
    [Dimension$1, Url$1],
    [Dimension$1, BadUrl],
    [Dimension$1, '-'],
    [Dimension$1, Number$2],
    [Dimension$1, Percentage$1],
    [Dimension$1, Dimension$1],
    [Dimension$1, CDC$1],

    ['#', Ident],
    ['#', Function$2],
    ['#', Url$1],
    ['#', BadUrl],
    ['#', '-'],
    ['#', Number$2],
    ['#', Percentage$1],
    ['#', Dimension$1],
    ['#', CDC$1], // https://github.com/w3c/csswg-drafts/pull/6874

    ['-', Ident],
    ['-', Function$2],
    ['-', Url$1],
    ['-', BadUrl],
    ['-', '-'],
    ['-', Number$2],
    ['-', Percentage$1],
    ['-', Dimension$1],
    ['-', CDC$1], // https://github.com/w3c/csswg-drafts/pull/6874

    [Number$2, Ident],
    [Number$2, Function$2],
    [Number$2, Url$1],
    [Number$2, BadUrl],
    [Number$2, Number$2],
    [Number$2, Percentage$1],
    [Number$2, Dimension$1],
    [Number$2, '%'],
    [Number$2, CDC$1], // https://github.com/w3c/csswg-drafts/pull/6874

    ['@', Ident],
    ['@', Function$2],
    ['@', Url$1],
    ['@', BadUrl],
    ['@', '-'],
    ['@', CDC$1], // https://github.com/w3c/csswg-drafts/pull/6874

    ['.', Number$2],
    ['.', Percentage$1],
    ['.', Dimension$1],

    ['+', Number$2],
    ['+', Percentage$1],
    ['+', Dimension$1],

    ['/', '*']
];
// validate with scripts/generate-safe
const safePairs = specPairs.concat([
    [Ident, Hash$1],

    [Dimension$1, Hash$1],

    [Hash$1, Hash$1],

    [AtKeyword, LeftParenthesis],
    [AtKeyword, String$2],
    [AtKeyword, Colon$1],

    [Percentage$1, Percentage$1],
    [Percentage$1, Dimension$1],
    [Percentage$1, Function$2],
    [Percentage$1, '-'],

    [RightParenthesis, Ident],
    [RightParenthesis, Function$2],
    [RightParenthesis, Percentage$1],
    [RightParenthesis, Dimension$1],
    [RightParenthesis, Hash$1],
    [RightParenthesis, '-']
]);

function createMap(pairs) {
    const isWhiteSpaceRequired = new Set(
        pairs.map(([prev, next]) => (code$1(prev) << 16 | code$1(next)))
    );

    return function(prevCode, type, value) {
        const nextCode = code$1(type, value);
        const nextCharCode = value.charCodeAt(0);
        const emitWs =
            (nextCharCode === HYPHENMINUS$6 &&
                type !== Ident &&
                type !== Function$2 &&
                type !== CDC$1) ||
            (nextCharCode === PLUSSIGN$9)
                ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8)
                : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);

        if (emitWs) {
            this.emit(' ', WhiteSpace$1, true);
        }

        return nextCode;
    };
}

const spec = createMap(specPairs);
const safe = createMap(safePairs);

var tokenBefore = /*#__PURE__*/Object.freeze({
  __proto__: null,
  safe: safe,
  spec: spec
});

const REVERSESOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\)

function processChildren(node, delimeter) {
    if (typeof delimeter === 'function') {
        let prev = null;

        node.children.forEach(node => {
            if (prev !== null) {
                delimeter.call(this, prev);
            }

            this.node(node);
            prev = node;
        });

        return;
    }

    node.children.forEach(this.node, this);
}

function processChunk(chunk) {
    tokenize$2(chunk, (type, start, end) => {
        this.token(type, chunk.slice(start, end));
    });
}

function createGenerator(config) {
    const types = new Map();

    for (let name in config.node) {
        const item = config.node[name];
        const fn = item.generate || item;

        if (typeof fn === 'function') {
            types.set(name, item.generate || item);
        }
    }

    return function(node, options) {
        let buffer = '';
        let prevCode = 0;
        let handlers = {
            node(node) {
                if (types.has(node.type)) {
                    types.get(node.type).call(publicApi, node);
                } else {
                    throw new Error('Unknown node type: ' + node.type);
                }
            },
            tokenBefore: safe,
            token(type, value) {
                prevCode = this.tokenBefore(prevCode, type, value);

                this.emit(value, type, false);

                if (type === Delim && value.charCodeAt(0) === REVERSESOLIDUS) {
                    this.emit('\n', WhiteSpace$1, true);
                }
            },
            emit(value) {
                buffer += value;
            },
            result() {
                return buffer;
            }
        };

        if (options) {
            if (typeof options.decorator === 'function') {
                handlers = options.decorator(handlers);
            }

            if (options.sourceMap) {
                handlers = generateSourceMap(handlers);
            }

            if (options.mode in tokenBefore) {
                handlers.tokenBefore = tokenBefore[options.mode];
            }
        }

        const publicApi = {
            node: (node) => handlers.node(node),
            children: processChildren,
            token: (type, value) => handlers.token(type, value),
            tokenize: processChunk
        };

        handlers.node(node);

        return handlers.result();
    };
}

function createConvertor(walk) {
    return {
        fromPlainObject(ast) {
            walk(ast, {
                enter(node) {
                    if (node.children && node.children instanceof List === false) {
                        node.children = new List().fromArray(node.children);
                    }
                }
            });

            return ast;
        },
        toPlainObject(ast) {
            walk(ast, {
                leave(node) {
                    if (node.children && node.children instanceof List) {
                        node.children = node.children.toArray();
                    }
                }
            });

            return ast;
        }
    };
}

const { hasOwnProperty: hasOwnProperty$4 } = Object.prototype;
const noop$3 = function() {};

function ensureFunction$1(value) {
    return typeof value === 'function' ? value : noop$3;
}

function invokeForType(fn, type) {
    return function(node, item, list) {
        if (node.type === type) {
            fn.call(this, node, item, list);
        }
    };
}

function getWalkersFromStructure(name, nodeType) {
    const structure = nodeType.structure;
    const walkers = [];

    for (const key in structure) {
        if (hasOwnProperty$4.call(structure, key) === false) {
            continue;
        }

        let fieldTypes = structure[key];
        const walker = {
            name: key,
            type: false,
            nullable: false
        };

        if (!Array.isArray(fieldTypes)) {
            fieldTypes = [fieldTypes];
        }

        for (const fieldType of fieldTypes) {
            if (fieldType === null) {
                walker.nullable = true;
            } else if (typeof fieldType === 'string') {
                walker.type = 'node';
            } else if (Array.isArray(fieldType)) {
                walker.type = 'list';
            }
        }

        if (walker.type) {
            walkers.push(walker);
        }
    }

    if (walkers.length) {
        return {
            context: nodeType.walkContext,
            fields: walkers
        };
    }

    return null;
}

function getTypesFromConfig(config) {
    const types = {};

    for (const name in config.node) {
        if (hasOwnProperty$4.call(config.node, name)) {
            const nodeType = config.node[name];

            if (!nodeType.structure) {
                throw new Error('Missed `structure` field in `' + name + '` node type definition');
            }

            types[name] = getWalkersFromStructure(name, nodeType);
        }
    }

    return types;
}

function createTypeIterator(config, reverse) {
    const fields = config.fields.slice();
    const contextName = config.context;
    const useContext = typeof contextName === 'string';

    if (reverse) {
        fields.reverse();
    }

    return function(node, context, walk, walkReducer) {
        let prevContextValue;

        if (useContext) {
            prevContextValue = context[contextName];
            context[contextName] = node;
        }

        for (const field of fields) {
            const ref = node[field.name];

            if (!field.nullable || ref) {
                if (field.type === 'list') {
                    const breakWalk = reverse
                        ? ref.reduceRight(walkReducer, false)
                        : ref.reduce(walkReducer, false);

                    if (breakWalk) {
                        return true;
                    }
                } else if (walk(ref)) {
                    return true;
                }
            }
        }

        if (useContext) {
            context[contextName] = prevContextValue;
        }
    };
}

function createFastTraveralMap({
    StyleSheet,
    Atrule,
    Rule,
    Block,
    DeclarationList
}) {
    return {
        Atrule: {
            StyleSheet,
            Atrule,
            Rule,
            Block
        },
        Rule: {
            StyleSheet,
            Atrule,
            Rule,
            Block
        },
        Declaration: {
            StyleSheet,
            Atrule,
            Rule,
            Block,
            DeclarationList
        }
    };
}

function createWalker(config) {
    const types = getTypesFromConfig(config);
    const iteratorsNatural = {};
    const iteratorsReverse = {};
    const breakWalk = Symbol('break-walk');
    const skipNode = Symbol('skip-node');

    for (const name in types) {
        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
            iteratorsNatural[name] = createTypeIterator(types[name], false);
            iteratorsReverse[name] = createTypeIterator(types[name], true);
        }
    }

    const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

    const walk = function(root, options) {
        function walkNode(node, item, list) {
            const enterRet = enter.call(context, node, item, list);

            if (enterRet === breakWalk) {
                return true;
            }

            if (enterRet === skipNode) {
                return false;
            }

            if (iterators.hasOwnProperty(node.type)) {
                if (iterators[node.type](node, context, walkNode, walkReducer)) {
                    return true;
                }
            }

            if (leave.call(context, node, item, list) === breakWalk) {
                return true;
            }

            return false;
        }

        let enter = noop$3;
        let leave = noop$3;
        let iterators = iteratorsNatural;
        let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
        const context = {
            break: breakWalk,
            skip: skipNode,

            root,
            stylesheet: null,
            atrule: null,
            atrulePrelude: null,
            rule: null,
            selector: null,
            block: null,
            declaration: null,
            function: null
        };

        if (typeof options === 'function') {
            enter = options;
        } else if (options) {
            enter = ensureFunction$1(options.enter);
            leave = ensureFunction$1(options.leave);

            if (options.reverse) {
                iterators = iteratorsReverse;
            }

            if (options.visit) {
                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
                    iterators = options.reverse
                        ? fastTraversalIteratorsReverse[options.visit]
                        : fastTraversalIteratorsNatural[options.visit];
                } else if (!types.hasOwnProperty(options.visit)) {
                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).sort().join(', ') + ')');
                }

                enter = invokeForType(enter, options.visit);
                leave = invokeForType(leave, options.visit);
            }
        }

        if (enter === noop$3 && leave === noop$3) {
            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
        }

        walkNode(root);
    };

    walk.break = breakWalk;
    walk.skip = skipNode;

    walk.find = function(ast, fn) {
        let found = null;

        walk(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
                found = node;
                return breakWalk;
            }
        });

        return found;
    };

    walk.findLast = function(ast, fn) {
        let found = null;

        walk(ast, {
            reverse: true,
            enter(node, item, list) {
                if (fn.call(this, node, item, list)) {
                    found = node;
                    return breakWalk;
                }
            }
        });

        return found;
    };

    walk.findAll = function(ast, fn) {
        const found = [];

        walk(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
                found.push(node);
            }
        });

        return found;
    };

    return walk;
}

function noop$2(value) {
    return value;
}

function generateMultiplier(multiplier) {
    const { min, max, comma } = multiplier;

    if (min === 0 && max === 0) {
        return comma ? '#?' : '*';
    }

    if (min === 0 && max === 1) {
        return '?';
    }

    if (min === 1 && max === 0) {
        return comma ? '#' : '+';
    }

    if (min === 1 && max === 1) {
        return '';
    }

    return (
        (comma ? '#' : '') +
        (min === max
            ? '{' + min + '}'
            : '{' + min + ',' + (max !== 0 ? max : '') + '}'
        )
    );
}

function generateTypeOpts(node) {
    switch (node.type) {
        case 'Range':
            return (
                ' [' +
                (node.min === null ? '-∞' : node.min) +
                ',' +
                (node.max === null ? '∞' : node.max) +
                ']'
            );

        default:
            throw new Error('Unknown node type `' + node.type + '`');
    }
}

function generateSequence(node, decorate, forceBraces, compact) {
    const combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
    const result = node.terms
        .map(term => internalGenerate(term, decorate, forceBraces, compact))
        .join(combinator);

    if (node.explicit || forceBraces) {
        return (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
    }

    return result;
}

function internalGenerate(node, decorate, forceBraces, compact) {
    let result;

    switch (node.type) {
        case 'Group':
            result =
                generateSequence(node, decorate, forceBraces, compact) +
                (node.disallowEmpty ? '!' : '');
            break;

        case 'Multiplier':
            // return since node is a composition
            return (
                internalGenerate(node.term, decorate, forceBraces, compact) +
                decorate(generateMultiplier(node), node)
            );

        case 'Type':
            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
            break;

        case 'Property':
            result = '<\'' + node.name + '\'>';
            break;

        case 'Keyword':
            result = node.name;
            break;

        case 'AtKeyword':
            result = '@' + node.name;
            break;

        case 'Function':
            result = node.name + '(';
            break;

        case 'String':
        case 'Token':
            result = node.value;
            break;

        case 'Comma':
            result = ',';
            break;

        default:
            throw new Error('Unknown node type `' + node.type + '`');
    }

    return decorate(result, node);
}

function generate$N(node, options) {
    let decorate = noop$2;
    let forceBraces = false;
    let compact = false;

    if (typeof options === 'function') {
        decorate = options;
    } else if (options) {
        forceBraces = Boolean(options.forceBraces);
        compact = Boolean(options.compact);
        if (typeof options.decorate === 'function') {
            decorate = options.decorate;
        }
    }

    return internalGenerate(node, decorate, forceBraces, compact);
}

const defaultLoc = { offset: 0, line: 1, column: 1 };

function locateMismatch(matchResult, node) {
    const tokens = matchResult.tokens;
    const longestMatch = matchResult.longestMatch;
    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
    const badNode = mismatchNode !== node ? mismatchNode : null;
    let mismatchOffset = 0;
    let mismatchLength = 0;
    let entries = 0;
    let css = '';
    let start;
    let end;

    for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i].value;

        if (i === longestMatch) {
            mismatchLength = token.length;
            mismatchOffset = css.length;
        }

        if (badNode !== null && tokens[i].node === badNode) {
            if (i <= longestMatch) {
                entries++;
            } else {
                entries = 0;
            }
        }

        css += token;
    }

    if (longestMatch === tokens.length || entries > 1) { // last
        start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);
        end = buildLoc(start);
    } else {
        start = fromLoc(badNode, 'start') ||
            buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));
        end = fromLoc(badNode, 'end') ||
            buildLoc(start, css.substr(mismatchOffset, mismatchLength));
    }

    return {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
    };
}

function fromLoc(node, point) {
    const value = node && node.loc && node.loc[point];

    if (value) {
        return 'line' in value ? buildLoc(value) : value;
    }

    return null;
}

function buildLoc({ offset, line, column }, extra) {
    const loc = {
        offset,
        line,
        column
    };

    if (extra) {
        const lines = extra.split(/\n|\r\n?|\f/);

        loc.offset += extra.length;
        loc.line += lines.length - 1;
        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
    }

    return loc;
}

const SyntaxReferenceError = function(type, referenceName) {
    const error = createCustomError(
        'SyntaxReferenceError',
        type + (referenceName ? ' `' + referenceName + '`' : '')
    );

    error.reference = referenceName;

    return error;
};

const SyntaxMatchError = function(message, syntax, node, matchResult) {
    const error = createCustomError('SyntaxMatchError', message);
    const {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
    } = locateMismatch(matchResult, node);

    error.rawMessage = message;
    error.syntax = syntax ? generate$N(syntax) : '<generic>';
    error.css = css;
    error.mismatchOffset = mismatchOffset;
    error.mismatchLength = mismatchLength;
    error.message = message + '\n' +
        '  syntax: ' + error.syntax + '\n' +
        '   value: ' + (css || '<empty string>') + '\n' +
        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

    Object.assign(error, start);
    error.loc = {
        source: (node && node.loc && node.loc.source) || '<unknown>',
        start,
        end
    };

    return error;
};

const keywords = new Map();
const properties = new Map();
const HYPHENMINUS$5 = 45; // '-'.charCodeAt()

const keyword = getKeywordDescriptor;
const property = getPropertyDescriptor;
function isCustomProperty(str, offset) {
    offset = offset || 0;

    return str.length - offset >= 2 &&
           str.charCodeAt(offset) === HYPHENMINUS$5 &&
           str.charCodeAt(offset + 1) === HYPHENMINUS$5;
}

function getVendorPrefix(str, offset) {
    offset = offset || 0;

    // verdor prefix should be at least 3 chars length
    if (str.length - offset >= 3) {
        // vendor prefix starts with hyper minus following non-hyper minus
        if (str.charCodeAt(offset) === HYPHENMINUS$5 &&
            str.charCodeAt(offset + 1) !== HYPHENMINUS$5) {
            // vendor prefix should contain a hyper minus at the ending
            const secondDashIndex = str.indexOf('-', offset + 2);

            if (secondDashIndex !== -1) {
                return str.substring(offset, secondDashIndex + 1);
            }
        }
    }

    return '';
}

function getKeywordDescriptor(keyword) {
    if (keywords.has(keyword)) {
        return keywords.get(keyword);
    }

    const name = keyword.toLowerCase();
    let descriptor = keywords.get(name);

    if (descriptor === undefined) {
        const custom = isCustomProperty(name, 0);
        const vendor = !custom ? getVendorPrefix(name, 0) : '';
        descriptor = Object.freeze({
            basename: name.substr(vendor.length),
            name,
            prefix: vendor,
            vendor,
            custom
        });
    }

    keywords.set(keyword, descriptor);

    return descriptor;
}

function getPropertyDescriptor(property) {
    if (properties.has(property)) {
        return properties.get(property);
    }

    let name = property;
    let hack = property[0];

    if (hack === '/') {
        hack = property[1] === '/' ? '//' : '/';
    } else if (hack !== '_' &&
               hack !== '*' &&
               hack !== '$' &&
               hack !== '#' &&
               hack !== '+' &&
               hack !== '&') {
        hack = '';
    }

    const custom = isCustomProperty(name, hack.length);

    // re-use result when possible (the same as for lower case)
    if (!custom) {
        name = name.toLowerCase();
        if (properties.has(name)) {
            const descriptor = properties.get(name);
            properties.set(property, descriptor);
            return descriptor;
        }
    }

    const vendor = !custom ? getVendorPrefix(name, hack.length) : '';
    const prefix = name.substr(0, hack.length + vendor.length);
    const descriptor = Object.freeze({
        basename: name.substr(prefix.length),
        name: name.substr(hack.length),
        hack,
        vendor,
        prefix,
        custom
    });

    properties.set(property, descriptor);

    return descriptor;
}

// https://drafts.csswg.org/css-cascade-5/
const cssWideKeywords = [
    'initial',
    'inherit',
    'unset',
    'revert',
    'revert-layer'
];

const PLUSSIGN$8 = 0x002B;    // U+002B PLUS SIGN (+)
const HYPHENMINUS$4 = 0x002D; // U+002D HYPHEN-MINUS (-)
const N$3 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
const DISALLOW_SIGN$1 = true;
const ALLOW_SIGN$1 = false;

function isDelim$1(token, code) {
    return token !== null && token.type === Delim && token.value.charCodeAt(0) === code;
}

function skipSC(token, offset, getNextToken) {
    while (token !== null && (token.type === WhiteSpace$1 || token.type === Comment$1)) {
        token = getNextToken(++offset);
    }

    return offset;
}

function checkInteger$1(token, valueOffset, disallowSign, offset) {
    if (!token) {
        return 0;
    }

    const code = token.value.charCodeAt(valueOffset);

    if (code === PLUSSIGN$8 || code === HYPHENMINUS$4) {
        if (disallowSign) {
            // Number sign is not allowed
            return 0;
        }
        valueOffset++;
    }

    for (; valueOffset < token.value.length; valueOffset++) {
        if (!isDigit(token.value.charCodeAt(valueOffset))) {
            // Integer is expected
            return 0;
        }
    }

    return offset + 1;
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB$1(token, offset_, getNextToken) {
    let sign = false;
    let offset = skipSC(token, offset_, getNextToken);

    token = getNextToken(offset);

    if (token === null) {
        return offset_;
    }

    if (token.type !== Number$2) {
        if (isDelim$1(token, PLUSSIGN$8) || isDelim$1(token, HYPHENMINUS$4)) {
            sign = true;
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);

            if (token === null || token.type !== Number$2) {
                return 0;
            }
        } else {
            return offset_;
        }
    }

    if (!sign) {
        const code = token.value.charCodeAt(0);
        if (code !== PLUSSIGN$8 && code !== HYPHENMINUS$4) {
            // Number sign is expected
            return 0;
        }
    }

    return checkInteger$1(token, sign ? 0 : 1, sign, offset);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
function anPlusB(token, getNextToken) {
    /* eslint-disable brace-style*/
    let offset = 0;

    if (!token) {
        return 0;
    }

    // <integer>
    if (token.type === Number$2) {
        return checkInteger$1(token, 0, ALLOW_SIGN$1, offset); // b
    }

    // -n
    // -n <signed-integer>
    // -n ['+' | '-'] <signless-integer>
    // -n- <signless-integer>
    // <dashndashdigit-ident>
    else if (token.type === Ident && token.value.charCodeAt(0) === HYPHENMINUS$4) {
        // expect 1st char is N
        if (!cmpChar(token.value, 1, N$3)) {
            return 0;
        }

        switch (token.value.length) {
            // -n
            // -n <signed-integer>
            // -n ['+' | '-'] <signless-integer>
            case 2:
                return consumeB$1(getNextToken(++offset), offset, getNextToken);

            // -n- <signless-integer>
            case 3:
                if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
                    return 0;
                }

                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);

            // <dashndashdigit-ident>
            default:
                if (token.value.charCodeAt(2) !== HYPHENMINUS$4) {
                    return 0;
                }

                return checkInteger$1(token, 3, DISALLOW_SIGN$1, offset);
        }
    }

    // '+'? n
    // '+'? n <signed-integer>
    // '+'? n ['+' | '-'] <signless-integer>
    // '+'? n- <signless-integer>
    // '+'? <ndashdigit-ident>
    else if (token.type === Ident || (isDelim$1(token, PLUSSIGN$8) && getNextToken(offset + 1).type === Ident)) {
        // just ignore a plus
        if (token.type !== Ident) {
            token = getNextToken(++offset);
        }

        if (token === null || !cmpChar(token.value, 0, N$3)) {
            return 0;
        }

        switch (token.value.length) {
            // '+'? n
            // '+'? n <signed-integer>
            // '+'? n ['+' | '-'] <signless-integer>
            case 1:
                return consumeB$1(getNextToken(++offset), offset, getNextToken);

            // '+'? n- <signless-integer>
            case 2:
                if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
                    return 0;
                }

                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);

            // '+'? <ndashdigit-ident>
            default:
                if (token.value.charCodeAt(1) !== HYPHENMINUS$4) {
                    return 0;
                }

                return checkInteger$1(token, 2, DISALLOW_SIGN$1, offset);
        }
    }

    // <ndashdigit-dimension>
    // <ndash-dimension> <signless-integer>
    // <n-dimension>
    // <n-dimension> <signed-integer>
    // <n-dimension> ['+' | '-'] <signless-integer>
    else if (token.type === Dimension$1) {
        let code = token.value.charCodeAt(0);
        let sign = code === PLUSSIGN$8 || code === HYPHENMINUS$4 ? 1 : 0;
        let i = sign;

        for (; i < token.value.length; i++) {
            if (!isDigit(token.value.charCodeAt(i))) {
                break;
            }
        }

        if (i === sign) {
            // Integer is expected
            return 0;
        }

        if (!cmpChar(token.value, i, N$3)) {
            return 0;
        }

        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        if (i + 1 === token.value.length) {
            return consumeB$1(getNextToken(++offset), offset, getNextToken);
        } else {
            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$4) {
                return 0;
            }

            // <ndash-dimension> <signless-integer>
            if (i + 2 === token.value.length) {
                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger$1(token, 0, DISALLOW_SIGN$1, offset);
            }
            // <ndashdigit-dimension>
            else {
                return checkInteger$1(token, i + 2, DISALLOW_SIGN$1, offset);
            }
        }
    }

    return 0;
}

const PLUSSIGN$7 = 0x002B;     // U+002B PLUS SIGN (+)
const HYPHENMINUS$3 = 0x002D;  // U+002D HYPHEN-MINUS (-)
const QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
const U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

function isDelim(token, code) {
    return token !== null && token.type === Delim && token.value.charCodeAt(0) === code;
}

function startsWith$1(token, code) {
    return token.value.charCodeAt(0) === code;
}

function hexSequence(token, offset, allowDash) {
    let hexlen = 0;

    for (let pos = offset; pos < token.value.length; pos++) {
        const code = token.value.charCodeAt(pos);

        if (code === HYPHENMINUS$3 && allowDash && hexlen !== 0) {
            hexSequence(token, offset + hexlen + 1, false);
            return 6; // dissallow following question marks
        }

        if (!isHexDigit(code)) {
            return 0; // not a hex digit
        }

        if (++hexlen > 6) {
            return 0; // too many hex digits
        }    }

    return hexlen;
}

function withQuestionMarkSequence(consumed, length, getNextToken) {
    if (!consumed) {
        return 0; // nothing consumed
    }

    while (isDelim(getNextToken(length), QUESTIONMARK$2)) {
        if (++consumed > 6) {
            return 0; // too many question marks
        }

        length++;
    }

    return length;
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
function urange(token, getNextToken) {
    let length = 0;

    // should start with `u` or `U`
    if (token === null || token.type !== Ident || !cmpChar(token.value, 0, U$1)) {
        return 0;
    }

    token = getNextToken(++length);
    if (token === null) {
        return 0;
    }

    // u '+' <ident-token> '?'*
    // u '+' '?'+
    if (isDelim(token, PLUSSIGN$7)) {
        token = getNextToken(++length);
        if (token === null) {
            return 0;
        }

        if (token.type === Ident) {
            // u '+' <ident-token> '?'*
            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
        }

        if (isDelim(token, QUESTIONMARK$2)) {
            // u '+' '?'+
            return withQuestionMarkSequence(1, ++length, getNextToken);
        }

        // Hex digit or question mark is expected
        return 0;
    }

    // u <number-token> '?'*
    // u <number-token> <dimension-token>
    // u <number-token> <number-token>
    if (token.type === Number$2) {
        const consumedHexLength = hexSequence(token, 1, true);
        if (consumedHexLength === 0) {
            return 0;
        }

        token = getNextToken(++length);
        if (token === null) {
            // u <number-token> <eof>
            return length;
        }

        if (token.type === Dimension$1 || token.type === Number$2) {
            // u <number-token> <dimension-token>
            // u <number-token> <number-token>
            if (!startsWith$1(token, HYPHENMINUS$3) || !hexSequence(token, 1, false)) {
                return 0;
            }

            return length + 1;
        }

        // u <number-token> '?'*
        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
    }

    // u <dimension-token> '?'*
    if (token.type === Dimension$1) {
        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
    }

    return 0;
}

const calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];
const balancePair = new Map([
    [Function$2, RightParenthesis],
    [LeftParenthesis, RightParenthesis],
    [LeftSquareBracket, RightSquareBracket],
    [LeftCurlyBracket, RightCurlyBracket]
]);

// safe char code getter
function charCodeAt(str, index) {
    return index < str.length ? str.charCodeAt(index) : 0;
}

function eqStr(actual, expected) {
    return cmpStr(actual, 0, actual.length, expected);
}

function eqStrAny(actual, expected) {
    for (let i = 0; i < expected.length; i++) {
        if (eqStr(actual, expected[i])) {
            return true;
        }
    }

    return false;
}

// IE postfix hack, i.e. 123\0 or 123px\9
function isPostfixIeHack(str, offset) {
    if (offset !== str.length - 2) {
        return false;
    }

    return (
        charCodeAt(str, offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
        isDigit(charCodeAt(str, offset + 1))
    );
}

function outOfRange(opts, value, numEnd) {
    if (opts && opts.type === 'Range') {
        const num = Number(
            numEnd !== undefined && numEnd !== value.length
                ? value.substr(0, numEnd)
                : value
        );

        if (isNaN(num)) {
            return true;
        }

        // FIXME: when opts.min is a string it's a dimension, skip a range validation
        // for now since it requires a type covertation which is not implmented yet
        if (opts.min !== null && num < opts.min && typeof opts.min !== 'string') {
            return true;
        }

        // FIXME: when opts.max is a string it's a dimension, skip a range validation
        // for now since it requires a type covertation which is not implmented yet
        if (opts.max !== null && num > opts.max && typeof opts.max !== 'string') {
            return true;
        }
    }

    return false;
}

function consumeFunction(token, getNextToken) {
    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;

    // balanced token consuming
    scan:
    do {
        switch (token.type) {
            case RightCurlyBracket:
            case RightParenthesis:
            case RightSquareBracket:
                if (token.type !== balanceCloseType) {
                    break scan;
                }

                balanceCloseType = balanceStash.pop();

                if (balanceStash.length === 0) {
                    length++;
                    break scan;
                }

                break;

            case Function$2:
            case LeftParenthesis:
            case LeftSquareBracket:
            case LeftCurlyBracket:
                balanceStash.push(balanceCloseType);
                balanceCloseType = balancePair.get(token.type);
                break;
        }

        length++;
    } while (token = getNextToken(length));

    return length;
}

// TODO: implement
// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
// https://drafts.csswg.org/css-values/#calc-notation
function calc(next) {
    return function(token, getNextToken, opts) {
        if (token === null) {
            return 0;
        }

        if (token.type === Function$2 && eqStrAny(token.value, calcFunctionNames)) {
            return consumeFunction(token, getNextToken);
        }

        return next(token, getNextToken, opts);
    };
}

function tokenType(expectedTokenType) {
    return function(token) {
        if (token === null || token.type !== expectedTokenType) {
            return 0;
        }

        return 1;
    };
}

// =========================
// Complex types
//

// https://drafts.csswg.org/css-values-4/#custom-idents
// 4.2. Author-defined Identifiers: the <custom-ident> type
// Some properties accept arbitrary author-defined identifiers as a component value.
// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
//
// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
function customIdent(token) {
    if (token === null || token.type !== Ident) {
        return 0;
    }

    const name = token.value.toLowerCase();

    // The CSS-wide keywords are not valid <custom-ident>s
    if (eqStrAny(name, cssWideKeywords)) {
        return 0;
    }

    // The default keyword is reserved and is also not a valid <custom-ident>
    if (eqStr(name, 'default')) {
        return 0;
    }

    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
    // Specifications using <custom-ident> must specify clearly what other keywords
    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
    // in that property’s value definition are excluded. Excluded keywords are excluded
    // in all ASCII case permutations.

    return 1;
}

// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
function customPropertyName(token) {
    // ... defined as any valid identifier
    if (token === null || token.type !== Ident) {
        return 0;
    }

    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
    if (charCodeAt(token.value, 0) !== 0x002D || charCodeAt(token.value, 1) !== 0x002D) {
        return 0;
    }

    return 1;
}

// https://drafts.csswg.org/css-color-4/#hex-notation
// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
function hexColor(token) {
    if (token === null || token.type !== Hash$1) {
        return 0;
    }

    const length = token.value.length;

    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
        return 0;
    }

    for (let i = 1; i < length; i++) {
        if (!isHexDigit(charCodeAt(token.value, i))) {
            return 0;
        }
    }

    return 1;
}

function idSelector(token) {
    if (token === null || token.type !== Hash$1) {
        return 0;
    }

    if (!isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
        return 0;
    }

    return 1;
}

// https://drafts.csswg.org/css-syntax/#any-value
// It represents the entirety of what a valid declaration can have as its value.
function declarationValue(token, getNextToken) {
    if (!token) {
        return 0;
    }

    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;

    // The <declaration-value> production matches any sequence of one or more tokens,
    // so long as the sequence does not contain ...
    scan:
    do {
        switch (token.type) {
            // ... <bad-string-token>, <bad-url-token>,
            case BadString:
            case BadUrl:
                break scan;

            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case RightCurlyBracket:
            case RightParenthesis:
            case RightSquareBracket:
                if (token.type !== balanceCloseType) {
                    break scan;
                }

                balanceCloseType = balanceStash.pop();
                break;

            // ... or top-level <semicolon-token> tokens
            case Semicolon:
                if (balanceCloseType === 0) {
                    break scan;
                }

                break;

            // ... or <delim-token> tokens with a value of "!"
            case Delim:
                if (balanceCloseType === 0 && token.value === '!') {
                    break scan;
                }

                break;

            case Function$2:
            case LeftParenthesis:
            case LeftSquareBracket:
            case LeftCurlyBracket:
                balanceStash.push(balanceCloseType);
                balanceCloseType = balancePair.get(token.type);
                break;
        }

        length++;
    } while (token = getNextToken(length));

    return length;
}

// https://drafts.csswg.org/css-syntax/#any-value
// The <any-value> production is identical to <declaration-value>, but also
// allows top-level <semicolon-token> tokens and <delim-token> tokens
// with a value of "!". It represents the entirety of what valid CSS can be in any context.
function anyValue(token, getNextToken) {
    if (!token) {
        return 0;
    }

    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;

    // The <any-value> production matches any sequence of one or more tokens,
    // so long as the sequence ...
    scan:
    do {
        switch (token.type) {
            // ... does not contain <bad-string-token>, <bad-url-token>,
            case BadString:
            case BadUrl:
                break scan;

            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case RightCurlyBracket:
            case RightParenthesis:
            case RightSquareBracket:
                if (token.type !== balanceCloseType) {
                    break scan;
                }

                balanceCloseType = balanceStash.pop();
                break;

            case Function$2:
            case LeftParenthesis:
            case LeftSquareBracket:
            case LeftCurlyBracket:
                balanceStash.push(balanceCloseType);
                balanceCloseType = balancePair.get(token.type);
                break;
        }

        length++;
    } while (token = getNextToken(length));

    return length;
}

// =========================
// Dimensions
//

function dimension(type) {
    if (type) {
        type = new Set(type);
    }

    return function(token, getNextToken, opts) {
        if (token === null || token.type !== Dimension$1) {
            return 0;
        }

        const numberEnd = consumeNumber$1(token.value, 0);

        // check unit
        if (type !== null) {
            // check for IE postfix hack, i.e. 123px\0 or 123px\9
            const reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
            const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
                ? token.value.substr(numberEnd)
                : token.value.substring(numberEnd, reverseSolidusOffset);

            if (type.has(unit.toLowerCase()) === false) {
                return 0;
            }
        }

        // check range if specified
        if (outOfRange(opts, token.value, numberEnd)) {
            return 0;
        }

        return 1;
    };
}

// =========================
// Percentage
//

// §5.5. Percentages: the <percentage> type
// https://drafts.csswg.org/css-values-4/#percentages
function percentage(token, getNextToken, opts) {
    // ... corresponds to the <percentage-token> production
    if (token === null || token.type !== Percentage$1) {
        return 0;
    }

    // check range if specified
    if (outOfRange(opts, token.value, token.value.length - 1)) {
        return 0;
    }

    return 1;
}

// =========================
// Numeric
//

// https://drafts.csswg.org/css-values-4/#numbers
// The value <zero> represents a literal number with the value 0. Expressions that merely
// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
// only literal <number-token>s do.
function zero(next) {
    if (typeof next !== 'function') {
        next = function() {
            return 0;
        };
    }

    return function(token, getNextToken, opts) {
        if (token !== null && token.type === Number$2) {
            if (Number(token.value) === 0) {
                return 1;
            }
        }

        return next(token, getNextToken, opts);
    };
}

// § 5.3. Real Numbers: the <number> type
// https://drafts.csswg.org/css-values-4/#numbers
// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
// ... It corresponds to the <number-token> production
function number$4(token, getNextToken, opts) {
    if (token === null) {
        return 0;
    }

    const numberEnd = consumeNumber$1(token.value, 0);
    const isNumber = numberEnd === token.value.length;
    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
        return 0;
    }

    // check range if specified
    if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
    }

    return 1;
}

// §5.2. Integers: the <integer> type
// https://drafts.csswg.org/css-values-4/#integers
function integer(token, getNextToken, opts) {
    // ... corresponds to a subset of the <number-token> production
    if (token === null || token.type !== Number$2) {
        return 0;
    }

    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
    let i = charCodeAt(token.value, 0) === 0x002B ||       // U+002B PLUS SIGN (+)
            charCodeAt(token.value, 0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

    // When written literally, an integer is one or more decimal digits 0 through 9 ...
    for (; i < token.value.length; i++) {
        if (!isDigit(charCodeAt(token.value, i))) {
            return 0;
        }
    }

    // check range if specified
    if (outOfRange(opts, token.value, i)) {
        return 0;
    }

    return 1;
}

// token types
const tokenTypes = {
    'ident-token': tokenType(Ident),
    'function-token': tokenType(Function$2),
    'at-keyword-token': tokenType(AtKeyword),
    'hash-token': tokenType(Hash$1),
    'string-token': tokenType(String$2),
    'bad-string-token': tokenType(BadString),
    'url-token': tokenType(Url$1),
    'bad-url-token': tokenType(BadUrl),
    'delim-token': tokenType(Delim),
    'number-token': tokenType(Number$2),
    'percentage-token': tokenType(Percentage$1),
    'dimension-token': tokenType(Dimension$1),
    'whitespace-token': tokenType(WhiteSpace$1),
    'CDO-token': tokenType(CDO$1),
    'CDC-token': tokenType(CDC$1),
    'colon-token': tokenType(Colon$1),
    'semicolon-token': tokenType(Semicolon),
    'comma-token': tokenType(Comma),
    '[-token': tokenType(LeftSquareBracket),
    ']-token': tokenType(RightSquareBracket),
    '(-token': tokenType(LeftParenthesis),
    ')-token': tokenType(RightParenthesis),
    '{-token': tokenType(LeftCurlyBracket),
    '}-token': tokenType(RightCurlyBracket)
};

// token production types
const productionTypes = {
    // token type aliases
    'string': tokenType(String$2),
    'ident': tokenType(Ident),

    // percentage
    'percentage': calc(percentage),

    // numeric
    'zero': zero(),
    'number': calc(number$4),
    'integer': calc(integer),

    // complex types
    'custom-ident': customIdent,
    'custom-property-name': customPropertyName,
    'hex-color': hexColor,
    'id-selector': idSelector, // element( <id-selector> )
    'an-plus-b': anPlusB,
    'urange': urange,
    'declaration-value': declarationValue,
    'any-value': anyValue
};

// dimensions types depend on units set
function createDemensionTypes(units) {
    const {
        angle,
        decibel,
        frequency,
        flex,
        length,
        resolution,
        semitones,
        time
    } = units || {};

    return {
        'dimension': calc(dimension(null)),
        'angle': calc(dimension(angle)),
        'decibel': calc(dimension(decibel)),
        'frequency': calc(dimension(frequency)),
        'flex': calc(dimension(flex)),
        'length': calc(zero(dimension(length))),
        'resolution': calc(dimension(resolution)),
        'semitones': calc(dimension(semitones)),
        'time': calc(dimension(time))
    };
}

function createGenericTypes(units) {
    return {
        ...tokenTypes,
        ...productionTypes,
        ...createDemensionTypes(units)
    };
}

const length = [
    // absolute length units https://www.w3.org/TR/css-values-3/#lengths
    'cm', 'mm', 'q', 'in', 'pt', 'pc', 'px',
    // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths
    'em', 'rem',
    'ex', 'rex',
    'cap', 'rcap',
    'ch', 'rch',
    'ic', 'ric',
    'lh', 'rlh',
    // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
    'vw', 'svw', 'lvw', 'dvw',
    'vh', 'svh', 'lvh', 'dvh',
    'vi', 'svi', 'lvi', 'dvi',
    'vb', 'svb', 'lvb', 'dvb',
    'vmin', 'svmin', 'lvmin', 'dvmin',
    'vmax', 'svmax', 'lvmax', 'dvmax',
    // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths
    'cqw', 'cqh', 'cqi', 'cqb', 'cqmin', 'cqmax'
];
const angle$1 = ['deg', 'grad', 'rad', 'turn'];    // https://www.w3.org/TR/css-values-3/#angles
const time$1 = ['s', 'ms'];                        // https://www.w3.org/TR/css-values-3/#time
const frequency = ['hz', 'khz'];                 // https://www.w3.org/TR/css-values-3/#frequency
const resolution = ['dpi', 'dpcm', 'dppx', 'x']; // https://www.w3.org/TR/css-values-3/#resolution
const flex = ['fr'];                             // https://drafts.csswg.org/css-grid/#fr-unit
const decibel = ['db'];                          // https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
const semitones = ['st'];                        // https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch

var units = /*#__PURE__*/Object.freeze({
  __proto__: null,
  angle: angle$1,
  decibel: decibel,
  flex: flex,
  frequency: frequency,
  length: length,
  resolution: resolution,
  semitones: semitones,
  time: time$1
});

function SyntaxError$1(message, input, offset) {
    return Object.assign(createCustomError('SyntaxError', message), {
        input,
        offset,
        rawMessage: message,
        message: message + '\n' +
            '  ' + input + '\n' +
            '--' + new Array((offset || input.length) + 1).join('-') + '^'
    });
}

const TAB$1 = 9;
const N$2 = 10;
const F$1 = 12;
const R$1 = 13;
const SPACE$3 = 32;

class Tokenizer {
    constructor(str) {
        this.str = str;
        this.pos = 0;
    }
    charCodeAt(pos) {
        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
    }
    charCode() {
        return this.charCodeAt(this.pos);
    }
    nextCharCode() {
        return this.charCodeAt(this.pos + 1);
    }
    nextNonWsCode(pos) {
        return this.charCodeAt(this.findWsEnd(pos));
    }
    findWsEnd(pos) {
        for (; pos < this.str.length; pos++) {
            const code = this.str.charCodeAt(pos);
            if (code !== R$1 && code !== N$2 && code !== F$1 && code !== SPACE$3 && code !== TAB$1) {
                break;
            }
        }

        return pos;
    }
    substringToPos(end) {
        return this.str.substring(this.pos, this.pos = end);
    }
    eat(code) {
        if (this.charCode() !== code) {
            this.error('Expect `' + String.fromCharCode(code) + '`');
        }

        this.pos++;
    }
    peek() {
        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
    }
    error(message) {
        throw new SyntaxError$1(message, this.str, this.pos);
    }
}

const TAB = 9;
const N$1 = 10;
const F = 12;
const R = 13;
const SPACE$2 = 32;
const EXCLAMATIONMARK$2 = 33;    // !
const NUMBERSIGN$3 = 35;         // #
const AMPERSAND$5 = 38;          // &
const APOSTROPHE$2 = 39;         // '
const LEFTPARENTHESIS$2 = 40;    // (
const RIGHTPARENTHESIS$2 = 41;   // )
const ASTERISK$6 = 42;           // *
const PLUSSIGN$6 = 43;           // +
const COMMA = 44;              // ,
const HYPERMINUS = 45;         // -
const LESSTHANSIGN = 60;       // <
const GREATERTHANSIGN$2 = 62;    // >
const QUESTIONMARK$1 = 63;       // ?
const COMMERCIALAT = 64;       // @
const LEFTSQUAREBRACKET = 91;  // [
const RIGHTSQUAREBRACKET = 93; // ]
const LEFTCURLYBRACKET = 123;  // {
const VERTICALLINE$3 = 124;      // |
const RIGHTCURLYBRACKET = 125; // }
const INFINITY = 8734;         // ∞
const NAME_CHAR = new Uint8Array(128).map((_, idx) =>
    /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0
);
const COMBINATOR_PRECEDENCE = {
    ' ': 1,
    '&&': 2,
    '||': 3,
    '|': 4
};

function scanSpaces(tokenizer) {
    return tokenizer.substringToPos(
        tokenizer.findWsEnd(tokenizer.pos)
    );
}

function scanWord(tokenizer) {
    let end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        const code = tokenizer.str.charCodeAt(end);
        if (code >= 128 || NAME_CHAR[code] === 0) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        tokenizer.error('Expect a keyword');
    }

    return tokenizer.substringToPos(end);
}

function scanNumber(tokenizer) {
    let end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        const code = tokenizer.str.charCodeAt(end);
        if (code < 48 || code > 57) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        tokenizer.error('Expect a number');
    }

    return tokenizer.substringToPos(end);
}

function scanString(tokenizer) {
    const end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

    if (end === -1) {
        tokenizer.pos = tokenizer.str.length;
        tokenizer.error('Expect an apostrophe');
    }

    return tokenizer.substringToPos(end + 1);
}

function readMultiplierRange(tokenizer) {
    let min = null;
    let max = null;

    tokenizer.eat(LEFTCURLYBRACKET);

    min = scanNumber(tokenizer);

    if (tokenizer.charCode() === COMMA) {
        tokenizer.pos++;
        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
            max = scanNumber(tokenizer);
        }
    } else {
        max = min;
    }

    tokenizer.eat(RIGHTCURLYBRACKET);

    return {
        min: Number(min),
        max: max ? Number(max) : 0
    };
}

function readMultiplier(tokenizer) {
    let range = null;
    let comma = false;

    switch (tokenizer.charCode()) {
        case ASTERISK$6:
            tokenizer.pos++;

            range = {
                min: 0,
                max: 0
            };

            break;

        case PLUSSIGN$6:
            tokenizer.pos++;

            range = {
                min: 1,
                max: 0
            };

            break;

        case QUESTIONMARK$1:
            tokenizer.pos++;

            range = {
                min: 0,
                max: 1
            };

            break;

        case NUMBERSIGN$3:
            tokenizer.pos++;

            comma = true;

            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
                range = readMultiplierRange(tokenizer);
            } else if (tokenizer.charCode() === QUESTIONMARK$1) {
                // https://www.w3.org/TR/css-values-4/#component-multipliers
                // > the # and ? multipliers may be stacked as #?
                // In this case just treat "#?" as a single multiplier
                // { min: 0, max: 0, comma: true }
                tokenizer.pos++;
                range = {
                    min: 0,
                    max: 0
                };
            } else {
                range = {
                    min: 1,
                    max: 0
                };
            }

            break;

        case LEFTCURLYBRACKET:
            range = readMultiplierRange(tokenizer);
            break;

        default:
            return null;
    }

    return {
        type: 'Multiplier',
        comma,
        min: range.min,
        max: range.max,
        term: null
    };
}

function maybeMultiplied(tokenizer, node) {
    const multiplier = readMultiplier(tokenizer);

    if (multiplier !== null) {
        multiplier.term = node;

        // https://www.w3.org/TR/css-values-4/#component-multipliers
        // > The + and # multipliers may be stacked as +#;
        // Represent "+#" as nested multipliers:
        // { ...<multiplier #>,
        //   term: {
        //     ...<multipler +>,
        //     term: node
        //   }
        // }
        if (tokenizer.charCode() === NUMBERSIGN$3 &&
            tokenizer.charCodeAt(tokenizer.pos - 1) === PLUSSIGN$6) {
            return maybeMultiplied(tokenizer, multiplier);
        }

        return multiplier;
    }

    return node;
}

function maybeToken(tokenizer) {
    const ch = tokenizer.peek();

    if (ch === '') {
        return null;
    }

    return {
        type: 'Token',
        value: ch
    };
}

function readProperty$1(tokenizer) {
    let name;

    tokenizer.eat(LESSTHANSIGN);
    tokenizer.eat(APOSTROPHE$2);

    name = scanWord(tokenizer);

    tokenizer.eat(APOSTROPHE$2);
    tokenizer.eat(GREATERTHANSIGN$2);

    return maybeMultiplied(tokenizer, {
        type: 'Property',
        name
    });
}

// https://drafts.csswg.org/css-values-3/#numeric-ranges
// 4.1. Range Restrictions and Range Definition Notation
//
// Range restrictions can be annotated in the numeric type notation using CSS bracketed
// range notation—[min,max]—within the angle brackets, after the identifying keyword,
// indicating a closed range between (and including) min and max.
// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
function readTypeRange(tokenizer) {
    // use null for Infinity to make AST format JSON serializable/deserializable
    let min = null; // -Infinity
    let max = null; // Infinity
    let sign = 1;

    tokenizer.eat(LEFTSQUAREBRACKET);

    if (tokenizer.charCode() === HYPERMINUS) {
        tokenizer.peek();
        sign = -1;
    }

    if (sign == -1 && tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
    } else {
        min = sign * Number(scanNumber(tokenizer));

        if (NAME_CHAR[tokenizer.charCode()] !== 0) {
            min += scanWord(tokenizer);
        }
    }

    scanSpaces(tokenizer);
    tokenizer.eat(COMMA);
    scanSpaces(tokenizer);

    if (tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
    } else {
        sign = 1;

        if (tokenizer.charCode() === HYPERMINUS) {
            tokenizer.peek();
            sign = -1;
        }

        max = sign * Number(scanNumber(tokenizer));

        if (NAME_CHAR[tokenizer.charCode()] !== 0) {
            max += scanWord(tokenizer);
        }
    }

    tokenizer.eat(RIGHTSQUAREBRACKET);

    return {
        type: 'Range',
        min,
        max
    };
}

function readType(tokenizer) {
    let name;
    let opts = null;

    tokenizer.eat(LESSTHANSIGN);
    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS$2 &&
        tokenizer.nextCharCode() === RIGHTPARENTHESIS$2) {
        tokenizer.pos += 2;
        name += '()';
    }

    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
        scanSpaces(tokenizer);
        opts = readTypeRange(tokenizer);
    }

    tokenizer.eat(GREATERTHANSIGN$2);

    return maybeMultiplied(tokenizer, {
        type: 'Type',
        name,
        opts
    });
}

function readKeywordOrFunction(tokenizer) {
    const name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS$2) {
        tokenizer.pos++;

        return {
            type: 'Function',
            name
        };
    }

    return maybeMultiplied(tokenizer, {
        type: 'Keyword',
        name
    });
}

function regroupTerms(terms, combinators) {
    function createGroup(terms, combinator) {
        return {
            type: 'Group',
            terms,
            combinator,
            disallowEmpty: false,
            explicit: false
        };
    }

    let combinator;

    combinators = Object.keys(combinators)
        .sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);

    while (combinators.length > 0) {
        combinator = combinators.shift();

        let i = 0;
        let subgroupStart = 0;

        for (; i < terms.length; i++) {
            const term = terms[i];

            if (term.type === 'Combinator') {
                if (term.value === combinator) {
                    if (subgroupStart === -1) {
                        subgroupStart = i - 1;
                    }
                    terms.splice(i, 1);
                    i--;
                } else {
                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
                        terms.splice(
                            subgroupStart,
                            i - subgroupStart,
                            createGroup(terms.slice(subgroupStart, i), combinator)
                        );
                        i = subgroupStart + 1;
                    }
                    subgroupStart = -1;
                }
            }
        }

        if (subgroupStart !== -1 && combinators.length) {
            terms.splice(
                subgroupStart,
                i - subgroupStart,
                createGroup(terms.slice(subgroupStart, i), combinator)
            );
        }
    }

    return combinator;
}

function readImplicitGroup(tokenizer) {
    const terms = [];
    const combinators = {};
    let token;
    let prevToken = null;
    let prevTokenPos = tokenizer.pos;

    while (token = peek(tokenizer)) {
        if (token.type !== 'Spaces') {
            if (token.type === 'Combinator') {
                // check for combinator in group beginning and double combinator sequence
                if (prevToken === null || prevToken.type === 'Combinator') {
                    tokenizer.pos = prevTokenPos;
                    tokenizer.error('Unexpected combinator');
                }

                combinators[token.value] = true;
            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
                combinators[' '] = true;  // a b
                terms.push({
                    type: 'Combinator',
                    value: ' '
                });
            }

            terms.push(token);
            prevToken = token;
            prevTokenPos = tokenizer.pos;
        }
    }

    // check for combinator in group ending
    if (prevToken !== null && prevToken.type === 'Combinator') {
        tokenizer.pos -= prevTokenPos;
        tokenizer.error('Unexpected combinator');
    }

    return {
        type: 'Group',
        terms,
        combinator: regroupTerms(terms, combinators) || ' ',
        disallowEmpty: false,
        explicit: false
    };
}

function readGroup(tokenizer) {
    let result;

    tokenizer.eat(LEFTSQUAREBRACKET);
    result = readImplicitGroup(tokenizer);
    tokenizer.eat(RIGHTSQUAREBRACKET);

    result.explicit = true;

    if (tokenizer.charCode() === EXCLAMATIONMARK$2) {
        tokenizer.pos++;
        result.disallowEmpty = true;
    }

    return result;
}

function peek(tokenizer) {
    let code = tokenizer.charCode();

    if (code < 128 && NAME_CHAR[code] === 1) {
        return readKeywordOrFunction(tokenizer);
    }

    switch (code) {
        case RIGHTSQUAREBRACKET:
            // don't eat, stop scan a group
            break;

        case LEFTSQUAREBRACKET:
            return maybeMultiplied(tokenizer, readGroup(tokenizer));

        case LESSTHANSIGN:
            return tokenizer.nextCharCode() === APOSTROPHE$2
                ? readProperty$1(tokenizer)
                : readType(tokenizer);

        case VERTICALLINE$3:
            return {
                type: 'Combinator',
                value: tokenizer.substringToPos(
                    tokenizer.pos + (tokenizer.nextCharCode() === VERTICALLINE$3 ? 2 : 1)
                )
            };

        case AMPERSAND$5:
            tokenizer.pos++;
            tokenizer.eat(AMPERSAND$5);

            return {
                type: 'Combinator',
                value: '&&'
            };

        case COMMA:
            tokenizer.pos++;
            return {
                type: 'Comma'
            };

        case APOSTROPHE$2:
            return maybeMultiplied(tokenizer, {
                type: 'String',
                value: scanString(tokenizer)
            });

        case SPACE$2:
        case TAB:
        case N$1:
        case R:
        case F:
            return {
                type: 'Spaces',
                value: scanSpaces(tokenizer)
            };

        case COMMERCIALAT:
            code = tokenizer.nextCharCode();

            if (code < 128 && NAME_CHAR[code] === 1) {
                tokenizer.pos++;
                return {
                    type: 'AtKeyword',
                    name: scanWord(tokenizer)
                };
            }

            return maybeToken(tokenizer);

        case ASTERISK$6:
        case PLUSSIGN$6:
        case QUESTIONMARK$1:
        case NUMBERSIGN$3:
        case EXCLAMATIONMARK$2:
            // prohibited tokens (used as a multiplier start)
            break;

        case LEFTCURLYBRACKET:
            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
            // check next char isn't a number, because it's likely a disjoined multiplier
            code = tokenizer.nextCharCode();

            if (code < 48 || code > 57) {
                return maybeToken(tokenizer);
            }

            break;

        default:
            return maybeToken(tokenizer);
    }
}

function parse$X(source) {
    const tokenizer = new Tokenizer(source);
    const result = readImplicitGroup(tokenizer);

    if (tokenizer.pos !== source.length) {
        tokenizer.error('Unexpected input');
    }

    // reduce redundant groups with single group term
    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
        return result.terms[0];
    }

    return result;
}

const noop$1 = function() {};

function ensureFunction(value) {
    return typeof value === 'function' ? value : noop$1;
}

function walk$1(node, options, context) {
    function walk(node) {
        enter.call(context, node);

        switch (node.type) {
            case 'Group':
                node.terms.forEach(walk);
                break;

            case 'Multiplier':
                walk(node.term);
                break;

            case 'Type':
            case 'Property':
            case 'Keyword':
            case 'AtKeyword':
            case 'Function':
            case 'String':
            case 'Token':
            case 'Comma':
                break;

            default:
                throw new Error('Unknown type: ' + node.type);
        }

        leave.call(context, node);
    }

    let enter = noop$1;
    let leave = noop$1;

    if (typeof options === 'function') {
        enter = options;
    } else if (options) {
        enter = ensureFunction(options.enter);
        leave = ensureFunction(options.leave);
    }

    if (enter === noop$1 && leave === noop$1) {
        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
    }

    walk(node);
}

const astToTokens = {
    decorator(handlers) {
        const tokens = [];
        let curNode = null;

        return {
            ...handlers,
            node(node) {
                const tmp = curNode;
                curNode = node;
                handlers.node.call(this, node);
                curNode = tmp;
            },
            emit(value, type, auto) {
                tokens.push({
                    type,
                    value,
                    node: auto ? null : curNode
                });
            },
            result() {
                return tokens;
            }
        };
    }
};

function stringToTokens(str) {
    const tokens = [];

    tokenize$2(str, (type, start, end) =>
        tokens.push({
            type,
            value: str.slice(start, end),
            node: null
        })
    );

    return tokens;
}

function prepareTokens(value, syntax) {
    if (typeof value === 'string') {
        return stringToTokens(value);
    }

    return syntax.generate(value, astToTokens);
}

const MATCH = { type: 'Match' };
const MISMATCH = { type: 'Mismatch' };
const DISALLOW_EMPTY = { type: 'DisallowEmpty' };

const LEFTPARENTHESIS$1 = 40;  // (
const RIGHTPARENTHESIS$1 = 41; // )

function createCondition(match, thenBranch, elseBranch) {
    // reduce node count
    if (thenBranch === MATCH && elseBranch === MISMATCH) {
        return match;
    }

    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
        return match;
    }

    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
        thenBranch = match.then;
        match = match.match;
    }

    return {
        type: 'If',
        match,
        then: thenBranch,
        else: elseBranch
    };
}

function isFunctionType(name) {
    return (
        name.length > 2 &&
        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
    );
}

function isEnumCapatible(term) {
    return (
        term.type === 'Keyword' ||
        term.type === 'AtKeyword' ||
        term.type === 'Function' ||
        term.type === 'Type' && isFunctionType(term.name)
    );
}

function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
    switch (combinator) {
        case ' ': {
            // Juxtaposing components means that all of them must occur, in the given order.
            //
            // a b c
            // =
            // match a
            //   then match b
            //     then match c
            //       then MATCH
            //       else MISMATCH
            //     else MISMATCH
            //   else MISMATCH
            let result = MATCH;

            for (let i = terms.length - 1; i >= 0; i--) {
                const term = terms[i];

                result = createCondition(
                    term,
                    result,
                    MISMATCH
                );
            }
            return result;
        }

        case '|': {
            // A bar (|) separates two or more alternatives: exactly one of them must occur.
            //
            // a | b | c
            // =
            // match a
            //   then MATCH
            //   else match b
            //     then MATCH
            //     else match c
            //       then MATCH
            //       else MISMATCH

            let result = MISMATCH;
            let map = null;

            for (let i = terms.length - 1; i >= 0; i--) {
                let term = terms[i];

                // reduce sequence of keywords into a Enum
                if (isEnumCapatible(term)) {
                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                        map = Object.create(null);
                        result = createCondition(
                            {
                                type: 'Enum',
                                map
                            },
                            MATCH,
                            result
                        );
                    }

                    if (map !== null) {
                        const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
                        if (key in map === false) {
                            map[key] = term;
                            continue;
                        }
                    }
                }

                map = null;

                // create a new conditonal node
                result = createCondition(
                    term,
                    MATCH,
                    result
                );
            }
            return result;
        }

        case '&&': {
            // A double ampersand (&&) separates two or more components,
            // all of which must occur, in any order.

            // Use MatchOnce for groups with a large number of terms,
            // since &&-groups produces at least N!-node trees
            if (terms.length > 5) {
                return {
                    type: 'MatchOnce',
                    terms,
                    all: true
                };
            }

            // Use a combination tree for groups with small number of terms
            //
            // a && b && c
            // =
            // match a
            //   then [b && c]
            //   else match b
            //     then [a && c]
            //     else match c
            //       then [a && b]
            //       else MISMATCH
            //
            // a && b
            // =
            // match a
            //   then match b
            //     then MATCH
            //     else MISMATCH
            //   else match b
            //     then match a
            //       then MATCH
            //       else MISMATCH
            //     else MISMATCH
            let result = MISMATCH;

            for (let i = terms.length - 1; i >= 0; i--) {
                const term = terms[i];
                let thenClause;

                if (terms.length > 1) {
                    thenClause = buildGroupMatchGraph(
                        combinator,
                        terms.filter(function(newGroupTerm) {
                            return newGroupTerm !== term;
                        }),
                        false
                    );
                } else {
                    thenClause = MATCH;
                }

                result = createCondition(
                    term,
                    thenClause,
                    result
                );
            }
            return result;
        }

        case '||': {
            // A double bar (||) separates two or more options:
            // one or more of them must occur, in any order.

            // Use MatchOnce for groups with a large number of terms,
            // since ||-groups produces at least N!-node trees
            if (terms.length > 5) {
                return {
                    type: 'MatchOnce',
                    terms,
                    all: false
                };
            }

            // Use a combination tree for groups with small number of terms
            //
            // a || b || c
            // =
            // match a
            //   then [b || c]
            //   else match b
            //     then [a || c]
            //     else match c
            //       then [a || b]
            //       else MISMATCH
            //
            // a || b
            // =
            // match a
            //   then match b
            //     then MATCH
            //     else MATCH
            //   else match b
            //     then match a
            //       then MATCH
            //       else MATCH
            //     else MISMATCH
            let result = atLeastOneTermMatched ? MATCH : MISMATCH;

            for (let i = terms.length - 1; i >= 0; i--) {
                const term = terms[i];
                let thenClause;

                if (terms.length > 1) {
                    thenClause = buildGroupMatchGraph(
                        combinator,
                        terms.filter(function(newGroupTerm) {
                            return newGroupTerm !== term;
                        }),
                        true
                    );
                } else {
                    thenClause = MATCH;
                }

                result = createCondition(
                    term,
                    thenClause,
                    result
                );
            }
            return result;
        }
    }
}

function buildMultiplierMatchGraph(node) {
    let result = MATCH;
    let matchTerm = buildMatchGraphInternal(node.term);

    if (node.max === 0) {
        // disable repeating of empty match to prevent infinite loop
        matchTerm = createCondition(
            matchTerm,
            DISALLOW_EMPTY,
            MISMATCH
        );

        // an occurrence count is not limited, make a cycle;
        // to collect more terms on each following matching mismatch
        result = createCondition(
            matchTerm,
            null, // will be a loop
            MISMATCH
        );

        result.then = createCondition(
            MATCH,
            MATCH,
            result // make a loop
        );

        if (node.comma) {
            result.then.else = createCondition(
                { type: 'Comma', syntax: node },
                result,
                MISMATCH
            );
        }
    } else {
        // create a match node chain for [min .. max] interval with optional matches
        for (let i = node.min || 1; i <= node.max; i++) {
            if (node.comma && result !== MATCH) {
                result = createCondition(
                    { type: 'Comma', syntax: node },
                    result,
                    MISMATCH
                );
            }

            result = createCondition(
                matchTerm,
                createCondition(
                    MATCH,
                    MATCH,
                    result
                ),
                MISMATCH
            );
        }
    }

    if (node.min === 0) {
        // allow zero match
        result = createCondition(
            MATCH,
            MATCH,
            result
        );
    } else {
        // create a match node chain to collect [0 ... min - 1] required matches
        for (let i = 0; i < node.min - 1; i++) {
            if (node.comma && result !== MATCH) {
                result = createCondition(
                    { type: 'Comma', syntax: node },
                    result,
                    MISMATCH
                );
            }

            result = createCondition(
                matchTerm,
                result,
                MISMATCH
            );
        }
    }

    return result;
}

function buildMatchGraphInternal(node) {
    if (typeof node === 'function') {
        return {
            type: 'Generic',
            fn: node
        };
    }

    switch (node.type) {
        case 'Group': {
            let result = buildGroupMatchGraph(
                node.combinator,
                node.terms.map(buildMatchGraphInternal),
                false
            );

            if (node.disallowEmpty) {
                result = createCondition(
                    result,
                    DISALLOW_EMPTY,
                    MISMATCH
                );
            }

            return result;
        }

        case 'Multiplier':
            return buildMultiplierMatchGraph(node);

        case 'Type':
        case 'Property':
            return {
                type: node.type,
                name: node.name,
                syntax: node
            };

        case 'Keyword':
            return {
                type: node.type,
                name: node.name.toLowerCase(),
                syntax: node
            };

        case 'AtKeyword':
            return {
                type: node.type,
                name: '@' + node.name.toLowerCase(),
                syntax: node
            };

        case 'Function':
            return {
                type: node.type,
                name: node.name.toLowerCase() + '(',
                syntax: node
            };

        case 'String':
            // convert a one char length String to a Token
            if (node.value.length === 3) {
                return {
                    type: 'Token',
                    value: node.value.charAt(1),
                    syntax: node
                };
            }

            // otherwise use it as is
            return {
                type: node.type,
                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
                syntax: node
            };

        case 'Token':
            return {
                type: node.type,
                value: node.value,
                syntax: node
            };

        case 'Comma':
            return {
                type: node.type,
                syntax: node
            };

        default:
            throw new Error('Unknown node type:', node.type);
    }
}

function buildMatchGraph(syntaxTree, ref) {
    if (typeof syntaxTree === 'string') {
        syntaxTree = parse$X(syntaxTree);
    }

    return {
        type: 'MatchGraph',
        match: buildMatchGraphInternal(syntaxTree),
        syntax: ref || null,
        source: syntaxTree
    };
}

const { hasOwnProperty: hasOwnProperty$3 } = Object.prototype;
const STUB = 0;
const TOKEN = 1;
const OPEN_SYNTAX = 2;
const CLOSE_SYNTAX = 3;

const EXIT_REASON_MATCH = 'Match';
const EXIT_REASON_MISMATCH = 'Mismatch';
const EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

const ITERATION_LIMIT = 15000;

function reverseList(list) {
    let prev = null;
    let next = null;
    let item = list;

    while (item !== null) {
        next = item.prev;
        item.prev = prev;
        prev = item;
        item = next;
    }

    return prev;
}

function areStringsEqualCaseInsensitive(testStr, referenceStr) {
    if (testStr.length !== referenceStr.length) {
        return false;
    }

    for (let i = 0; i < testStr.length; i++) {
        const referenceCode = referenceStr.charCodeAt(i);
        let testCode = testStr.charCodeAt(i);

        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
        if (testCode >= 0x0041 && testCode <= 0x005A) {
            testCode = testCode | 32;
        }

        if (testCode !== referenceCode) {
            return false;
        }
    }

    return true;
}

function isContextEdgeDelim(token) {
    if (token.type !== Delim) {
        return false;
    }

    // Fix matching for unicode-range: U+30??, U+FF00-FF9F
    // Probably we need to check out previous match instead
    return token.value !== '?';
}

function isCommaContextStart(token) {
    if (token === null) {
        return true;
    }

    return (
        token.type === Comma ||
        token.type === Function$2 ||
        token.type === LeftParenthesis ||
        token.type === LeftSquareBracket ||
        token.type === LeftCurlyBracket ||
        isContextEdgeDelim(token)
    );
}

function isCommaContextEnd(token) {
    if (token === null) {
        return true;
    }

    return (
        token.type === RightParenthesis ||
        token.type === RightSquareBracket ||
        token.type === RightCurlyBracket ||
        (token.type === Delim && token.value === '/')
    );
}

function internalMatch(tokens, state, syntaxes) {
    function moveToNextToken() {
        do {
            tokenIndex++;
            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        } while (token !== null && (token.type === WhiteSpace$1 || token.type === Comment$1));
    }

    function getNextToken(offset) {
        const nextIndex = tokenIndex + offset;

        return nextIndex < tokens.length ? tokens[nextIndex] : null;
    }

    function stateSnapshotFromSyntax(nextState, prev) {
        return {
            nextState,
            matchStack,
            syntaxStack,
            thenStack,
            tokenIndex,
            prev
        };
    }

    function pushThenStack(nextState) {
        thenStack = {
            nextState,
            matchStack,
            syntaxStack,
            prev: thenStack
        };
    }

    function pushElseStack(nextState) {
        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
    }

    function addTokenToMatch() {
        matchStack = {
            type: TOKEN,
            syntax: state.syntax,
            token,
            prev: matchStack
        };

        moveToNextToken();
        syntaxStash = null;

        if (tokenIndex > longestMatch) {
            longestMatch = tokenIndex;
        }
    }

    function openSyntax() {
        syntaxStack = {
            syntax: state.syntax,
            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
            prev: syntaxStack
        };

        matchStack = {
            type: OPEN_SYNTAX,
            syntax: state.syntax,
            token: matchStack.token,
            prev: matchStack
        };
    }

    function closeSyntax() {
        if (matchStack.type === OPEN_SYNTAX) {
            matchStack = matchStack.prev;
        } else {
            matchStack = {
                type: CLOSE_SYNTAX,
                syntax: syntaxStack.syntax,
                token: matchStack.token,
                prev: matchStack
            };
        }

        syntaxStack = syntaxStack.prev;
    }

    let syntaxStack = null;
    let thenStack = null;
    let elseStack = null;

    // null – stashing allowed, nothing stashed
    // false – stashing disabled, nothing stashed
    // anithing else – fail stashable syntaxes, some syntax stashed
    let syntaxStash = null;

    let iterationCount = 0; // count iterations and prevent infinite loop
    let exitReason = null;

    let token = null;
    let tokenIndex = -1;
    let longestMatch = 0;
    let matchStack = {
        type: STUB,
        syntax: null,
        token: null,
        prev: null
    };

    moveToNextToken();

    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
        // function mapList(list, fn) {
        //     const result = [];
        //     while (list) {
        //         result.unshift(fn(list));
        //         list = list.prev;
        //     }
        //     return result;
        // }
        // console.log('--\n',
        //     '#' + iterationCount,
        //     require('util').inspect({
        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
        //         token: token && token.value,
        //         tokenIndex,
        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
        //     }, { depth: null })
        // );
        switch (state.type) {
            case 'Match':
                if (thenStack === null) {
                    // turn to MISMATCH when some tokens left unmatched
                    if (token !== null) {
                        // doesn't mismatch if just one token left and it's an IE hack
                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
                            state = MISMATCH;
                            break;
                        }
                    }

                    // break the main loop, return a result - MATCH
                    exitReason = EXIT_REASON_MATCH;
                    break;
                }

                // go to next syntax (`then` branch)
                state = thenStack.nextState;

                // check match is not empty
                if (state === DISALLOW_EMPTY) {
                    if (thenStack.matchStack === matchStack) {
                        state = MISMATCH;
                        break;
                    } else {
                        state = MATCH;
                    }
                }

                // close syntax if needed
                while (thenStack.syntaxStack !== syntaxStack) {
                    closeSyntax();
                }

                // pop stack
                thenStack = thenStack.prev;
                break;

            case 'Mismatch':
                // when some syntax is stashed
                if (syntaxStash !== null && syntaxStash !== false) {
                    // there is no else branches or a branch reduce match stack
                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
                        // restore state from the stash
                        elseStack = syntaxStash;
                        syntaxStash = false; // disable stashing
                    }
                } else if (elseStack === null) {
                    // no else branches -> break the main loop
                    // return a result - MISMATCH
                    exitReason = EXIT_REASON_MISMATCH;
                    break;
                }

                // go to next syntax (`else` branch)
                state = elseStack.nextState;

                // restore all the rest stack states
                thenStack = elseStack.thenStack;
                syntaxStack = elseStack.syntaxStack;
                matchStack = elseStack.matchStack;
                tokenIndex = elseStack.tokenIndex;
                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

                // pop stack
                elseStack = elseStack.prev;
                break;

            case 'MatchGraph':
                state = state.match;
                break;

            case 'If':
                // IMPORTANT: else stack push must go first,
                // since it stores the state of thenStack before changes
                if (state.else !== MISMATCH) {
                    pushElseStack(state.else);
                }

                if (state.then !== MATCH) {
                    pushThenStack(state.then);
                }

                state = state.match;
                break;

            case 'MatchOnce':
                state = {
                    type: 'MatchOnceBuffer',
                    syntax: state,
                    index: 0,
                    mask: 0
                };
                break;

            case 'MatchOnceBuffer': {
                const terms = state.syntax.terms;

                if (state.index === terms.length) {
                    // no matches at all or it's required all terms to be matched
                    if (state.mask === 0 || state.syntax.all) {
                        state = MISMATCH;
                        break;
                    }

                    // a partial match is ok
                    state = MATCH;
                    break;
                }

                // all terms are matched
                if (state.mask === (1 << terms.length) - 1) {
                    state = MATCH;
                    break;
                }

                for (; state.index < terms.length; state.index++) {
                    const matchFlag = 1 << state.index;

                    if ((state.mask & matchFlag) === 0) {
                        // IMPORTANT: else stack push must go first,
                        // since it stores the state of thenStack before changes
                        pushElseStack(state);
                        pushThenStack({
                            type: 'AddMatchOnce',
                            syntax: state.syntax,
                            mask: state.mask | matchFlag
                        });

                        // match
                        state = terms[state.index++];
                        break;
                    }
                }
                break;
            }

            case 'AddMatchOnce':
                state = {
                    type: 'MatchOnceBuffer',
                    syntax: state.syntax,
                    index: 0,
                    mask: state.mask
                };
                break;

            case 'Enum':
                if (token !== null) {
                    let name = token.value.toLowerCase();

                    // drop \0 and \9 hack from keyword name
                    if (name.indexOf('\\') !== -1) {
                        name = name.replace(/\\[09].*$/, '');
                    }

                    if (hasOwnProperty$3.call(state.map, name)) {
                        state = state.map[name];
                        break;
                    }
                }

                state = MISMATCH;
                break;

            case 'Generic': {
                const opts = syntaxStack !== null ? syntaxStack.opts : null;
                const lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
                    while (tokenIndex < lastTokenIndex) {
                        addTokenToMatch();
                    }

                    state = MATCH;
                } else {
                    state = MISMATCH;
                }

                break;
            }

            case 'Type':
            case 'Property': {
                const syntaxDict = state.type === 'Type' ? 'types' : 'properties';
                const dictSyntax = hasOwnProperty$3.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

                if (!dictSyntax || !dictSyntax.match) {
                    throw new Error(
                        'Bad syntax reference: ' +
                        (state.type === 'Type'
                            ? '<' + state.name + '>'
                            : '<\'' + state.name + '\'>')
                    );
                }

                // stash a syntax for types with low priority
                if (syntaxStash !== false && token !== null && state.type === 'Type') {
                    const lowPriorityMatching =
                        // https://drafts.csswg.org/css-values-4/#custom-idents
                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
                        // can only claim the keyword if no other unfulfilled production can claim it.
                        (state.name === 'custom-ident' && token.type === Ident) ||

                        // https://drafts.csswg.org/css-values-4/#lengths
                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
                        // it must parse as a <number>
                        (state.name === 'length' && token.value === '0');

                    if (lowPriorityMatching) {
                        if (syntaxStash === null) {
                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
                        }

                        state = MISMATCH;
                        break;
                    }
                }

                openSyntax();
                state = dictSyntax.match;
                break;
            }

            case 'Keyword': {
                const name = state.name;

                if (token !== null) {
                    let keywordName = token.value;

                    // drop \0 and \9 hack from keyword name
                    if (keywordName.indexOf('\\') !== -1) {
                        keywordName = keywordName.replace(/\\[09].*$/, '');
                    }

                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
                        addTokenToMatch();
                        state = MATCH;
                        break;
                    }
                }

                state = MISMATCH;
                break;
            }

            case 'AtKeyword':
            case 'Function':
                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
                    addTokenToMatch();
                    state = MATCH;
                    break;
                }

                state = MISMATCH;
                break;

            case 'Token':
                if (token !== null && token.value === state.value) {
                    addTokenToMatch();
                    state = MATCH;
                    break;
                }

                state = MISMATCH;
                break;

            case 'Comma':
                if (token !== null && token.type === Comma) {
                    if (isCommaContextStart(matchStack.token)) {
                        state = MISMATCH;
                    } else {
                        addTokenToMatch();
                        state = isCommaContextEnd(token) ? MISMATCH : MATCH;
                    }
                } else {
                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
                }

                break;

            case 'String':
                let string = '';
                let lastTokenIndex = tokenIndex;

                for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
                    string += tokens[lastTokenIndex].value;
                }

                if (areStringsEqualCaseInsensitive(string, state.value)) {
                    while (tokenIndex < lastTokenIndex) {
                        addTokenToMatch();
                    }

                    state = MATCH;
                } else {
                    state = MISMATCH;
                }

                break;

            default:
                throw new Error('Unknown node type: ' + state.type);
        }
    }

    switch (exitReason) {
        case null:
            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
            exitReason = EXIT_REASON_ITERATION_LIMIT;
            matchStack = null;
            break;

        case EXIT_REASON_MATCH:
            while (syntaxStack !== null) {
                closeSyntax();
            }
            break;

        default:
            matchStack = null;
    }

    return {
        tokens,
        reason: exitReason,
        iterations: iterationCount,
        match: matchStack,
        longestMatch
    };
}

function matchAsTree(tokens, matchGraph, syntaxes) {
    const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match === null) {
        return matchResult;
    }

    let item = matchResult.match;
    let host = matchResult.match = {
        syntax: matchGraph.syntax || null,
        match: []
    };
    const hostStack = [host];

    // revert a list and start with 2nd item since 1st is a stub item
    item = reverseList(item).prev;

    // build a tree
    while (item !== null) {
        switch (item.type) {
            case OPEN_SYNTAX:
                host.match.push(host = {
                    syntax: item.syntax,
                    match: []
                });
                hostStack.push(host);
                break;

            case CLOSE_SYNTAX:
                hostStack.pop();
                host = hostStack[hostStack.length - 1];
                break;

            default:
                host.match.push({
                    syntax: item.syntax || null,
                    token: item.token.value,
                    node: item.token.node
                });
        }

        item = item.prev;
    }

    return matchResult;
}

function getTrace(node) {
    function shouldPutToTrace(syntax) {
        if (syntax === null) {
            return false;
        }

        return (
            syntax.type === 'Type' ||
            syntax.type === 'Property' ||
            syntax.type === 'Keyword'
        );
    }

    function hasMatch(matchNode) {
        if (Array.isArray(matchNode.match)) {
            // use for-loop for better perfomance
            for (let i = 0; i < matchNode.match.length; i++) {
                if (hasMatch(matchNode.match[i])) {
                    if (shouldPutToTrace(matchNode.syntax)) {
                        result.unshift(matchNode.syntax);
                    }

                    return true;
                }
            }
        } else if (matchNode.node === node) {
            result = shouldPutToTrace(matchNode.syntax)
                ? [matchNode.syntax]
                : [];

            return true;
        }

        return false;
    }

    let result = null;

    if (this.matched !== null) {
        hasMatch(this.matched);
    }

    return result;
}

function isType(node, type) {
    return testNode(this, node, match => match.type === 'Type' && match.name === type);
}

function isProperty(node, property) {
    return testNode(this, node, match => match.type === 'Property' && match.name === property);
}

function isKeyword(node) {
    return testNode(this, node, match => match.type === 'Keyword');
}

function testNode(match, node, fn) {
    const trace = getTrace.call(match, node);

    if (trace === null) {
        return false;
    }

    return trace.some(fn);
}

var trace = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getTrace: getTrace,
  isKeyword: isKeyword,
  isProperty: isProperty,
  isType: isType
});

function getFirstMatchNode(matchNode) {
    if ('node' in matchNode) {
        return matchNode.node;
    }

    return getFirstMatchNode(matchNode.match[0]);
}

function getLastMatchNode(matchNode) {
    if ('node' in matchNode) {
        return matchNode.node;
    }

    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}

function matchFragments(lexer, ast, match, type, name) {
    function findFragments(matchNode) {
        if (matchNode.syntax !== null &&
            matchNode.syntax.type === type &&
            matchNode.syntax.name === name) {
            const start = getFirstMatchNode(matchNode);
            const end = getLastMatchNode(matchNode);

            lexer.syntax.walk(ast, function(node, item, list) {
                if (node === start) {
                    const nodes = new List();

                    do {
                        nodes.appendData(item.data);

                        if (item.data === end) {
                            break;
                        }

                        item = item.next;
                    } while (item !== null);

                    fragments.push({
                        parent: list,
                        nodes
                    });
                }
            });
        }

        if (Array.isArray(matchNode.match)) {
            matchNode.match.forEach(findFragments);
        }
    }

    const fragments = [];

    if (match.matched !== null) {
        findFragments(match.matched);
    }

    return fragments;
}

const { hasOwnProperty: hasOwnProperty$2 } = Object.prototype;

function isValidNumber(value) {
    // Number.isInteger(value) && value >= 0
    return (
        typeof value === 'number' &&
        isFinite(value) &&
        Math.floor(value) === value &&
        value >= 0
    );
}

function isValidLocation(loc) {
    return (
        Boolean(loc) &&
        isValidNumber(loc.offset) &&
        isValidNumber(loc.line) &&
        isValidNumber(loc.column)
    );
}

function createNodeStructureChecker(type, fields) {
    return function checkNode(node, warn) {
        if (!node || node.constructor !== Object) {
            return warn(node, 'Type of node should be an Object');
        }

        for (let key in node) {
            let valid = true;

            if (hasOwnProperty$2.call(node, key) === false) {
                continue;
            }

            if (key === 'type') {
                if (node.type !== type) {
                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
                }
            } else if (key === 'loc') {
                if (node.loc === null) {
                    continue;
                } else if (node.loc && node.loc.constructor === Object) {
                    if (typeof node.loc.source !== 'string') {
                        key += '.source';
                    } else if (!isValidLocation(node.loc.start)) {
                        key += '.start';
                    } else if (!isValidLocation(node.loc.end)) {
                        key += '.end';
                    } else {
                        continue;
                    }
                }

                valid = false;
            } else if (fields.hasOwnProperty(key)) {
                valid = false;

                for (let i = 0; !valid && i < fields[key].length; i++) {
                    const fieldType = fields[key][i];

                    switch (fieldType) {
                        case String:
                            valid = typeof node[key] === 'string';
                            break;

                        case Boolean:
                            valid = typeof node[key] === 'boolean';
                            break;

                        case null:
                            valid = node[key] === null;
                            break;

                        default:
                            if (typeof fieldType === 'string') {
                                valid = node[key] && node[key].type === fieldType;
                            } else if (Array.isArray(fieldType)) {
                                valid = node[key] instanceof List;
                            }
                    }
                }
            } else {
                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
            }

            if (!valid) {
                warn(node, 'Bad value for `' + type + '.' + key + '`');
            }
        }

        for (const key in fields) {
            if (hasOwnProperty$2.call(fields, key) &&
                hasOwnProperty$2.call(node, key) === false) {
                warn(node, 'Field `' + type + '.' + key + '` is missed');
            }
        }
    };
}

function processStructure(name, nodeType) {
    const structure = nodeType.structure;
    const fields = {
        type: String,
        loc: true
    };
    const docs = {
        type: '"' + name + '"'
    };

    for (const key in structure) {
        if (hasOwnProperty$2.call(structure, key) === false) {
            continue;
        }

        const docsTypes = [];
        const fieldTypes = fields[key] = Array.isArray(structure[key])
            ? structure[key].slice()
            : [structure[key]];

        for (let i = 0; i < fieldTypes.length; i++) {
            const fieldType = fieldTypes[i];
            if (fieldType === String || fieldType === Boolean) {
                docsTypes.push(fieldType.name);
            } else if (fieldType === null) {
                docsTypes.push('null');
            } else if (typeof fieldType === 'string') {
                docsTypes.push('<' + fieldType + '>');
            } else if (Array.isArray(fieldType)) {
                docsTypes.push('List'); // TODO: use type enum
            } else {
                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
            }
        }

        docs[key] = docsTypes.join(' | ');
    }

    return {
        docs,
        check: createNodeStructureChecker(name, fields)
    };
}

function getStructureFromConfig(config) {
    const structure = {};

    if (config.node) {
        for (const name in config.node) {
            if (hasOwnProperty$2.call(config.node, name)) {
                const nodeType = config.node[name];

                if (nodeType.structure) {
                    structure[name] = processStructure(name, nodeType);
                } else {
                    throw new Error('Missed `structure` field in `' + name + '` node type definition');
                }
            }
        }
    }

    return structure;
}

const cssWideKeywordsSyntax = buildMatchGraph(cssWideKeywords.join(' | '));

function dumpMapSyntax(map, compact, syntaxAsAst) {
    const result = {};

    for (const name in map) {
        if (map[name].syntax) {
            result[name] = syntaxAsAst
                ? map[name].syntax
                : generate$N(map[name].syntax, { compact });
        }
    }

    return result;
}

function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
    const result = {};

    for (const [name, atrule] of Object.entries(map)) {
        result[name] = {
            prelude: atrule.prelude && (
                syntaxAsAst
                    ? atrule.prelude.syntax
                    : generate$N(atrule.prelude.syntax, { compact })
            ),
            descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
        };
    }

    return result;
}

function valueHasVar(tokens) {
    for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].value.toLowerCase() === 'var(') {
            return true;
        }
    }

    return false;
}

function buildMatchResult(matched, error, iterations) {
    return {
        matched,
        iterations,
        error,
        ...trace
    };
}

function matchSyntax(lexer, syntax, value, useCssWideKeywords) {
    const tokens = prepareTokens(value, lexer.syntax);
    let result;

    if (valueHasVar(tokens)) {
        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
    }

    if (useCssWideKeywords) {
        result = matchAsTree(tokens, lexer.cssWideKeywordsSyntax, lexer);
    }

    if (!useCssWideKeywords || !result.match) {
        result = matchAsTree(tokens, syntax.match, lexer);
        if (!result.match) {
            return buildMatchResult(
                null,
                new SyntaxMatchError(result.reason, syntax.syntax, value, result),
                result.iterations
            );
        }
    }

    return buildMatchResult(result.match, null, result.iterations);
}

class Lexer {
    constructor(config, syntax, structure) {
        this.cssWideKeywordsSyntax = cssWideKeywordsSyntax;
        this.syntax = syntax;
        this.generic = false;
        this.units = { ...units };
        this.atrules = Object.create(null);
        this.properties = Object.create(null);
        this.types = Object.create(null);
        this.structure = structure || getStructureFromConfig(config);

        if (config) {
            if (config.units) {
                for (const group of Object.keys(units)) {
                    if (Array.isArray(config.units[group])) {
                        this.units[group] = config.units[group];
                    }
                }
            }

            if (config.types) {
                for (const name in config.types) {
                    this.addType_(name, config.types[name]);
                }
            }

            if (config.generic) {
                this.generic = true;
                for (const [name, value] of Object.entries(createGenericTypes(this.units))) {
                    this.addType_(name, value);
                }
            }

            if (config.atrules) {
                for (const name in config.atrules) {
                    this.addAtrule_(name, config.atrules[name]);
                }
            }

            if (config.properties) {
                for (const name in config.properties) {
                    this.addProperty_(name, config.properties[name]);
                }
            }
        }
    }

    checkStructure(ast) {
        function collectWarning(node, message) {
            warns.push({ node, message });
        }

        const structure = this.structure;
        const warns = [];

        this.syntax.walk(ast, function(node) {
            if (structure.hasOwnProperty(node.type)) {
                structure[node.type].check(node, collectWarning);
            } else {
                collectWarning(node, 'Unknown node type `' + node.type + '`');
            }
        });

        return warns.length ? warns : false;
    }

    createDescriptor(syntax, type, name, parent = null) {
        const ref = {
            type,
            name
        };
        const descriptor = {
            type,
            name,
            parent,
            serializable: typeof syntax === 'string' || (syntax && typeof syntax.type === 'string'),
            syntax: null,
            match: null
        };

        if (typeof syntax === 'function') {
            descriptor.match = buildMatchGraph(syntax, ref);
        } else {
            if (typeof syntax === 'string') {
                // lazy parsing on first access
                Object.defineProperty(descriptor, 'syntax', {
                    get() {
                        Object.defineProperty(descriptor, 'syntax', {
                            value: parse$X(syntax)
                        });

                        return descriptor.syntax;
                    }
                });
            } else {
                descriptor.syntax = syntax;
            }

            // lazy graph build on first access
            Object.defineProperty(descriptor, 'match', {
                get() {
                    Object.defineProperty(descriptor, 'match', {
                        value: buildMatchGraph(descriptor.syntax, ref)
                    });

                    return descriptor.match;
                }
            });
        }

        return descriptor;
    }
    addAtrule_(name, syntax) {
        if (!syntax) {
            return;
        }

        this.atrules[name] = {
            type: 'Atrule',
            name: name,
            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
            descriptors: syntax.descriptors
                ? Object.keys(syntax.descriptors).reduce(
                    (map, descName) => {
                        map[descName] = this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);
                        return map;
                    },
                    Object.create(null)
                )
                : null
        };
    }
    addProperty_(name, syntax) {
        if (!syntax) {
            return;
        }

        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
    }
    addType_(name, syntax) {
        if (!syntax) {
            return;
        }

        this.types[name] = this.createDescriptor(syntax, 'Type', name);
    }

    checkAtruleName(atruleName) {
        if (!this.getAtrule(atruleName)) {
            return new SyntaxReferenceError('Unknown at-rule', '@' + atruleName);
        }
    }
    checkAtrulePrelude(atruleName, prelude) {
        const error = this.checkAtruleName(atruleName);

        if (error) {
            return error;
        }

        const atrule = this.getAtrule(atruleName);

        if (!atrule.prelude && prelude) {
            return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');
        }

        if (atrule.prelude && !prelude) {
            if (!matchSyntax(this, atrule.prelude, '', false).matched) {
                return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');
            }
        }
    }
    checkAtruleDescriptorName(atruleName, descriptorName) {
        const error = this.checkAtruleName(atruleName);

        if (error) {
            return error;
        }

        const atrule = this.getAtrule(atruleName);
        const descriptor = keyword(descriptorName);

        if (!atrule.descriptors) {
            return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');
        }

        if (!atrule.descriptors[descriptor.name] &&
            !atrule.descriptors[descriptor.basename]) {
            return new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);
        }
    }
    checkPropertyName(propertyName) {
        if (!this.getProperty(propertyName)) {
            return new SyntaxReferenceError('Unknown property', propertyName);
        }
    }

    matchAtrulePrelude(atruleName, prelude) {
        const error = this.checkAtrulePrelude(atruleName, prelude);

        if (error) {
            return buildMatchResult(null, error);
        }

        const atrule = this.getAtrule(atruleName);

        if (!atrule.prelude) {
            return buildMatchResult(null, null);
        }

        return matchSyntax(this, atrule.prelude, prelude || '', false);
    }
    matchAtruleDescriptor(atruleName, descriptorName, value) {
        const error = this.checkAtruleDescriptorName(atruleName, descriptorName);

        if (error) {
            return buildMatchResult(null, error);
        }

        const atrule = this.getAtrule(atruleName);
        const descriptor = keyword(descriptorName);

        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
    }
    matchDeclaration(node) {
        if (node.type !== 'Declaration') {
            return buildMatchResult(null, new Error('Not a Declaration node'));
        }

        return this.matchProperty(node.property, node.value);
    }
    matchProperty(propertyName, value) {
        // don't match syntax for a custom property at the moment
        if (property(propertyName).custom) {
            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
        }

        const error = this.checkPropertyName(propertyName);

        if (error) {
            return buildMatchResult(null, error);
        }

        return matchSyntax(this, this.getProperty(propertyName), value, true);
    }
    matchType(typeName, value) {
        const typeSyntax = this.getType(typeName);

        if (!typeSyntax) {
            return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));
        }

        return matchSyntax(this, typeSyntax, value, false);
    }
    match(syntax, value) {
        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
            return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));
        }

        if (typeof syntax === 'string' || !syntax.match) {
            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
        }

        return matchSyntax(this, syntax, value, false);
    }

    findValueFragments(propertyName, value, type, name) {
        return matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
    }
    findDeclarationValueFragments(declaration, type, name) {
        return matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
    }
    findAllFragments(ast, type, name) {
        const result = [];

        this.syntax.walk(ast, {
            visit: 'Declaration',
            enter: (declaration) => {
                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
            }
        });

        return result;
    }

    getAtrule(atruleName, fallbackBasename = true) {
        const atrule = keyword(atruleName);
        const atruleEntry = atrule.vendor && fallbackBasename
            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
            : this.atrules[atrule.name];

        return atruleEntry || null;
    }
    getAtrulePrelude(atruleName, fallbackBasename = true) {
        const atrule = this.getAtrule(atruleName, fallbackBasename);

        return atrule && atrule.prelude || null;
    }
    getAtruleDescriptor(atruleName, name) {
        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
            ? this.atrules[atruleName].declarators[name] || null
            : null;
    }
    getProperty(propertyName, fallbackBasename = true) {
        const property$1 = property(propertyName);
        const propertyEntry = property$1.vendor && fallbackBasename
            ? this.properties[property$1.name] || this.properties[property$1.basename]
            : this.properties[property$1.name];

        return propertyEntry || null;
    }
    getType(name) {
        return hasOwnProperty.call(this.types, name) ? this.types[name] : null;
    }

    validate() {
        function validate(syntax, name, broken, descriptor) {
            if (broken.has(name)) {
                return broken.get(name);
            }

            broken.set(name, false);
            if (descriptor.syntax !== null) {
                walk$1(descriptor.syntax, function(node) {
                    if (node.type !== 'Type' && node.type !== 'Property') {
                        return;
                    }

                    const map = node.type === 'Type' ? syntax.types : syntax.properties;
                    const brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

                    if (!hasOwnProperty.call(map, node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
                        broken.set(name, true);
                    }
                }, this);
            }
        }

        let brokenTypes = new Map();
        let brokenProperties = new Map();

        for (const key in this.types) {
            validate(this, key, brokenTypes, this.types[key]);
        }

        for (const key in this.properties) {
            validate(this, key, brokenProperties, this.properties[key]);
        }

        brokenTypes = [...brokenTypes.keys()].filter(name => brokenTypes.get(name));
        brokenProperties = [...brokenProperties.keys()].filter(name => brokenProperties.get(name));

        if (brokenTypes.length || brokenProperties.length) {
            return {
                types: brokenTypes,
                properties: brokenProperties
            };
        }

        return null;
    }
    dump(syntaxAsAst, pretty) {
        return {
            generic: this.generic,
            units: this.units,
            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
        };
    }
    toString() {
        return JSON.stringify(this.dump());
    }
}

function appendOrSet(a, b) {
    if (typeof b === 'string' && /^\s*\|/.test(b)) {
        return typeof a === 'string'
            ? a + b
            : b.replace(/^\s*\|\s*/, '');
    }

    return b || null;
}

function sliceProps(obj, props) {
    const result = Object.create(null);

    for (const [key, value] of Object.entries(obj)) {
        if (value) {
            result[key] = {};
            for (const prop of Object.keys(value)) {
                if (props.includes(prop)) {
                    result[key][prop] = value[prop];
                }
            }
        }
    }

    return result;
}

function mix(dest, src) {
    const result = { ...dest };

    for (const [prop, value] of Object.entries(src)) {
        switch (prop) {
            case 'generic':
                result[prop] = Boolean(value);
                break;

            case 'units':
                result[prop] = { ...dest[prop] };
                for (const [name, patch] of Object.entries(value)) {
                    result[prop][name] = Array.isArray(patch) ? patch : [];
                }
                break;

            case 'atrules':
                result[prop] = { ...dest[prop] };

                for (const [name, atrule] of Object.entries(value)) {
                    const exists = result[prop][name] || {};
                    const current = result[prop][name] = {
                        prelude: exists.prelude || null,
                        descriptors: {
                            ...exists.descriptors
                        }
                    };

                    if (!atrule) {
                        continue;
                    }

                    current.prelude = atrule.prelude
                        ? appendOrSet(current.prelude, atrule.prelude)
                        : current.prelude || null;

                    for (const [descriptorName, descriptorValue] of Object.entries(atrule.descriptors || {})) {
                        current.descriptors[descriptorName] = descriptorValue
                            ? appendOrSet(current.descriptors[descriptorName], descriptorValue)
                            : null;
                    }

                    if (!Object.keys(current.descriptors).length) {
                        current.descriptors = null;
                    }
                }
                break;

            case 'types':
            case 'properties':
                result[prop] = { ...dest[prop] };
                for (const [name, syntax] of Object.entries(value)) {
                    result[prop][name] = appendOrSet(result[prop][name], syntax);
                }
                break;

            case 'scope':
                result[prop] = { ...dest[prop] };
                for (const [name, props] of Object.entries(value)) {
                    result[prop][name] = { ...result[prop][name], ...props };
                }
                break;

            case 'parseContext':
                result[prop] = {
                    ...dest[prop],
                    ...value
                };
                break;

            case 'atrule':
            case 'pseudo':
                result[prop] = {
                    ...dest[prop],
                    ...sliceProps(value, ['parse']) };
                break;

            case 'node':
                result[prop] = {
                    ...dest[prop],
                    ...sliceProps(value, ['name', 'structure', 'parse', 'generate', 'walkContext'])
                };
                break;
        }
    }

    return result;
}

function createSyntax(config) {
    const parse = createParser(config);
    const walk = createWalker(config);
    const generate = createGenerator(config);
    const { fromPlainObject, toPlainObject } = createConvertor(walk);

    const syntax = {
        lexer: null,
        createLexer: config => new Lexer(config, syntax, syntax.lexer.structure),

        tokenize: tokenize$2,
        parse,
        generate,

        walk,
        find: walk.find,
        findLast: walk.findLast,
        findAll: walk.findAll,

        fromPlainObject,
        toPlainObject,

        fork(extension) {
            const base = mix({}, config); // copy of config

            return createSyntax(
                typeof extension === 'function'
                    ? extension(base, Object.assign)
                    : mix(base, extension)
            );
        }
    };

    syntax.lexer = new Lexer({
        generic: true,
        units: config.units,
        types: config.types,
        atrules: config.atrules,
        properties: config.properties,
        node: config.node
    }, syntax);

    return syntax;
}
var createSyntax$1 = config => createSyntax(mix({}, config));

const require$3 = createRequire(import.meta.url);
const patch$1 = require$3('../data/patch.json');

const require$2 = createRequire(import.meta.url);
const mdnAtrules = require$2('mdn-data/css/at-rules.json');
const mdnProperties = require$2('mdn-data/css/properties.json');
const mdnSyntaxes = require$2('mdn-data/css/syntaxes.json');

const extendSyntax = /^\s*\|\s*/;

function preprocessAtrules(dict) {
    const result = Object.create(null);

    for (const atruleName in dict) {
        const atrule = dict[atruleName];
        let descriptors = null;

        if (atrule.descriptors) {
            descriptors = Object.create(null);

            for (const descriptor in atrule.descriptors) {
                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
            }
        }

        result[atruleName.substr(1)] = {
            prelude: atrule.syntax.trim().replace(/\{(.|\s)+\}/, '').match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
            descriptors
        };
    }

    return result;
}

function patchDictionary(dict, patchDict) {
    const result = {};

    // copy all syntaxes for an original dict
    for (const key in dict) {
        result[key] = dict[key].syntax || dict[key];
    }

    // apply a patch
    for (const key in patchDict) {
        if (key in dict) {
            if (patchDict[key].syntax) {
                result[key] = extendSyntax.test(patchDict[key].syntax)
                    ? result[key] + ' ' + patchDict[key].syntax.trim()
                    : patchDict[key].syntax;
            } else {
                delete result[key];
            }
        } else {
            if (patchDict[key].syntax) {
                result[key] = patchDict[key].syntax.replace(extendSyntax, '');
            }
        }
    }

    return result;
}

function patchAtrules(dict, patchDict) {
    const result = {};

    // copy all syntaxes for an original dict
    for (const key in dict) {
        const atrulePatch = patchDict[key] || {};

        result[key] = {
            prelude: key in patchDict && 'prelude' in atrulePatch
                ? atrulePatch.prelude
                : dict[key].prelude || null,
            descriptors: patchDictionary(dict[key].descriptors || {}, atrulePatch.descriptors || {})
        };
    }

    // apply a patch
    for (const key in patchDict) {
        if (!hasOwnProperty.call(dict, key)) {
            const atrulePatch = patchDict[key] || {};

            result[key] = {
                prelude: atrulePatch.prelude || null,
                descriptors: atrulePatch.descriptors && patchDictionary({}, atrulePatch.descriptors)
            };
        }
    }

    return result;
}

var definitions = {
    types: patchDictionary(mdnSyntaxes, patch$1.types),
    atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch$1.atrules),
    properties: patchDictionary(mdnProperties, patch$1.properties)
};

const PLUSSIGN$5 = 0x002B;    // U+002B PLUS SIGN (+)
const HYPHENMINUS$2 = 0x002D; // U+002D HYPHEN-MINUS (-)
const N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
const DISALLOW_SIGN = true;
const ALLOW_SIGN = false;

function checkInteger(offset, disallowSign) {
    let pos = this.tokenStart + offset;
    const code = this.charCodeAt(pos);

    if (code === PLUSSIGN$5 || code === HYPHENMINUS$2) {
        if (disallowSign) {
            this.error('Number sign is not allowed');
        }
        pos++;
    }

    for (; pos < this.tokenEnd; pos++) {
        if (!isDigit(this.charCodeAt(pos))) {
            this.error('Integer is expected', pos);
        }
    }
}

function checkTokenIsInteger(disallowSign) {
    return checkInteger.call(this, 0, disallowSign);
}

function expectCharCode(offset, code) {
    if (!this.cmpChar(this.tokenStart + offset, code)) {
        let msg = '';

        switch (code) {
            case N:
                msg = 'N is expected';
                break;
            case HYPHENMINUS$2:
                msg = 'HyphenMinus is expected';
                break;
        }

        this.error(msg, this.tokenStart + offset);
    }
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB() {
    let offset = 0;
    let sign = 0;
    let type = this.tokenType;

    while (type === WhiteSpace$1 || type === Comment$1) {
        type = this.lookupType(++offset);
    }

    if (type !== Number$2) {
        if (this.isDelim(PLUSSIGN$5, offset) ||
            this.isDelim(HYPHENMINUS$2, offset)) {
            sign = this.isDelim(PLUSSIGN$5, offset) ? PLUSSIGN$5 : HYPHENMINUS$2;

            do {
                type = this.lookupType(++offset);
            } while (type === WhiteSpace$1 || type === Comment$1);

            if (type !== Number$2) {
                this.skip(offset);
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
            }
        } else {
            return null;
        }
    }

    if (offset > 0) {
        this.skip(offset);
    }

    if (sign === 0) {
        type = this.charCodeAt(this.tokenStart);
        if (type !== PLUSSIGN$5 && type !== HYPHENMINUS$2) {
            this.error('Number sign is expected');
        }
    }

    checkTokenIsInteger.call(this, sign !== 0);
    return sign === HYPHENMINUS$2 ? '-' + this.consume(Number$2) : this.consume(Number$2);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
const name$N = 'AnPlusB';
const structure$L = {
    a: [String, null],
    b: [String, null]
};

function parse$W() {
    /* eslint-disable brace-style*/
    const start = this.tokenStart;
    let a = null;
    let b = null;

    // <integer>
    if (this.tokenType === Number$2) {
        checkTokenIsInteger.call(this, ALLOW_SIGN);
        b = this.consume(Number$2);
    }

    // -n
    // -n <signed-integer>
    // -n ['+' | '-'] <signless-integer>
    // -n- <signless-integer>
    // <dashndashdigit-ident>
    else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, HYPHENMINUS$2)) {
        a = '-1';

        expectCharCode.call(this, 1, N);

        switch (this.tokenEnd - this.tokenStart) {
            // -n
            // -n <signed-integer>
            // -n ['+' | '-'] <signless-integer>
            case 2:
                this.next();
                b = consumeB.call(this);
                break;

            // -n- <signless-integer>
            case 3:
                expectCharCode.call(this, 2, HYPHENMINUS$2);

                this.next();
                this.skipSC();

                checkTokenIsInteger.call(this, DISALLOW_SIGN);

                b = '-' + this.consume(Number$2);
                break;

            // <dashndashdigit-ident>
            default:
                expectCharCode.call(this, 2, HYPHENMINUS$2);
                checkInteger.call(this, 3, DISALLOW_SIGN);
                this.next();

                b = this.substrToCursor(start + 2);
        }
    }

    // '+'? n
    // '+'? n <signed-integer>
    // '+'? n ['+' | '-'] <signless-integer>
    // '+'? n- <signless-integer>
    // '+'? <ndashdigit-ident>
    else if (this.tokenType === Ident || (this.isDelim(PLUSSIGN$5) && this.lookupType(1) === Ident)) {
        let sign = 0;
        a = '1';

        // just ignore a plus
        if (this.isDelim(PLUSSIGN$5)) {
            sign = 1;
            this.next();
        }

        expectCharCode.call(this, 0, N);

        switch (this.tokenEnd - this.tokenStart) {
            // '+'? n
            // '+'? n <signed-integer>
            // '+'? n ['+' | '-'] <signless-integer>
            case 1:
                this.next();
                b = consumeB.call(this);
                break;

            // '+'? n- <signless-integer>
            case 2:
                expectCharCode.call(this, 1, HYPHENMINUS$2);

                this.next();
                this.skipSC();

                checkTokenIsInteger.call(this, DISALLOW_SIGN);

                b = '-' + this.consume(Number$2);
                break;

            // '+'? <ndashdigit-ident>
            default:
                expectCharCode.call(this, 1, HYPHENMINUS$2);
                checkInteger.call(this, 2, DISALLOW_SIGN);
                this.next();

                b = this.substrToCursor(start + sign + 1);
        }
    }

    // <ndashdigit-dimension>
    // <ndash-dimension> <signless-integer>
    // <n-dimension>
    // <n-dimension> <signed-integer>
    // <n-dimension> ['+' | '-'] <signless-integer>
    else if (this.tokenType === Dimension$1) {
        const code = this.charCodeAt(this.tokenStart);
        const sign = code === PLUSSIGN$5 || code === HYPHENMINUS$2;
        let i = this.tokenStart + sign;

        for (; i < this.tokenEnd; i++) {
            if (!isDigit(this.charCodeAt(i))) {
                break;
            }
        }

        if (i === this.tokenStart + sign) {
            this.error('Integer is expected', this.tokenStart + sign);
        }

        expectCharCode.call(this, i - this.tokenStart, N);
        a = this.substring(start, i);

        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        if (i + 1 === this.tokenEnd) {
            this.next();
            b = consumeB.call(this);
        } else {
            expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS$2);

            // <ndash-dimension> <signless-integer>
            if (i + 2 === this.tokenEnd) {
                this.next();
                this.skipSC();
                checkTokenIsInteger.call(this, DISALLOW_SIGN);
                b = '-' + this.consume(Number$2);
            }
            // <ndashdigit-dimension>
            else {
                checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);
                this.next();
                b = this.substrToCursor(i + 1);
            }
        }
    } else {
        this.error();
    }

    if (a !== null && a.charCodeAt(0) === PLUSSIGN$5) {
        a = a.substr(1);
    }

    if (b !== null && b.charCodeAt(0) === PLUSSIGN$5) {
        b = b.substr(1);
    }

    return {
        type: 'AnPlusB',
        loc: this.getLocation(start, this.tokenStart),
        a,
        b
    };
}

function generate$M(node) {
    if (node.a) {
        const a =
            node.a === '+1' && 'n' ||
            node.a ===  '1' && 'n' ||
            node.a === '-1' && '-n' ||
            node.a + 'n';

        if (node.b) {
            const b = node.b[0] === '-' || node.b[0] === '+'
                ? node.b
                : '+' + node.b;
            this.tokenize(a + b);
        } else {
            this.tokenize(a);
        }
    } else {
        this.tokenize(node.b);
    }
}

var AnPlusB = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$M,
  name: name$N,
  parse: parse$W,
  structure: structure$L
});

function consumeRaw$5(startToken) {
    return this.Raw(startToken, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
}

function isDeclarationBlockAtrule() {
    for (let offset = 1, type; type = this.lookupType(offset); offset++) {
        if (type === RightCurlyBracket) {
            return true;
        }

        if (type === LeftCurlyBracket ||
            type === AtKeyword) {
            return false;
        }
    }

    return false;
}


const name$M = 'Atrule';
const walkContext$9 = 'atrule';
const structure$K = {
    name: String,
    prelude: ['AtrulePrelude', 'Raw', null],
    block: ['Block', null]
};

function parse$V(isDeclaration = false) {
    const start = this.tokenStart;
    let name;
    let nameLowerCase;
    let prelude = null;
    let block = null;

    this.eat(AtKeyword);

    name = this.substrToCursor(start + 1);
    nameLowerCase = name.toLowerCase();
    this.skipSC();

    // parse prelude
    if (this.eof === false &&
        this.tokenType !== LeftCurlyBracket &&
        this.tokenType !== Semicolon) {
        if (this.parseAtrulePrelude) {
            prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name, isDeclaration), consumeRaw$5);
        } else {
            prelude = consumeRaw$5.call(this, this.tokenIndex);
        }

        this.skipSC();
    }

    switch (this.tokenType) {
        case Semicolon:
            this.next();
            break;

        case LeftCurlyBracket:
            if (hasOwnProperty.call(this.atrule, nameLowerCase) &&
                typeof this.atrule[nameLowerCase].block === 'function') {
                block = this.atrule[nameLowerCase].block.call(this, isDeclaration);
            } else {
                // TODO: should consume block content as Raw?
                block = this.Block(isDeclarationBlockAtrule.call(this));
            }

            break;
    }

    return {
        type: 'Atrule',
        loc: this.getLocation(start, this.tokenStart),
        name,
        prelude,
        block
    };
}

function generate$L(node) {
    this.token(AtKeyword, '@' + node.name);

    if (node.prelude !== null) {
        this.node(node.prelude);
    }

    if (node.block) {
        this.node(node.block);
    } else {
        this.token(Semicolon, ';');
    }
}

var Atrule = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$L,
  name: name$M,
  parse: parse$V,
  structure: structure$K,
  walkContext: walkContext$9
});

const name$L = 'AtrulePrelude';
const walkContext$8 = 'atrulePrelude';
const structure$J = {
    children: [[]]
};

function parse$U(name) {
    let children = null;

    if (name !== null) {
        name = name.toLowerCase();
    }

    this.skipSC();

    if (hasOwnProperty.call(this.atrule, name) &&
        typeof this.atrule[name].prelude === 'function') {
        // custom consumer
        children = this.atrule[name].prelude.call(this);
    } else {
        // default consumer
        children = this.readSequence(this.scope.AtrulePrelude);
    }

    this.skipSC();

    if (this.eof !== true &&
        this.tokenType !== LeftCurlyBracket &&
        this.tokenType !== Semicolon) {
        this.error('Semicolon or block is expected');
    }

    return {
        type: 'AtrulePrelude',
        loc: this.getLocationFromList(children),
        children
    };
}

function generate$K(node) {
    this.children(node);
}

var AtrulePrelude = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$K,
  name: name$L,
  parse: parse$U,
  structure: structure$J,
  walkContext: walkContext$8
});

const DOLLARSIGN$1 = 0x0024;       // U+0024 DOLLAR SIGN ($)
const ASTERISK$5 = 0x002A;         // U+002A ASTERISK (*)
const EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
const CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
const VERTICALLINE$2 = 0x007C;     // U+007C VERTICAL LINE (|)
const TILDE$2 = 0x007E;            // U+007E TILDE (~)

function getAttributeName() {
    if (this.eof) {
        this.error('Unexpected end of input');
    }

    const start = this.tokenStart;
    let expectIdent = false;

    if (this.isDelim(ASTERISK$5)) {
        expectIdent = true;
        this.next();
    } else if (!this.isDelim(VERTICALLINE$2)) {
        this.eat(Ident);
    }

    if (this.isDelim(VERTICALLINE$2)) {
        if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
            this.next();
            this.eat(Ident);
        } else if (expectIdent) {
            this.error('Identifier is expected', this.tokenEnd);
        }
    } else if (expectIdent) {
        this.error('Vertical line is expected');
    }

    return {
        type: 'Identifier',
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start)
    };
}

function getOperator() {
    const start = this.tokenStart;
    const code = this.charCodeAt(start);

    if (code !== EQUALSSIGN &&        // =
        code !== TILDE$2 &&             // ~=
        code !== CIRCUMFLEXACCENT &&  // ^=
        code !== DOLLARSIGN$1 &&        // $=
        code !== ASTERISK$5 &&          // *=
        code !== VERTICALLINE$2         // |=
    ) {
        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
    }

    this.next();

    if (code !== EQUALSSIGN) {
        if (!this.isDelim(EQUALSSIGN)) {
            this.error('Equal sign is expected');
        }

        this.next();
    }

    return this.substrToCursor(start);
}

// '[' <wq-name> ']'
// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
const name$K = 'AttributeSelector';
const structure$I = {
    name: 'Identifier',
    matcher: [String, null],
    value: ['String', 'Identifier', null],
    flags: [String, null]
};

function parse$T() {
    const start = this.tokenStart;
    let name;
    let matcher = null;
    let value = null;
    let flags = null;

    this.eat(LeftSquareBracket);
    this.skipSC();

    name = getAttributeName.call(this);
    this.skipSC();

    if (this.tokenType !== RightSquareBracket) {
        // avoid case `[name i]`
        if (this.tokenType !== Ident) {
            matcher = getOperator.call(this);

            this.skipSC();

            value = this.tokenType === String$2
                ? this.String()
                : this.Identifier();

            this.skipSC();
        }

        // attribute flags
        if (this.tokenType === Ident) {
            flags = this.consume(Ident);

            this.skipSC();
        }
    }

    this.eat(RightSquareBracket);

    return {
        type: 'AttributeSelector',
        loc: this.getLocation(start, this.tokenStart),
        name,
        matcher,
        value,
        flags
    };
}

function generate$J(node) {
    this.token(Delim, '[');
    this.node(node.name);

    if (node.matcher !== null) {
        this.tokenize(node.matcher);
        this.node(node.value);
    }

    if (node.flags !== null) {
        this.token(Ident, node.flags);
    }

    this.token(Delim, ']');
}

var AttributeSelector = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$J,
  name: name$K,
  parse: parse$T,
  structure: structure$I
});

const AMPERSAND$4 = 0x0026;       // U+0026 AMPERSAND (&)

function consumeRaw$4(startToken) {
    return this.Raw(startToken, null, true);
}
function consumeRule() {
    return this.parseWithFallback(this.Rule, consumeRaw$4);
}
function consumeRawDeclaration(startToken) {
    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
}
function consumeDeclaration() {
    if (this.tokenType === Semicolon) {
        return consumeRawDeclaration.call(this, this.tokenIndex);
    }

    const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

    if (this.tokenType === Semicolon) {
        this.next();
    }

    return node;
}

const name$J = 'Block';
const walkContext$7 = 'block';
const structure$H = {
    children: [[
        'Atrule',
        'Rule',
        'Declaration'
    ]]
};

function parse$S(isStyleBlock) {
    const consumer = isStyleBlock ? consumeDeclaration : consumeRule;
    const start = this.tokenStart;
    let children = this.createList();

    this.eat(LeftCurlyBracket);

    scan:
    while (!this.eof) {
        switch (this.tokenType) {
            case RightCurlyBracket:
                break scan;

            case WhiteSpace$1:
            case Comment$1:
                this.next();
                break;

            case AtKeyword:
                children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw$4));
                break;

            default:
                if (isStyleBlock && this.isDelim(AMPERSAND$4))  {
                    children.push(consumeRule.call(this));
                } else {
                    children.push(consumer.call(this));
                }
        }
    }

    if (!this.eof) {
        this.eat(RightCurlyBracket);
    }

    return {
        type: 'Block',
        loc: this.getLocation(start, this.tokenStart),
        children
    };
}

function generate$I(node) {
    this.token(LeftCurlyBracket, '{');
    this.children(node, prev => {
        if (prev.type === 'Declaration') {
            this.token(Semicolon, ';');
        }
    });
    this.token(RightCurlyBracket, '}');
}

var Block = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$I,
  name: name$J,
  parse: parse$S,
  structure: structure$H,
  walkContext: walkContext$7
});

const name$I = 'Brackets';
const structure$G = {
    children: [[]]
};

function parse$R(readSequence, recognizer) {
    const start = this.tokenStart;
    let children = null;

    this.eat(LeftSquareBracket);

    children = readSequence.call(this, recognizer);

    if (!this.eof) {
        this.eat(RightSquareBracket);
    }

    return {
        type: 'Brackets',
        loc: this.getLocation(start, this.tokenStart),
        children
    };
}

function generate$H(node) {
    this.token(Delim, '[');
    this.children(node);
    this.token(Delim, ']');
}

var Brackets = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$H,
  name: name$I,
  parse: parse$R,
  structure: structure$G
});

const name$H = 'CDC';
const structure$F = [];

function parse$Q() {
    const start = this.tokenStart;

    this.eat(CDC$1); // -->

    return {
        type: 'CDC',
        loc: this.getLocation(start, this.tokenStart)
    };
}

function generate$G() {
    this.token(CDC$1, '-->');
}

var CDC = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$G,
  name: name$H,
  parse: parse$Q,
  structure: structure$F
});

const name$G = 'CDO';
const structure$E = [];

function parse$P() {
    const start = this.tokenStart;

    this.eat(CDO$1); // <!--

    return {
        type: 'CDO',
        loc: this.getLocation(start, this.tokenStart)
    };
}

function generate$F() {
    this.token(CDO$1, '<!--');
}

var CDO = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$F,
  name: name$G,
  parse: parse$P,
  structure: structure$E
});

const FULLSTOP$2 = 0x002E; // U+002E FULL STOP (.)

// '.' ident
const name$F = 'ClassSelector';
const structure$D = {
    name: String
};

function parse$O() {
    this.eatDelim(FULLSTOP$2);

    return {
        type: 'ClassSelector',
        loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
        name: this.consume(Ident)
    };
}

function generate$E(node) {
    this.token(Delim, '.');
    this.token(Ident, node.name);
}

var ClassSelector = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$E,
  name: name$F,
  parse: parse$O,
  structure: structure$D
});

const PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
const SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
const GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
const TILDE$1 = 0x007E;           // U+007E TILDE (~)

const name$E = 'Combinator';
const structure$C = {
    name: String
};

// + | > | ~ | /deep/
function parse$N() {
    const start = this.tokenStart;
    let name;

    switch (this.tokenType) {
        case WhiteSpace$1:
            name = ' ';
            break;

        case Delim:
            switch (this.charCodeAt(this.tokenStart)) {
                case GREATERTHANSIGN$1:
                case PLUSSIGN$4:
                case TILDE$1:
                    this.next();
                    break;

                case SOLIDUS$5:
                    this.next();
                    this.eatIdent('deep');
                    this.eatDelim(SOLIDUS$5);
                    break;

                default:
                    this.error('Combinator is expected');
            }

            name = this.substrToCursor(start);
            break;
    }

    return {
        type: 'Combinator',
        loc: this.getLocation(start, this.tokenStart),
        name
    };
}

function generate$D(node) {
    this.tokenize(node.name);
}

var Combinator = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$D,
  name: name$E,
  parse: parse$N,
  structure: structure$C
});

const ASTERISK$4 = 0x002A;        // U+002A ASTERISK (*)
const SOLIDUS$4 = 0x002F;         // U+002F SOLIDUS (/)


const name$D = 'Comment';
const structure$B = {
    value: String
};

function parse$M() {
    const start = this.tokenStart;
    let end = this.tokenEnd;

    this.eat(Comment$1);

    if ((end - start + 2) >= 2 &&
        this.charCodeAt(end - 2) === ASTERISK$4 &&
        this.charCodeAt(end - 1) === SOLIDUS$4) {
        end -= 2;
    }

    return {
        type: 'Comment',
        loc: this.getLocation(start, this.tokenStart),
        value: this.substring(start + 2, end)
    };
}

function generate$C(node) {
    this.token(Comment$1, '/*' + node.value + '*/');
}

var Comment = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$C,
  name: name$D,
  parse: parse$M,
  structure: structure$B
});

const EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)
const NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
const DOLLARSIGN = 0x0024;      // U+0024 DOLLAR SIGN ($)
const AMPERSAND$3 = 0x0026;       // U+0026 AMPERSAND (&)
const ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
const PLUSSIGN$3 = 0x002B;        // U+002B PLUS SIGN (+)
const SOLIDUS$3 = 0x002F;         // U+002F SOLIDUS (/)

function consumeValueRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, true);
}

function consumeCustomPropertyRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, false);
}

function consumeValue() {
    const startValueToken = this.tokenIndex;
    const value = this.Value();

    if (value.type !== 'Raw' &&
        this.eof === false &&
        this.tokenType !== Semicolon &&
        this.isDelim(EXCLAMATIONMARK$1) === false &&
        this.isBalanceEdge(startValueToken) === false) {
        this.error();
    }

    return value;
}

const name$C = 'Declaration';
const walkContext$6 = 'declaration';
const structure$A = {
    important: [Boolean, String],
    property: String,
    value: ['Value', 'Raw']
};

function parse$L() {
    const start = this.tokenStart;
    const startToken = this.tokenIndex;
    const property = readProperty.call(this);
    const customProperty = isCustomProperty(property);
    const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
    const consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
    let important = false;
    let value;

    this.skipSC();
    this.eat(Colon$1);

    const valueStart = this.tokenIndex;

    if (!customProperty) {
        this.skipSC();
    }

    if (parseValue) {
        value = this.parseWithFallback(consumeValue, consumeRaw);
    } else {
        value = consumeRaw.call(this, this.tokenIndex);
    }

    if (customProperty && value.type === 'Value' && value.children.isEmpty) {
        for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {
            if (this.lookupType(offset) === WhiteSpace$1) {
                value.children.appendData({
                    type: 'WhiteSpace',
                    loc: null,
                    value: ' '
                });
                break;
            }
        }
    }

    if (this.isDelim(EXCLAMATIONMARK$1)) {
        important = getImportant.call(this);
        this.skipSC();
    }

    // Do not include semicolon to range per spec
    // https://drafts.csswg.org/css-syntax/#declaration-diagram

    if (this.eof === false &&
        this.tokenType !== Semicolon &&
        this.isBalanceEdge(startToken) === false) {
        this.error();
    }

    return {
        type: 'Declaration',
        loc: this.getLocation(start, this.tokenStart),
        important,
        property,
        value
    };
}

function generate$B(node) {
    this.token(Ident, node.property);
    this.token(Colon$1, ':');
    this.node(node.value);

    if (node.important) {
        this.token(Delim, '!');
        this.token(Ident, node.important === true ? 'important' : node.important);
    }
}

function readProperty() {
    const start = this.tokenStart;

    // hacks
    if (this.tokenType === Delim) {
        switch (this.charCodeAt(this.tokenStart)) {
            case ASTERISK$3:
            case DOLLARSIGN:
            case PLUSSIGN$3:
            case NUMBERSIGN$2:
            case AMPERSAND$3:
                this.next();
                break;

            // TODO: not sure we should support this hack
            case SOLIDUS$3:
                this.next();
                if (this.isDelim(SOLIDUS$3)) {
                    this.next();
                }
                break;
        }
    }

    if (this.tokenType === Hash$1) {
        this.eat(Hash$1);
    } else {
        this.eat(Ident);
    }

    return this.substrToCursor(start);
}

// ! ws* important
function getImportant() {
    this.eat(Delim);
    this.skipSC();

    const important = this.consume(Ident);

    // store original value in case it differ from `important`
    // for better original source restoring and hacks like `!ie` support
    return important === 'important' ? true : important;
}

var Declaration = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$B,
  name: name$C,
  parse: parse$L,
  structure: structure$A,
  walkContext: walkContext$6
});

const AMPERSAND$2 = 0x0026;       // U+0026 AMPERSAND (&)

function consumeRaw$3(startToken) {
    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
}

const name$B = 'DeclarationList';
const structure$z = {
    children: [[
        'Declaration',
        'Atrule',
        'Rule'
    ]]
};

function parse$K() {
    const children = this.createList();

    while (!this.eof) {
        switch (this.tokenType) {
            case WhiteSpace$1:
            case Comment$1:
            case Semicolon:
                this.next();
                break;

            case AtKeyword:
                children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw$3));
                break;

            default:
                if (this.isDelim(AMPERSAND$2))  {
                    children.push(this.parseWithFallback(this.Rule, consumeRaw$3));
                } else {
                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$3));
                }
        }
    }

    return {
        type: 'DeclarationList',
        loc: this.getLocationFromList(children),
        children
    };
}

function generate$A(node) {
    this.children(node, prev => {
        if (prev.type === 'Declaration') {
            this.token(Semicolon, ';');
        }
    });
}

var DeclarationList = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$A,
  name: name$B,
  parse: parse$K,
  structure: structure$z
});

const name$A = 'Dimension';
const structure$y = {
    value: String,
    unit: String
};

function parse$J() {
    const start = this.tokenStart;
    const value = this.consumeNumber(Dimension$1);

    return {
        type: 'Dimension',
        loc: this.getLocation(start, this.tokenStart),
        value,
        unit: this.substring(start + value.length, this.tokenStart)
    };
}

function generate$z(node) {
    this.token(Dimension$1, node.value + node.unit);
}

var Dimension = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$z,
  name: name$A,
  parse: parse$J,
  structure: structure$y
});

const name$z = 'Function';
const walkContext$5 = 'function';
const structure$x = {
    name: String,
    children: [[]]
};

// <function-token> <sequence> )
function parse$I(readSequence, recognizer) {
    const start = this.tokenStart;
    const name = this.consumeFunctionName();
    const nameLowerCase = name.toLowerCase();
    let children;

    children = recognizer.hasOwnProperty(nameLowerCase)
        ? recognizer[nameLowerCase].call(this, recognizer)
        : readSequence.call(this, recognizer);

    if (!this.eof) {
        this.eat(RightParenthesis);
    }

    return {
        type: 'Function',
        loc: this.getLocation(start, this.tokenStart),
        name,
        children
    };
}

function generate$y(node) {
    this.token(Function$2, node.name + '(');
    this.children(node);
    this.token(RightParenthesis, ')');
}

var Function$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$y,
  name: name$z,
  parse: parse$I,
  structure: structure$x,
  walkContext: walkContext$5
});

// '#' ident
const xxx = 'XXX';
const name$y = 'Hash';
const structure$w = {
    value: String
};
function parse$H() {
    const start = this.tokenStart;

    this.eat(Hash$1);

    return {
        type: 'Hash',
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start + 1)
    };
}
function generate$x(node) {
    this.token(Hash$1, '#' + node.value);
}

var Hash = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$x,
  name: name$y,
  parse: parse$H,
  structure: structure$w,
  xxx: xxx
});

const name$x = 'Identifier';
const structure$v = {
    name: String
};

function parse$G() {
    return {
        type: 'Identifier',
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        name: this.consume(Ident)
    };
}

function generate$w(node) {
    this.token(Ident, node.name);
}

var Identifier = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$w,
  name: name$x,
  parse: parse$G,
  structure: structure$v
});

const name$w = 'IdSelector';
const structure$u = {
    name: String
};

function parse$F() {
    const start = this.tokenStart;

    // TODO: check value is an ident
    this.eat(Hash$1);

    return {
        type: 'IdSelector',
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start + 1)
    };
}

function generate$v(node) {
    // Using Delim instead of Hash is a hack to avoid for a whitespace between ident and id-selector
    // in safe mode (e.g. "a#id"), because IE11 doesn't allow a sequence <ident-token> <hash-token>
    // without a whitespace in values (e.g. "1px solid#000")
    this.token(Delim, '#' + node.name);
}

var IdSelector = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$v,
  name: name$w,
  parse: parse$F,
  structure: structure$u
});

const name$v = 'MediaFeature';
const structure$t = {
    name: String,
    value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
};

function parse$E() {
    const start = this.tokenStart;
    let name;
    let value = null;

    this.eat(LeftParenthesis);
    this.skipSC();

    name = this.consume(Ident);
    this.skipSC();

    if (this.tokenType !== RightParenthesis) {
        this.eat(Colon$1);
        this.skipSC();

        switch (this.tokenType) {
            case Number$2:
                if (this.lookupNonWSType(1) === Delim) {
                    value = this.Ratio();
                } else {
                    value = this.Number();
                }

                break;

            case Dimension$1:
                value = this.Dimension();
                break;

            case Ident:
                value = this.Identifier();
                break;

            default:
                this.error('Number, dimension, ratio or identifier is expected');
        }

        this.skipSC();
    }

    this.eat(RightParenthesis);

    return {
        type: 'MediaFeature',
        loc: this.getLocation(start, this.tokenStart),
        name,
        value
    };
}

function generate$u(node) {
    this.token(LeftParenthesis, '(');
    this.token(Ident, node.name);

    if (node.value !== null) {
        this.token(Colon$1, ':');
        this.node(node.value);
    }

    this.token(RightParenthesis, ')');
}

var MediaFeature = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$u,
  name: name$v,
  parse: parse$E,
  structure: structure$t
});

const name$u = 'MediaQuery';
const structure$s = {
    children: [[
        'Identifier',
        'MediaFeature',
        'WhiteSpace'
    ]]
};

function parse$D() {
    const children = this.createList();
    let child = null;

    this.skipSC();

    scan:
    while (!this.eof) {
        switch (this.tokenType) {
            case Comment$1:
            case WhiteSpace$1:
                this.next();
                continue;

            case Ident:
                child = this.Identifier();
                break;

            case LeftParenthesis:
                child = this.MediaFeature();
                break;

            default:
                break scan;
        }

        children.push(child);
    }

    if (child === null) {
        this.error('Identifier or parenthesis is expected');
    }

    return {
        type: 'MediaQuery',
        loc: this.getLocationFromList(children),
        children
    };
}

function generate$t(node) {
    this.children(node);
}

var MediaQuery = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$t,
  name: name$u,
  parse: parse$D,
  structure: structure$s
});

const name$t = 'MediaQueryList';
const structure$r = {
    children: [[
        'MediaQuery'
    ]]
};

function parse$C() {
    const children = this.createList();

    this.skipSC();

    while (!this.eof) {
        children.push(this.MediaQuery());

        if (this.tokenType !== Comma) {
            break;
        }

        this.next();
    }

    return {
        type: 'MediaQueryList',
        loc: this.getLocationFromList(children),
        children
    };
}

function generate$s(node) {
    this.children(node, () => this.token(Comma, ','));
}

var MediaQueryList = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$s,
  name: name$t,
  parse: parse$C,
  structure: structure$r
});

const AMPERSAND$1 = 0x0026;       // U+0026 AMPERSAND (&)

const name$s = 'NestingSelector';
const structure$q = {
};

function parse$B() {
    const start = this.tokenStart;

    this.eatDelim(AMPERSAND$1);

    return {
        type: 'NestingSelector',
        loc: this.getLocation(start, this.tokenStart)
    };
}

function generate$r() {
    this.token(Delim, '&');
}

var NestingSelector = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$r,
  name: name$s,
  parse: parse$B,
  structure: structure$q
});

const name$r = 'Nth';
const structure$p = {
    nth: ['AnPlusB', 'Identifier'],
    selector: ['SelectorList', null]
};

function parse$A() {
    this.skipSC();

    const start = this.tokenStart;
    let end = start;
    let selector = null;
    let nth;

    if (this.lookupValue(0, 'odd') || this.lookupValue(0, 'even')) {
        nth = this.Identifier();
    } else {
        nth = this.AnPlusB();
    }

    end = this.tokenStart;
    this.skipSC();

    if (this.lookupValue(0, 'of')) {
        this.next();

        selector = this.SelectorList();
        end = this.tokenStart;
    }

    return {
        type: 'Nth',
        loc: this.getLocation(start, end),
        nth,
        selector
    };
}

function generate$q(node) {
    this.node(node.nth);
    if (node.selector !== null) {
        this.token(Ident, 'of');
        this.node(node.selector);
    }
}

var Nth = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$q,
  name: name$r,
  parse: parse$A,
  structure: structure$p
});

const name$q = 'Number';
const structure$o = {
    value: String
};

function parse$z() {
    return {
        type: 'Number',
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: this.consume(Number$2)
    };
}

function generate$p(node) {
    this.token(Number$2, node.value);
}

var Number$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$p,
  name: name$q,
  parse: parse$z,
  structure: structure$o
});

// '/' | '*' | ',' | ':' | '+' | '-'
const name$p = 'Operator';
const structure$n = {
    value: String
};

function parse$y() {
    const start = this.tokenStart;

    this.next();

    return {
        type: 'Operator',
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start)
    };
}

function generate$o(node) {
    this.tokenize(node.value);
}

var Operator = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$o,
  name: name$p,
  parse: parse$y,
  structure: structure$n
});

const name$o = 'Parentheses';
const structure$m = {
    children: [[]]
};

function parse$x(readSequence, recognizer) {
    const start = this.tokenStart;
    let children = null;

    this.eat(LeftParenthesis);

    children = readSequence.call(this, recognizer);

    if (!this.eof) {
        this.eat(RightParenthesis);
    }

    return {
        type: 'Parentheses',
        loc: this.getLocation(start, this.tokenStart),
        children
    };
}

function generate$n(node) {
    this.token(LeftParenthesis, '(');
    this.children(node);
    this.token(RightParenthesis, ')');
}

var Parentheses = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$n,
  name: name$o,
  parse: parse$x,
  structure: structure$m
});

const name$n = 'Percentage';
const structure$l = {
    value: String
};

function parse$w() {
    return {
        type: 'Percentage',
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: this.consumeNumber(Percentage$1)
    };
}

function generate$m(node) {
    this.token(Percentage$1, node.value + '%');
}

var Percentage = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$m,
  name: name$n,
  parse: parse$w,
  structure: structure$l
});

const name$m = 'PseudoClassSelector';
const walkContext$4 = 'function';
const structure$k = {
    name: String,
    children: [['Raw'], null]
};

// : [ <ident> | <function-token> <any-value>? ) ]
function parse$v() {
    const start = this.tokenStart;
    let children = null;
    let name;
    let nameLowerCase;

    this.eat(Colon$1);

    if (this.tokenType === Function$2) {
        name = this.consumeFunctionName();
        nameLowerCase = name.toLowerCase();

        if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
            this.skipSC();
            children = this.pseudo[nameLowerCase].call(this);
            this.skipSC();
        } else {
            children = this.createList();
            children.push(
                this.Raw(this.tokenIndex, null, false)
            );
        }

        this.eat(RightParenthesis);
    } else {
        name = this.consume(Ident);
    }

    return {
        type: 'PseudoClassSelector',
        loc: this.getLocation(start, this.tokenStart),
        name,
        children
    };
}

function generate$l(node) {
    this.token(Colon$1, ':');

    if (node.children === null) {
        this.token(Ident, node.name);
    } else {
        this.token(Function$2, node.name + '(');
        this.children(node);
        this.token(RightParenthesis, ')');
    }
}

var PseudoClassSelector = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$l,
  name: name$m,
  parse: parse$v,
  structure: structure$k,
  walkContext: walkContext$4
});

const name$l = 'PseudoElementSelector';
const walkContext$3 = 'function';
const structure$j = {
    name: String,
    children: [['Raw'], null]
};

// :: [ <ident> | <function-token> <any-value>? ) ]
function parse$u() {
    const start = this.tokenStart;
    let children = null;
    let name;
    let nameLowerCase;

    this.eat(Colon$1);
    this.eat(Colon$1);

    if (this.tokenType === Function$2) {
        name = this.consumeFunctionName();
        nameLowerCase = name.toLowerCase();

        if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
            this.skipSC();
            children = this.pseudo[nameLowerCase].call(this);
            this.skipSC();
        } else {
            children = this.createList();
            children.push(
                this.Raw(this.tokenIndex, null, false)
            );
        }

        this.eat(RightParenthesis);
    } else {
        name = this.consume(Ident);
    }

    return {
        type: 'PseudoElementSelector',
        loc: this.getLocation(start, this.tokenStart),
        name,
        children
    };
}

function generate$k(node) {
    this.token(Colon$1, ':');
    this.token(Colon$1, ':');

    if (node.children === null) {
        this.token(Ident, node.name);
    } else {
        this.token(Function$2, node.name + '(');
        this.children(node);
        this.token(RightParenthesis, ')');
    }
}

var PseudoElementSelector = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$k,
  name: name$l,
  parse: parse$u,
  structure: structure$j,
  walkContext: walkContext$3
});

const SOLIDUS$2 = 0x002F;  // U+002F SOLIDUS (/)
const FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

// Terms of <ratio> should be a positive numbers (not zero or negative)
// (see https://drafts.csswg.org/mediaqueries-3/#values)
// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
// and this is using by various sites. Therefore we relax checking on parse
// to test a term is unsigned number without an exponent part.
// Additional checking may be applied on lexer validation.
function consumeNumber() {
    this.skipSC();

    const value = this.consume(Number$2);

    for (let i = 0; i < value.length; i++) {
        const code = value.charCodeAt(i);
        if (!isDigit(code) && code !== FULLSTOP$1) {
            this.error('Unsigned number is expected', this.tokenStart - value.length + i);
        }
    }

    if (Number(value) === 0) {
        this.error('Zero number is not allowed', this.tokenStart - value.length);
    }

    return value;
}

const name$k = 'Ratio';
const structure$i = {
    left: String,
    right: String
};

// <positive-integer> S* '/' S* <positive-integer>
function parse$t() {
    const start = this.tokenStart;
    const left = consumeNumber.call(this);
    let right;

    this.skipSC();
    this.eatDelim(SOLIDUS$2);
    right = consumeNumber.call(this);

    return {
        type: 'Ratio',
        loc: this.getLocation(start, this.tokenStart),
        left,
        right
    };
}

function generate$j(node) {
    this.token(Number$2, node.left);
    this.token(Delim, '/');
    this.token(Number$2, node.right);
}

var Ratio = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$j,
  name: name$k,
  parse: parse$t,
  structure: structure$i
});

function getOffsetExcludeWS() {
    if (this.tokenIndex > 0) {
        if (this.lookupType(-1) === WhiteSpace$1) {
            return this.tokenIndex > 1
                ? this.getTokenStart(this.tokenIndex - 1)
                : this.firstCharOffset;
        }
    }

    return this.tokenStart;
}

const name$j = 'Raw';
const structure$h = {
    value: String
};

function parse$s(startToken, consumeUntil, excludeWhiteSpace) {
    const startOffset = this.getTokenStart(startToken);
    let endOffset;

    this.skipUntilBalanced(startToken, consumeUntil || this.consumeUntilBalanceEnd);

    if (excludeWhiteSpace && this.tokenStart > startOffset) {
        endOffset = getOffsetExcludeWS.call(this);
    } else {
        endOffset = this.tokenStart;
    }

    return {
        type: 'Raw',
        loc: this.getLocation(startOffset, endOffset),
        value: this.substring(startOffset, endOffset)
    };
}

function generate$i(node) {
    this.tokenize(node.value);
}

var Raw = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$i,
  name: name$j,
  parse: parse$s,
  structure: structure$h
});

function consumeRaw$2(startToken) {
    return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
}

function consumePrelude() {
    const prelude = this.SelectorList();

    if (prelude.type !== 'Raw' &&
        this.eof === false &&
        this.tokenType !== LeftCurlyBracket) {
        this.error();
    }

    return prelude;
}

const name$i = 'Rule';
const walkContext$2 = 'rule';
const structure$g = {
    prelude: ['SelectorList', 'Raw'],
    block: ['Block']
};

function parse$r() {
    const startToken = this.tokenIndex;
    const startOffset = this.tokenStart;
    let prelude;
    let block;

    if (this.parseRulePrelude) {
        prelude = this.parseWithFallback(consumePrelude, consumeRaw$2);
    } else {
        prelude = consumeRaw$2.call(this, startToken);
    }

    block = this.Block(true);

    return {
        type: 'Rule',
        loc: this.getLocation(startOffset, this.tokenStart),
        prelude,
        block
    };
}
function generate$h(node) {
    this.node(node.prelude);
    this.node(node.block);
}

var Rule = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$h,
  name: name$i,
  parse: parse$r,
  structure: structure$g,
  walkContext: walkContext$2
});

const name$h = 'Selector';
const structure$f = {
    children: [[
        'TypeSelector',
        'IdSelector',
        'ClassSelector',
        'AttributeSelector',
        'PseudoClassSelector',
        'PseudoElementSelector',
        'Combinator',
        'WhiteSpace'
    ]]
};

function parse$q() {
    const children = this.readSequence(this.scope.Selector);

    // nothing were consumed
    if (this.getFirstListNode(children) === null) {
        this.error('Selector is expected');
    }

    return {
        type: 'Selector',
        loc: this.getLocationFromList(children),
        children
    };
}

function generate$g(node) {
    this.children(node);
}

var Selector = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$g,
  name: name$h,
  parse: parse$q,
  structure: structure$f
});

const name$g = 'SelectorList';
const walkContext$1 = 'selector';
const structure$e = {
    children: [[
        'Selector',
        'Raw'
    ]]
};

function parse$p() {
    const children = this.createList();

    while (!this.eof) {
        children.push(this.Selector());

        if (this.tokenType === Comma) {
            this.next();
            continue;
        }

        break;
    }

    return {
        type: 'SelectorList',
        loc: this.getLocationFromList(children),
        children
    };
}

function generate$f(node) {
    this.children(node, () => this.token(Comma, ','));
}

var SelectorList = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$f,
  name: name$g,
  parse: parse$p,
  structure: structure$e,
  walkContext: walkContext$1
});

const REVERSE_SOLIDUS$1 = 0x005c; // U+005C REVERSE SOLIDUS (\)
const QUOTATION_MARK$1 = 0x0022;  // "
const APOSTROPHE$1 = 0x0027;      // '

function decode$2(str) {
    const len = str.length;
    const firstChar = str.charCodeAt(0);
    const start = firstChar === QUOTATION_MARK$1 || firstChar === APOSTROPHE$1 ? 1 : 0;
    const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
    let decoded = '';

    for (let i = start; i <= end; i++) {
        let code = str.charCodeAt(i);

        if (code === REVERSE_SOLIDUS$1) {
            // special case at the ending
            if (i === end) {
                // if the next input code point is EOF, do nothing
                // otherwise include last quote as escaped
                if (i !== len - 1) {
                    decoded = str.substr(i + 1);
                }
                break;
            }

            code = str.charCodeAt(++i);

            // consume escaped
            if (isValidEscape(REVERSE_SOLIDUS$1, code)) {
                const escapeStart = i - 1;
                const escapeEnd = consumeEscaped(str, escapeStart);

                i = escapeEnd - 1;
                decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
            } else {
                // \r\n
                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
                    i++;
                }
            }
        } else {
            decoded += str[i];
        }
    }

    return decoded;
}

// https://drafts.csswg.org/cssom/#serialize-a-string
// § 2.1. Common Serializing Idioms
function encode$3(str, apostrophe) {
    const quote = apostrophe ? '\'' : '"';
    const quoteCode = apostrophe ? APOSTROPHE$1 : QUOTATION_MARK$1;
    let encoded = '';
    let wsBeforeHexIsNeeded = false;

    for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);

        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
        if (code === 0x0000) {
            encoded += '\uFFFD';
            continue;
        }

        // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F,
        // the character escaped as code point.
        // Note: Do not compare with 0x0001 since 0x0000 is precessed before
        if (code <= 0x001f || code === 0x007F) {
            encoded += '\\' + code.toString(16);
            wsBeforeHexIsNeeded = true;
            continue;
        }

        // If the character is '"' (U+0022) or "\" (U+005C), the escaped character.
        if (code === quoteCode || code === REVERSE_SOLIDUS$1) {
            encoded += '\\' + str.charAt(i);
            wsBeforeHexIsNeeded = false;
        } else {
            if (wsBeforeHexIsNeeded && (isHexDigit(code) || isWhiteSpace(code))) {
                encoded += ' ';
            }

            // Otherwise, the character itself.
            encoded += str.charAt(i);
            wsBeforeHexIsNeeded = false;
        }
    }

    return quote + encoded + quote;
}

const name$f = 'String';
const structure$d = {
    value: String
};

function parse$o() {
    return {
        type: 'String',
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: decode$2(this.consume(String$2))
    };
}

function generate$e(node) {
    this.token(String$2, encode$3(node.value));
}

var String$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$e,
  name: name$f,
  parse: parse$o,
  structure: structure$d
});

const EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

function consumeRaw$1(startToken) {
    return this.Raw(startToken, null, false);
}

const name$e = 'StyleSheet';
const walkContext = 'stylesheet';
const structure$c = {
    children: [[
        'Comment',
        'CDO',
        'CDC',
        'Atrule',
        'Rule',
        'Raw'
    ]]
};

function parse$n() {
    const start = this.tokenStart;
    const children = this.createList();
    let child;

    while (!this.eof) {
        switch (this.tokenType) {
            case WhiteSpace$1:
                this.next();
                continue;

            case Comment$1:
                // ignore comments except exclamation comments (i.e. /*! .. */) on top level
                if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {
                    this.next();
                    continue;
                }

                child = this.Comment();
                break;

            case CDO$1: // <!--
                child = this.CDO();
                break;

            case CDC$1: // -->
                child = this.CDC();
                break;

            // CSS Syntax Module Level 3
            // §2.2 Error handling
            // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
            case AtKeyword:
                child = this.parseWithFallback(this.Atrule, consumeRaw$1);
                break;

            // Anything else starts a qualified rule ...
            default:
                child = this.parseWithFallback(this.Rule, consumeRaw$1);
        }

        children.push(child);
    }

    return {
        type: 'StyleSheet',
        loc: this.getLocation(start, this.tokenStart),
        children
    };
}

function generate$d(node) {
    this.children(node);
}

var StyleSheet = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$d,
  name: name$e,
  parse: parse$n,
  structure: structure$c,
  walkContext: walkContext
});

const ASTERISK$2 = 0x002A;     // U+002A ASTERISK (*)
const VERTICALLINE$1 = 0x007C; // U+007C VERTICAL LINE (|)

function eatIdentifierOrAsterisk() {
    if (this.tokenType !== Ident &&
        this.isDelim(ASTERISK$2) === false) {
        this.error('Identifier or asterisk is expected');
    }

    this.next();
}

const name$d = 'TypeSelector';
const structure$b = {
    name: String
};

// ident
// ident|ident
// ident|*
// *
// *|ident
// *|*
// |ident
// |*
function parse$m() {
    const start = this.tokenStart;

    if (this.isDelim(VERTICALLINE$1)) {
        this.next();
        eatIdentifierOrAsterisk.call(this);
    } else {
        eatIdentifierOrAsterisk.call(this);

        if (this.isDelim(VERTICALLINE$1)) {
            this.next();
            eatIdentifierOrAsterisk.call(this);
        }
    }

    return {
        type: 'TypeSelector',
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start)
    };
}

function generate$c(node) {
    this.tokenize(node.name);
}

var TypeSelector = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$c,
  name: name$d,
  parse: parse$m,
  structure: structure$b
});

const PLUSSIGN$2 = 0x002B;     // U+002B PLUS SIGN (+)
const HYPHENMINUS$1 = 0x002D;  // U+002D HYPHEN-MINUS (-)
const QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)

function eatHexSequence(offset, allowDash) {
    let len = 0;

    for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
        const code = this.charCodeAt(pos);

        if (code === HYPHENMINUS$1 && allowDash && len !== 0) {
            eatHexSequence.call(this, offset + len + 1, false);
            return -1;
        }

        if (!isHexDigit(code)) {
            this.error(
                allowDash && len !== 0
                    ? 'Hyphen minus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
                pos
            );
        }

        if (++len > 6) {
            this.error('Too many hex digits', pos);
        }    }

    this.next();
    return len;
}

function eatQuestionMarkSequence(max) {
    let count = 0;

    while (this.isDelim(QUESTIONMARK)) {
        if (++count > max) {
            this.error('Too many question marks');
        }

        this.next();
    }
}

function startsWith(code) {
    if (this.charCodeAt(this.tokenStart) !== code) {
        this.error((code === PLUSSIGN$2 ? 'Plus sign' : 'Hyphen minus') + ' is expected');
    }
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
function scanUnicodeRange() {
    let hexLength = 0;

    switch (this.tokenType) {
        case Number$2:
            // u <number-token> '?'*
            // u <number-token> <dimension-token>
            // u <number-token> <number-token>
            hexLength = eatHexSequence.call(this, 1, true);

            if (this.isDelim(QUESTIONMARK)) {
                eatQuestionMarkSequence.call(this, 6 - hexLength);
                break;
            }

            if (this.tokenType === Dimension$1 ||
                this.tokenType === Number$2) {
                startsWith.call(this, HYPHENMINUS$1);
                eatHexSequence.call(this, 1, false);
                break;
            }

            break;

        case Dimension$1:
            // u <dimension-token> '?'*
            hexLength = eatHexSequence.call(this, 1, true);

            if (hexLength > 0) {
                eatQuestionMarkSequence.call(this, 6 - hexLength);
            }

            break;

        default:
            // u '+' <ident-token> '?'*
            // u '+' '?'+
            this.eatDelim(PLUSSIGN$2);

            if (this.tokenType === Ident) {
                hexLength = eatHexSequence.call(this, 0, true);
                if (hexLength > 0) {
                    eatQuestionMarkSequence.call(this, 6 - hexLength);
                }
                break;
            }

            if (this.isDelim(QUESTIONMARK)) {
                this.next();
                eatQuestionMarkSequence.call(this, 5);
                break;
            }

            this.error('Hex digit or question mark is expected');
    }
}

const name$c = 'UnicodeRange';
const structure$a = {
    value: String
};

function parse$l() {
    const start = this.tokenStart;

    // U or u
    this.eatIdent('u');
    scanUnicodeRange.call(this);

    return {
        type: 'UnicodeRange',
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start)
    };
}

function generate$b(node) {
    this.tokenize(node.value);
}

var UnicodeRange = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$b,
  name: name$c,
  parse: parse$l,
  structure: structure$a
});

const SPACE$1 = 0x0020;            // U+0020 SPACE
const REVERSE_SOLIDUS = 0x005c;  // U+005C REVERSE SOLIDUS (\)
const QUOTATION_MARK = 0x0022;   // "
const APOSTROPHE = 0x0027;       // '
const LEFTPARENTHESIS = 0x0028;  // U+0028 LEFT PARENTHESIS (()
const RIGHTPARENTHESIS = 0x0029; // U+0029 RIGHT PARENTHESIS ())

function decode$1(str) {
    const len = str.length;
    let start = 4; // length of "url("
    let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
    let decoded = '';

    while (start < end && isWhiteSpace(str.charCodeAt(start))) {
        start++;
    }

    while (start < end && isWhiteSpace(str.charCodeAt(end))) {
        end--;
    }

    for (let i = start; i <= end; i++) {
        let code = str.charCodeAt(i);

        if (code === REVERSE_SOLIDUS) {
            // special case at the ending
            if (i === end) {
                // if the next input code point is EOF, do nothing
                // otherwise include last left parenthesis as escaped
                if (i !== len - 1) {
                    decoded = str.substr(i + 1);
                }
                break;
            }

            code = str.charCodeAt(++i);

            // consume escaped
            if (isValidEscape(REVERSE_SOLIDUS, code)) {
                const escapeStart = i - 1;
                const escapeEnd = consumeEscaped(str, escapeStart);

                i = escapeEnd - 1;
                decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
            } else {
                // \r\n
                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
                    i++;
                }
            }
        } else {
            decoded += str[i];
        }
    }

    return decoded;
}

function encode$2(str) {
    let encoded = '';
    let wsBeforeHexIsNeeded = false;

    for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);

        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
        if (code === 0x0000) {
            encoded += '\uFFFD';
            continue;
        }

        // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F,
        // the character escaped as code point.
        // Note: Do not compare with 0x0001 since 0x0000 is precessed before
        if (code <= 0x001f || code === 0x007F) {
            encoded += '\\' + code.toString(16);
            wsBeforeHexIsNeeded = true;
            continue;
        }

        if (code === SPACE$1 ||
            code === REVERSE_SOLIDUS ||
            code === QUOTATION_MARK ||
            code === APOSTROPHE ||
            code === LEFTPARENTHESIS ||
            code === RIGHTPARENTHESIS) {
            encoded += '\\' + str.charAt(i);
            wsBeforeHexIsNeeded = false;
        } else {
            if (wsBeforeHexIsNeeded && isHexDigit(code)) {
                encoded += ' ';
            }

            encoded += str.charAt(i);
            wsBeforeHexIsNeeded = false;
        }
    }

    return 'url(' + encoded + ')';
}

const name$b = 'Url';
const structure$9 = {
    value: String
};

// <url-token> | <function-token> <string> )
function parse$k() {
    const start = this.tokenStart;
    let value;

    switch (this.tokenType) {
        case Url$1:
            value = decode$1(this.consume(Url$1));
            break;

        case Function$2:
            if (!this.cmpStr(this.tokenStart, this.tokenEnd, 'url(')) {
                this.error('Function name must be `url`');
            }

            this.eat(Function$2);
            this.skipSC();
            value = decode$2(this.consume(String$2));
            this.skipSC();
            if (!this.eof) {
                this.eat(RightParenthesis);
            }
            break;

        default:
            this.error('Url or Function is expected');
    }

    return {
        type: 'Url',
        loc: this.getLocation(start, this.tokenStart),
        value
    };
}

function generate$a(node) {
    this.token(Url$1, encode$2(node.value));
}

var Url = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$a,
  name: name$b,
  parse: parse$k,
  structure: structure$9
});

const name$a = 'Value';
const structure$8 = {
    children: [[]]
};

function parse$j() {
    const start = this.tokenStart;
    const children = this.readSequence(this.scope.Value);

    return {
        type: 'Value',
        loc: this.getLocation(start, this.tokenStart),
        children
    };
}

function generate$9(node) {
    this.children(node);
}

var Value = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$9,
  name: name$a,
  parse: parse$j,
  structure: structure$8
});

const SPACE = Object.freeze({
    type: 'WhiteSpace',
    loc: null,
    value: ' '
});

const name$9 = 'WhiteSpace';
const structure$7 = {
    value: String
};

function parse$i() {
    this.eat(WhiteSpace$1);
    return SPACE;

    // return {
    //     type: 'WhiteSpace',
    //     loc: this.getLocation(this.tokenStart, this.tokenEnd),
    //     value: this.consume(WHITESPACE)
    // };
}

function generate$8(node) {
    this.token(WhiteSpace$1, node.value);
}

var WhiteSpace = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$8,
  name: name$9,
  parse: parse$i,
  structure: structure$7
});

var node$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AnPlusB: AnPlusB,
  Atrule: Atrule,
  AtrulePrelude: AtrulePrelude,
  AttributeSelector: AttributeSelector,
  Block: Block,
  Brackets: Brackets,
  CDC: CDC,
  CDO: CDO,
  ClassSelector: ClassSelector,
  Combinator: Combinator,
  Comment: Comment,
  Declaration: Declaration,
  DeclarationList: DeclarationList,
  Dimension: Dimension,
  Function: Function$1,
  Hash: Hash,
  IdSelector: IdSelector,
  Identifier: Identifier,
  MediaFeature: MediaFeature,
  MediaQuery: MediaQuery,
  MediaQueryList: MediaQueryList,
  NestingSelector: NestingSelector,
  Nth: Nth,
  Number: Number$1,
  Operator: Operator,
  Parentheses: Parentheses,
  Percentage: Percentage,
  PseudoClassSelector: PseudoClassSelector,
  PseudoElementSelector: PseudoElementSelector,
  Ratio: Ratio,
  Raw: Raw,
  Rule: Rule,
  Selector: Selector,
  SelectorList: SelectorList,
  String: String$1,
  StyleSheet: StyleSheet,
  TypeSelector: TypeSelector,
  UnicodeRange: UnicodeRange,
  Url: Url,
  Value: Value,
  WhiteSpace: WhiteSpace
});

var lexerConfig = {
    generic: true,
    ...definitions,
    node: node$2
};

const NUMBERSIGN$1 = 0x0023;  // U+0023 NUMBER SIGN (#)
const ASTERISK$1 = 0x002A;    // U+002A ASTERISK (*)
const PLUSSIGN$1 = 0x002B;    // U+002B PLUS SIGN (+)
const HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
const SOLIDUS$1 = 0x002F;     // U+002F SOLIDUS (/)
const U = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

function defaultRecognizer(context) {
    switch (this.tokenType) {
        case Hash$1:
            return this.Hash();

        case Comma:
            return this.Operator();

        case LeftParenthesis:
            return this.Parentheses(this.readSequence, context.recognizer);

        case LeftSquareBracket:
            return this.Brackets(this.readSequence, context.recognizer);

        case String$2:
            return this.String();

        case Dimension$1:
            return this.Dimension();

        case Percentage$1:
            return this.Percentage();

        case Number$2:
            return this.Number();

        case Function$2:
            return this.cmpStr(this.tokenStart, this.tokenEnd, 'url(')
                ? this.Url()
                : this.Function(this.readSequence, context.recognizer);

        case Url$1:
            return this.Url();

        case Ident:
            // check for unicode range, it should start with u+ or U+
            if (this.cmpChar(this.tokenStart, U) &&
                this.cmpChar(this.tokenStart + 1, PLUSSIGN$1)) {
                return this.UnicodeRange();
            } else {
                return this.Identifier();
            }

        case Delim: {
            const code = this.charCodeAt(this.tokenStart);

            if (code === SOLIDUS$1 ||
                code === ASTERISK$1 ||
                code === PLUSSIGN$1 ||
                code === HYPHENMINUS) {
                return this.Operator(); // TODO: replace with Delim
            }

            // TODO: produce a node with Delim node type

            if (code === NUMBERSIGN$1) {
                this.error('Hex or identifier is expected', this.tokenStart + 1);
            }

            break;
        }
    }
}

var atrulePrelude = {
    getNode: defaultRecognizer
};

const NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)
const AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)
const ASTERISK = 0x002A;        // U+002A ASTERISK (*)
const PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
const SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
const FULLSTOP = 0x002E;        // U+002E FULL STOP (.)
const GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)
const VERTICALLINE = 0x007C;    // U+007C VERTICAL LINE (|)
const TILDE = 0x007E;           // U+007E TILDE (~)

function onWhiteSpace(next, children) {
    if (children.last !== null && children.last.type !== 'Combinator' &&
        next !== null && next.type !== 'Combinator') {
        children.push({  // FIXME: this.Combinator() should be used instead
            type: 'Combinator',
            loc: null,
            name: ' '
        });
    }
}

function getNode() {
    switch (this.tokenType) {
        case LeftSquareBracket:
            return this.AttributeSelector();

        case Hash$1:
            return this.IdSelector();

        case Colon$1:
            if (this.lookupType(1) === Colon$1) {
                return this.PseudoElementSelector();
            } else {
                return this.PseudoClassSelector();
            }

        case Ident:
            return this.TypeSelector();

        case Number$2:
        case Percentage$1:
            return this.Percentage();

        case Dimension$1:
            // throws when .123ident
            if (this.charCodeAt(this.tokenStart) === FULLSTOP) {
                this.error('Identifier is expected', this.tokenStart + 1);
            }
            break;

        case Delim: {
            const code = this.charCodeAt(this.tokenStart);

            switch (code) {
                case PLUSSIGN:
                case GREATERTHANSIGN:
                case TILDE:
                case SOLIDUS:  // /deep/
                    return this.Combinator();

                case FULLSTOP:
                    return this.ClassSelector();

                case ASTERISK:
                case VERTICALLINE:
                    return this.TypeSelector();

                case NUMBERSIGN:
                    return this.IdSelector();

                case AMPERSAND:
                    return this.NestingSelector();
            }

            break;
        }
    }
}
var selector$1 = {
    onWhiteSpace,
    getNode
};

// legacy IE function
// expression( <any-value> )
function expressionFn() {
    return this.createSingleNodeList(
        this.Raw(this.tokenIndex, null, false)
    );
}

// var( <ident> , <value>? )
function varFn() {
    const children = this.createList();

    this.skipSC();

    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
    children.push(this.Identifier());

    this.skipSC();

    if (this.tokenType === Comma) {
        children.push(this.Operator());

        const startIndex = this.tokenIndex;
        const value = this.parseCustomProperty
            ? this.Value(null)
            : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);

        if (value.type === 'Value' && value.children.isEmpty) {
            for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {
                if (this.lookupType(offset) === WhiteSpace$1) {
                    value.children.appendData({
                        type: 'WhiteSpace',
                        loc: null,
                        value: ' '
                    });
                    break;
                }
            }
        }

        children.push(value);
    }

    return children;
}

function isPlusMinusOperator(node) {
    return (
        node !== null &&
        node.type === 'Operator' &&
        (node.value[node.value.length - 1] === '-' || node.value[node.value.length - 1] === '+')
    );
}

var value = {
    getNode: defaultRecognizer,
    onWhiteSpace(next, children) {
        if (isPlusMinusOperator(next)) {
            next.value = ' ' + next.value;
        }
        if (isPlusMinusOperator(children.last)) {
            children.last.value += ' ';
        }
    },
    'expression': expressionFn,
    'var': varFn
};

var scope = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AtrulePrelude: atrulePrelude,
  Selector: selector$1,
  Value: value
});

var fontFace = {
    parse: {
        prelude: null,
        block() {
            return this.Block(true);
        }
    }
};

var importAtrule = {
    parse: {
        prelude() {
            const children = this.createList();

            this.skipSC();

            switch (this.tokenType) {
                case String$2:
                    children.push(this.String());
                    break;

                case Url$1:
                case Function$2:
                    children.push(this.Url());
                    break;

                default:
                    this.error('String or url() is expected');
            }

            if (this.lookupNonWSType(0) === Ident ||
                this.lookupNonWSType(0) === LeftParenthesis) {
                children.push(this.MediaQueryList());
            }

            return children;
        },
        block: null
    }
};

var media = {
    parse: {
        prelude() {
            return this.createSingleNodeList(
                this.MediaQueryList()
            );
        },
        block(isStyleBlock = false) {
            return this.Block(isStyleBlock);
        }
    }
};

var nest = {
    parse: {
        prelude() {
            return this.createSingleNodeList(
                this.SelectorList()
            );
        },
        block() {
            return this.Block(true);
        }
    }
};

var page = {
    parse: {
        prelude() {
            return this.createSingleNodeList(
                this.SelectorList()
            );
        },
        block() {
            return this.Block(true);
        }
    }
};

function consumeRaw() {
    return this.createSingleNodeList(
        this.Raw(this.tokenIndex, null, false)
    );
}

function parentheses() {
    this.skipSC();

    if (this.tokenType === Ident &&
        this.lookupNonWSType(1) === Colon$1) {
        return this.createSingleNodeList(
            this.Declaration()
        );
    }

    return readSequence.call(this);
}

function readSequence() {
    const children = this.createList();
    let child;

    this.skipSC();

    scan:
    while (!this.eof) {
        switch (this.tokenType) {
            case Comment$1:
            case WhiteSpace$1:
                this.next();
                continue;

            case Function$2:
                child = this.Function(consumeRaw, this.scope.AtrulePrelude);
                break;

            case Ident:
                child = this.Identifier();
                break;

            case LeftParenthesis:
                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
                break;

            default:
                break scan;
        }

        children.push(child);
    }

    return children;
}

var supports = {
    parse: {
        prelude() {
            const children = readSequence.call(this);

            if (this.getFirstListNode(children) === null) {
                this.error('Condition is expected');
            }

            return children;
        },
        block(isStyleBlock = false) {
            return this.Block(isStyleBlock);
        }
    }
};

var atrule = {
    'font-face': fontFace,
    'import': importAtrule,
    media,
    nest,
    page,
    supports
};

const selectorList = {
    parse() {
        return this.createSingleNodeList(
            this.SelectorList()
        );
    }
};

const selector = {
    parse() {
        return this.createSingleNodeList(
            this.Selector()
        );
    }
};

const identList = {
    parse() {
        return this.createSingleNodeList(
            this.Identifier()
        );
    }
};

const nth = {
    parse() {
        return this.createSingleNodeList(
            this.Nth()
        );
    }
};

var pseudo = {
    'dir': identList,
    'has': selectorList,
    'lang': identList,
    'matches': selectorList,
    'is': selectorList,
    '-moz-any': selectorList,
    '-webkit-any': selectorList,
    'where': selectorList,
    'not': selectorList,
    'nth-child': nth,
    'nth-last-child': nth,
    'nth-last-of-type': nth,
    'nth-of-type': nth,
    'slotted': selector,
    'host': selector,
    'host-context': selector
};

var node$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AnPlusB: parse$W,
  Atrule: parse$V,
  AtrulePrelude: parse$U,
  AttributeSelector: parse$T,
  Block: parse$S,
  Brackets: parse$R,
  CDC: parse$Q,
  CDO: parse$P,
  ClassSelector: parse$O,
  Combinator: parse$N,
  Comment: parse$M,
  Declaration: parse$L,
  DeclarationList: parse$K,
  Dimension: parse$J,
  Function: parse$I,
  Hash: parse$H,
  IdSelector: parse$F,
  Identifier: parse$G,
  MediaFeature: parse$E,
  MediaQuery: parse$D,
  MediaQueryList: parse$C,
  NestingSelector: parse$B,
  Nth: parse$A,
  Number: parse$z,
  Operator: parse$y,
  Parentheses: parse$x,
  Percentage: parse$w,
  PseudoClassSelector: parse$v,
  PseudoElementSelector: parse$u,
  Ratio: parse$t,
  Raw: parse$s,
  Rule: parse$r,
  Selector: parse$q,
  SelectorList: parse$p,
  String: parse$o,
  StyleSheet: parse$n,
  TypeSelector: parse$m,
  UnicodeRange: parse$l,
  Url: parse$k,
  Value: parse$j,
  WhiteSpace: parse$i
});

var parserConfig = {
    parseContext: {
        default: 'StyleSheet',
        stylesheet: 'StyleSheet',
        atrule: 'Atrule',
        atrulePrelude(options) {
            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
        },
        mediaQueryList: 'MediaQueryList',
        mediaQuery: 'MediaQuery',
        rule: 'Rule',
        selectorList: 'SelectorList',
        selector: 'Selector',
        block() {
            return this.Block(true);
        },
        declarationList: 'DeclarationList',
        declaration: 'Declaration',
        value: 'Value'
    },
    scope,
    atrule,
    pseudo,
    node: node$1
};

var walkerConfig = {
    node: node$2
};

var syntax = createSyntax$1({
    ...lexerConfig,
    ...parserConfig,
    ...walkerConfig
});

const require$1 = createRequire(import.meta.url);

require$1('../package.json');

const {
    tokenize: tokenize$1,
    parse: parse$h,
    generate: generate$7,
    lexer,
    createLexer,

    walk,
    find: find$1,
    findLast,
    findAll,

    toPlainObject,
    fromPlainObject,

    fork: fork$1
} = syntax;

// @ts-nocheck

const name$8 = 'Comparison';
const structure$6 = {
	value: String
};

function parse$g() {
	const start = this.tokenStart;

	const char1 = this.consume(Delim);

	// The first character in the comparison operator must match '<', '=', or '>'.
	if (char1 !== '<' && char1 !== '>' && char1 !== '=') {
		this.error('Malformed comparison operator');
	}

	let char2;

	if (this.tokenType === Delim) {
		char2 = this.consume(Delim);

		// The second character in the comparison operator must match '='.
		if (char2 !== '=') {
			this.error('Malformed comparison operator');
		}
	}

	// If the next token is also 'Delim' then it is malformed.
	if (this.tokenType === Delim) {
		this.error('Malformed comparison operator');
	}

	const value = char2 ? `${char1}${char2}` : char1;

	return {
		type: 'Comparison',
		loc: this.getLocation(start, this.tokenStart),
		value
	};
}

function generate$6(node) {
	for (let index = 0; index < node.value.length; index++) {
		this.token(Delim, node.value.charAt(index));
	}
}

var comparison = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$6,
  name: name$8,
  parse: parse$g,
  structure: structure$6
});

// @ts-nocheck

const name$7 = 'ContainerFeatureStyle';
const structure$5 = {
	name: String,
	value: ['Function', 'Identifier', 'Number', 'Dimension', 'QueryCSSFunction', 'Ratio', null]
};

function parse$f() {
	const start = this.tokenStart;
	let value = null;

	const function_name = this.consumeFunctionName();
	if (function_name !== 'style') {
		this.error('Unknown container style query identifier; "style" is expected');
	}

	this.skipSC();

	const name = this.consume(Ident);
	this.skipSC();

	if (this.tokenType !== RightParenthesis) {
		this.eat(Colon$1);
		this.skipSC();

		switch (this.tokenType) {
			case Number$2:
				if (this.lookupNonWSType(1) === Delim) {
					value = this.Ratio();
				} else {
					value = this.Number();
				}
				break;

			case Dimension$1:
				value = this.Dimension();
				break;

			case Function$2:
				value = this.QueryCSSFunction();
				break;

			case Ident:
				value = this.Identifier();
				break;

			default:
				this.error('Number, dimension, ratio, function or identifier is expected');
				break;
		}

		this.skipSC();
	}

	this.eat(RightParenthesis);

	return {
		type: 'ContainerFeatureStyle',
		loc: this.getLocation(start, this.tokenStart),
		name,
		value
	};
}

function generate$5(node) {
	this.token(Function$2, 'style(');
	this.token(Ident, node.name);

	if (node.value !== null) {
		this.token(Colon$1, ':');
		this.node(node.value);
	}

	this.token(RightParenthesis, ')');
}

var container_feature_style = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$5,
  name: name$7,
  parse: parse$f,
  structure: structure$5
});

// @ts-nocheck

/**
 * Looks ahead to determine if query feature is a range query. This involves locating at least one delimiter and no
 * colon tokens.
 *
 * @returns {boolean} Is potential range query.
 */
function lookahead_is_range() {
	let type;
	let offset = 0;

	let count = 0;
	let delim_found = false;
	let no_colon = true;

	// A range query has maximum 5 tokens when formatted as 'mf-range' /
	// '<mf-value> <mf-lt> <mf-name> <mf-lt> <mf-value>'. So only look ahead maximum of 6 non-whitespace tokens.
	do {
		type = this.lookupNonWSType(offset++);
		if (type !== WhiteSpace$1) {
			count++;
		}
		if (type === Delim) {
			delim_found = true;
		}
		if (type === Colon$1) {
			no_colon = false;
		}
		if (type === LeftCurlyBracket || type === RightParenthesis) {
			break;
		}
	} while (type !== EOF$1 && count <= 6);

	return delim_found && no_colon;
}

// @ts-nocheck

const CONTAINER_QUERY_KEYWORDS = new Set(['none', 'and', 'not', 'or']);

const name$6 = 'ContainerQuery';
const structure$4 = {
	name: 'Identifier',
	children: [
		['Identifier', 'QueryFeature', 'QueryFeatureRange', 'ContainerFeatureStyle', 'WhiteSpace']
	]
};

function parse$e() {
	const start = this.tokenStart;
	const children = this.createList();
	let child = null;
	let name = null;

	// Parse potential container name.
	if (this.tokenType === Ident) {
		const container_name = this.substring(this.tokenStart, this.tokenEnd);

		// Container name doesn't match a query keyword, so assign it as container name.
		if (!CONTAINER_QUERY_KEYWORDS.has(container_name.toLowerCase())) {
			name = container_name;
			this.eatIdent(container_name);
		}
	}

	this.skipSC();

	scan: while (!this.eof) {
		switch (this.tokenType) {
			case Comment$1:
			case WhiteSpace$1:
				this.next();
				continue;

			case Ident:
				child = this.Identifier();
				break;

			case Function$2:
				child = this.ContainerFeatureStyle();
				break;

			case LeftParenthesis:
				// Lookahead to determine if range feature.
				child = lookahead_is_range.call(this) ? this.QueryFeatureRange() : this.QueryFeature();
				break;

			default:
				break scan;
		}

		children.push(child);
	}

	if (child === null) {
		this.error('Identifier or parenthesis is expected');
	}

	return {
		type: 'ContainerQuery',
		loc: this.getLocation(start, this.tokenStart - 1),
		name,
		children
	};
}

function generate$4(node) {
	if (typeof node.name === 'string') {
		this.token(Ident, node.name);
	}

	this.children(node);
}

var container_query = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$4,
  name: name$6,
  parse: parse$e,
  structure: structure$4
});

// @ts-nocheck

const name$5 = 'MediaQuery';
const structure$3 = {
	children: [['Identifier', 'QueryFeature', 'QueryFeatureRange', 'WhiteSpace']]
};

function parse$d() {
	const children = this.createList();
	let child = null;

	this.skipSC();

	scan: while (!this.eof) {
		switch (this.tokenType) {
			case Comment$1:
			case WhiteSpace$1:
				this.next();
				continue;

			case Ident:
				child = this.Identifier();
				break;

			case LeftParenthesis:
				// Lookahead to determine if range feature.
				child = lookahead_is_range.call(this) ? this.QueryFeatureRange() : this.QueryFeature();
				break;

			default:
				break scan;
		}

		children.push(child);
	}

	if (child === null) {
		this.error('Identifier or parenthesis is expected');
	}

	return {
		type: 'MediaQuery',
		loc: this.getLocationFromList(children),
		children
	};
}

function generate$3(node) {
	this.children(node);
}

var media_query = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$3,
  name: name$5,
  parse: parse$d,
  structure: structure$3
});

// @ts-nocheck

const name$4 = 'QueryFeature';
const structure$2 = {
	name: String,
	value: ['Identifier', 'Number', 'Dimension', 'QueryCSSFunction', 'Ratio', null]
};

function parse$c() {
	const start = this.tokenStart;
	let value = null;

	this.eat(LeftParenthesis);
	this.skipSC();

	const name = this.consume(Ident);
	this.skipSC();

	if (this.tokenType !== RightParenthesis) {
		this.eat(Colon$1);
		this.skipSC();

		switch (this.tokenType) {
			case Number$2:
				if (this.lookupNonWSType(1) === Delim) {
					value = this.Ratio();
				} else {
					value = this.Number();
				}
				break;

			case Dimension$1:
				value = this.Dimension();
				break;

			case Function$2:
				value = this.QueryCSSFunction();
				break;

			case Ident:
				value = this.Identifier();
				break;

			default:
				this.error('Number, dimension, ratio, function, or identifier is expected');
				break;
		}

		this.skipSC();
	}

	this.eat(RightParenthesis);

	return {
		type: 'QueryFeature',
		loc: this.getLocation(start, this.tokenStart),
		name,
		value
	};
}

function generate$2(node) {
	this.token(LeftParenthesis, '(');
	this.token(Ident, node.name);

	if (node.value !== null) {
		this.token(Colon$1, ':');
		this.node(node.value);
	}

	this.token(RightParenthesis, ')');
}

var query_feature = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$2,
  name: name$4,
  parse: parse$c,
  structure: structure$2
});

// @ts-nocheck

const name$3 = 'QueryFeatureRange';
const structure$1 = {
	name: String,
	value: ['Identifier', 'Number', 'Comparison', 'Dimension', 'QueryCSSFunction', 'Ratio', null]
};

function lookup_non_WS_type_and_value(offset, type, referenceStr) {
	let current_type;

	do {
		current_type = this.lookupType(offset++);
		if (current_type !== WhiteSpace$1) {
			break;
		}
	} while (current_type !== 0); // NULL -> 0

	return current_type === type ? this.lookupValue(offset - 1, referenceStr) : false;
}

function parse$b() {
	const start = this.tokenStart;
	const children = this.createList();
	let child = null;

	this.eat(LeftParenthesis);
	this.skipSC();

	while (!this.eof && this.tokenType !== RightParenthesis) {
		switch (this.tokenType) {
			case Number$2:
				if (lookup_non_WS_type_and_value.call(this, 1, Delim, '/')) {
					child = this.Ratio();
				} else {
					child = this.Number();
				}
				break;

			case Delim:
				child = this.Comparison();
				break;

			case Dimension$1:
				child = this.Dimension();
				break;

			case Function$2:
				child = this.QueryCSSFunction();
				break;

			case Ident:
				child = this.Identifier();
				break;

			default:
				this.error('Number, dimension, comparison, ratio, function, or identifier is expected');
				break;
		}

		children.push(child);

		this.skipSC();
	}

	this.eat(RightParenthesis);

	return {
		type: 'QueryFeatureRange',
		loc: this.getLocation(start, this.tokenStart),
		children
	};
}

function generate$1(node) {
	this.children(node);
}

var query_feature_range = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate$1,
  name: name$3,
  parse: parse$b,
  structure: structure$1
});

// @ts-nocheck

const QUERY_CSS_FUNCTIONS = new Set(['calc', 'clamp', 'min', 'max']);

const name$2 = 'QueryCSSFunction';
const structure = {
	name: String,
	expression: String
};

function parse$a() {
	const start = this.tokenStart;

	const name = this.consumeFunctionName();

	if (!QUERY_CSS_FUNCTIONS.has(name)) {
		this.error('Unknown query single value function; expected: "calc", "clamp", "max", min"');
	}

	const body = this.Raw(this.tokenIndex, null, false);

	this.eat(RightParenthesis);

	return {
		type: 'QueryCSSFunction',
		loc: this.getLocation(start, this.tokenStart),
		name,
		expression: body.value
	};
}

function generate(node) {
	this.token(Function, `${node.name}(`);

	this.node(node.expression);

	this.token(RightParenthesis, ')');
}

var query_css_function = /*#__PURE__*/Object.freeze({
  __proto__: null,
  generate: generate,
  name: name$2,
  parse: parse$a,
  structure: structure
});

var node = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Comparison: comparison,
  ContainerFeatureStyle: container_feature_style,
  ContainerQuery: container_query,
  MediaQuery: media_query,
  QueryCSSFunction: query_css_function,
  QueryFeature: query_feature,
  QueryFeatureRange: query_feature_range
});

// @ts-nocheck

/**
 * Extends `css-tree` for container query support by forking and adding new nodes and at-rule support for `@container`.
 *
 * The new nodes are located in `./node`.
 */
const cqSyntax = fork$1({
	atrule: {
		// extend or override at-rule dictionary
		container: {
			parse: {
				prelude() {
					return this.createSingleNodeList(this.ContainerQuery());
				},
				block(isStyleBlock = false) {
					return this.Block(isStyleBlock);
				}
			}
		}
	},
	node
});

const parse$9 = cqSyntax.parse;

// @ts-ignore
// import parse from 'css-tree/parser'; // When css-tree supports container queries uncomment.

const regex_closing_style_tag = /<\/style\s*>/;
const regex_starts_with_closing_style_tag = /^<\/style\s*>/;

/**
 *
 * @param {import('../index.js').Parser} parser
 * @param {number} start
 * @param {import('estree').Node[]} attributes
 * @returns {import('../../interfaces.js').Style}
 */
function read_style(parser, start, attributes) {
	const content_start = parser.index;

	const styles = parser.read_until(regex_closing_style_tag, parser_errors.unclosed_style);

	if (parser.index >= parser.template.length) {
		parser.error(parser_errors.unclosed_style);
	}

	const content_end = parser.index;

	// discard styles when css is disabled
	if (parser.css_mode === 'none') {
		parser.read(regex_starts_with_closing_style_tag);
		return null;
	}

	let ast;

	try {
		ast = parse$9(styles, {
			positions: true,
			offset: content_start,
			onParseError(error) {
				throw error;
			}
		});
	} catch (err) {
		if (err.name === 'SyntaxError') {
			parser.error(parser_errors.css_syntax_error(err.message), err.offset);
		} else {
			throw err;
		}
	}

	ast = JSON.parse(JSON.stringify(ast));

	// tidy up AST
	walk$2(ast, {
		/** @param {any} node */
		enter: (node) => {
			// `any` because this isn't an ESTree node
			// replace `ref:a` nodes
			if (node.type === 'Selector') {
				for (let i = 0; i < node.children.length; i += 1) {
					const a = node.children[i];
					const b = node.children[i + 1];

					if (is_ref_selector(a, b)) {
						parser.error(parser_errors.invalid_ref_selector, a.loc.start.offset);
					}
				}
			}

			if (
				node.type === 'Declaration' &&
				node.value.type === 'Value' &&
				node.value.children.length === 0
			) {
				parser.error(parser_errors.invalid_declaration, node.start);
			}

			if (node.type === 'PseudoClassSelector' && node.name === 'global' && node.children === null) {
				parser.error(parser_errors.empty_global_selector, node.loc.start.offset);
			}

			if (node.loc) {
				node.start = node.loc.start.offset;
				node.end = node.loc.end.offset;
				delete node.loc;
			}
		}
	});

	parser.read(regex_starts_with_closing_style_tag);

	const end = parser.index;

	return {
		type: 'Style',
		start,
		end,
		attributes,
		children: ast.children,
		content: {
			start: content_start,
			end: content_end,
			styles
		}
	};
}

/**
 * @param {any} a
 * @param {any} b
 */
function is_ref_selector(a, b) {
	// TODO add CSS node types
	if (!b) return false;

	return a.type === 'TypeSelector' && a.name === 'ref' && b.type === 'PseudoClassSelector';
}

// https://html.spec.whatwg.org/entities.json from https://dev.w3.org/html5/html-author/charref
var entities$1 = {
	'CounterClockwiseContourIntegral;': 8755,
	'ClockwiseContourIntegral;': 8754,
	'DoubleLongLeftRightArrow;': 10234,
	'NotNestedGreaterGreater;': 10914,
	'DiacriticalDoubleAcute;': 733,
	'NotSquareSupersetEqual;': 8931,
	'CloseCurlyDoubleQuote;': 8221,
	'DoubleContourIntegral;': 8751,
	'FilledVerySmallSquare;': 9642,
	'NegativeVeryThinSpace;': 8203,
	'NotPrecedesSlantEqual;': 8928,
	'NotRightTriangleEqual;': 8941,
	'NotSucceedsSlantEqual;': 8929,
	'CapitalDifferentialD;': 8517,
	'DoubleLeftRightArrow;': 8660,
	'DoubleLongRightArrow;': 10233,
	'EmptyVerySmallSquare;': 9643,
	'NestedGreaterGreater;': 8811,
	'NotDoubleVerticalBar;': 8742,
	'NotGreaterSlantEqual;': 10878,
	'NotLeftTriangleEqual;': 8940,
	'NotSquareSubsetEqual;': 8930,
	'OpenCurlyDoubleQuote;': 8220,
	'ReverseUpEquilibrium;': 10607,
	'DoubleLongLeftArrow;': 10232,
	'DownLeftRightVector;': 10576,
	'LeftArrowRightArrow;': 8646,
	'NegativeMediumSpace;': 8203,
	'NotGreaterFullEqual;': 8807,
	'NotRightTriangleBar;': 10704,
	'RightArrowLeftArrow;': 8644,
	'SquareSupersetEqual;': 8850,
	'leftrightsquigarrow;': 8621,
	'DownRightTeeVector;': 10591,
	'DownRightVectorBar;': 10583,
	'LongLeftRightArrow;': 10231,
	'Longleftrightarrow;': 10234,
	'NegativeThickSpace;': 8203,
	'NotLeftTriangleBar;': 10703,
	'PrecedesSlantEqual;': 8828,
	'ReverseEquilibrium;': 8651,
	'RightDoubleBracket;': 10215,
	'RightDownTeeVector;': 10589,
	'RightDownVectorBar;': 10581,
	'RightTriangleEqual;': 8885,
	'SquareIntersection;': 8851,
	'SucceedsSlantEqual;': 8829,
	'blacktriangleright;': 9656,
	'longleftrightarrow;': 10231,
	'DoubleUpDownArrow;': 8661,
	'DoubleVerticalBar;': 8741,
	'DownLeftTeeVector;': 10590,
	'DownLeftVectorBar;': 10582,
	'FilledSmallSquare;': 9724,
	'GreaterSlantEqual;': 10878,
	'LeftDoubleBracket;': 10214,
	'LeftDownTeeVector;': 10593,
	'LeftDownVectorBar;': 10585,
	'LeftTriangleEqual;': 8884,
	'NegativeThinSpace;': 8203,
	'NotGreaterGreater;': 8811,
	'NotLessSlantEqual;': 10877,
	'NotNestedLessLess;': 10913,
	'NotReverseElement;': 8716,
	'NotSquareSuperset;': 8848,
	'NotTildeFullEqual;': 8775,
	'RightAngleBracket;': 10217,
	'RightUpDownVector;': 10575,
	'SquareSubsetEqual;': 8849,
	'VerticalSeparator;': 10072,
	'blacktriangledown;': 9662,
	'blacktriangleleft;': 9666,
	'leftrightharpoons;': 8651,
	'rightleftharpoons;': 8652,
	'twoheadrightarrow;': 8608,
	'DiacriticalAcute;': 180,
	'DiacriticalGrave;': 96,
	'DiacriticalTilde;': 732,
	'DoubleRightArrow;': 8658,
	'DownArrowUpArrow;': 8693,
	'EmptySmallSquare;': 9723,
	'GreaterEqualLess;': 8923,
	'GreaterFullEqual;': 8807,
	'LeftAngleBracket;': 10216,
	'LeftUpDownVector;': 10577,
	'LessEqualGreater;': 8922,
	'NonBreakingSpace;': 160,
	'NotPrecedesEqual;': 10927,
	'NotRightTriangle;': 8939,
	'NotSucceedsEqual;': 10928,
	'NotSucceedsTilde;': 8831,
	'NotSupersetEqual;': 8841,
	'RightTriangleBar;': 10704,
	'RightUpTeeVector;': 10588,
	'RightUpVectorBar;': 10580,
	'UnderParenthesis;': 9181,
	'UpArrowDownArrow;': 8645,
	'circlearrowright;': 8635,
	'downharpoonright;': 8642,
	'ntrianglerighteq;': 8941,
	'rightharpoondown;': 8641,
	'rightrightarrows;': 8649,
	'twoheadleftarrow;': 8606,
	'vartriangleright;': 8883,
	'CloseCurlyQuote;': 8217,
	'ContourIntegral;': 8750,
	'DoubleDownArrow;': 8659,
	'DoubleLeftArrow;': 8656,
	'DownRightVector;': 8641,
	'LeftRightVector;': 10574,
	'LeftTriangleBar;': 10703,
	'LeftUpTeeVector;': 10592,
	'LeftUpVectorBar;': 10584,
	'LowerRightArrow;': 8600,
	'NotGreaterEqual;': 8817,
	'NotGreaterTilde;': 8821,
	'NotHumpDownHump;': 8782,
	'NotLeftTriangle;': 8938,
	'NotSquareSubset;': 8847,
	'OverParenthesis;': 9180,
	'RightDownVector;': 8642,
	'ShortRightArrow;': 8594,
	'UpperRightArrow;': 8599,
	'bigtriangledown;': 9661,
	'circlearrowleft;': 8634,
	'curvearrowright;': 8631,
	'downharpoonleft;': 8643,
	'leftharpoondown;': 8637,
	'leftrightarrows;': 8646,
	'nLeftrightarrow;': 8654,
	'nleftrightarrow;': 8622,
	'ntrianglelefteq;': 8940,
	'rightleftarrows;': 8644,
	'rightsquigarrow;': 8605,
	'rightthreetimes;': 8908,
	'straightepsilon;': 1013,
	'trianglerighteq;': 8885,
	'vartriangleleft;': 8882,
	'DiacriticalDot;': 729,
	'DoubleRightTee;': 8872,
	'DownLeftVector;': 8637,
	'GreaterGreater;': 10914,
	'HorizontalLine;': 9472,
	'InvisibleComma;': 8291,
	'InvisibleTimes;': 8290,
	'LeftDownVector;': 8643,
	'LeftRightArrow;': 8596,
	'Leftrightarrow;': 8660,
	'LessSlantEqual;': 10877,
	'LongRightArrow;': 10230,
	'Longrightarrow;': 10233,
	'LowerLeftArrow;': 8601,
	'NestedLessLess;': 8810,
	'NotGreaterLess;': 8825,
	'NotLessGreater;': 8824,
	'NotSubsetEqual;': 8840,
	'NotVerticalBar;': 8740,
	'OpenCurlyQuote;': 8216,
	'ReverseElement;': 8715,
	'RightTeeVector;': 10587,
	'RightVectorBar;': 10579,
	'ShortDownArrow;': 8595,
	'ShortLeftArrow;': 8592,
	'SquareSuperset;': 8848,
	'TildeFullEqual;': 8773,
	'UpperLeftArrow;': 8598,
	'ZeroWidthSpace;': 8203,
	'curvearrowleft;': 8630,
	'doublebarwedge;': 8966,
	'downdownarrows;': 8650,
	'hookrightarrow;': 8618,
	'leftleftarrows;': 8647,
	'leftrightarrow;': 8596,
	'leftthreetimes;': 8907,
	'longrightarrow;': 10230,
	'looparrowright;': 8620,
	'nshortparallel;': 8742,
	'ntriangleright;': 8939,
	'rightarrowtail;': 8611,
	'rightharpoonup;': 8640,
	'trianglelefteq;': 8884,
	'upharpoonright;': 8638,
	'ApplyFunction;': 8289,
	'DifferentialD;': 8518,
	'DoubleLeftTee;': 10980,
	'DoubleUpArrow;': 8657,
	'LeftTeeVector;': 10586,
	'LeftVectorBar;': 10578,
	'LessFullEqual;': 8806,
	'LongLeftArrow;': 10229,
	'Longleftarrow;': 10232,
	'NotEqualTilde;': 8770,
	'NotTildeEqual;': 8772,
	'NotTildeTilde;': 8777,
	'Poincareplane;': 8460,
	'PrecedesEqual;': 10927,
	'PrecedesTilde;': 8830,
	'RightArrowBar;': 8677,
	'RightTeeArrow;': 8614,
	'RightTriangle;': 8883,
	'RightUpVector;': 8638,
	'SucceedsEqual;': 10928,
	'SucceedsTilde;': 8831,
	'SupersetEqual;': 8839,
	'UpEquilibrium;': 10606,
	'VerticalTilde;': 8768,
	'VeryThinSpace;': 8202,
	'bigtriangleup;': 9651,
	'blacktriangle;': 9652,
	'divideontimes;': 8903,
	'fallingdotseq;': 8786,
	'hookleftarrow;': 8617,
	'leftarrowtail;': 8610,
	'leftharpoonup;': 8636,
	'longleftarrow;': 10229,
	'looparrowleft;': 8619,
	'measuredangle;': 8737,
	'ntriangleleft;': 8938,
	'shortparallel;': 8741,
	'smallsetminus;': 8726,
	'triangleright;': 9657,
	'upharpoonleft;': 8639,
	'varsubsetneqq;': 10955,
	'varsupsetneqq;': 10956,
	'DownArrowBar;': 10515,
	'DownTeeArrow;': 8615,
	'ExponentialE;': 8519,
	'GreaterEqual;': 8805,
	'GreaterTilde;': 8819,
	'HilbertSpace;': 8459,
	'HumpDownHump;': 8782,
	'Intersection;': 8898,
	'LeftArrowBar;': 8676,
	'LeftTeeArrow;': 8612,
	'LeftTriangle;': 8882,
	'LeftUpVector;': 8639,
	'NotCongruent;': 8802,
	'NotHumpEqual;': 8783,
	'NotLessEqual;': 8816,
	'NotLessTilde;': 8820,
	'Proportional;': 8733,
	'RightCeiling;': 8969,
	'RoundImplies;': 10608,
	'ShortUpArrow;': 8593,
	'SquareSubset;': 8847,
	'UnderBracket;': 9141,
	'VerticalLine;': 124,
	'blacklozenge;': 10731,
	'exponentiale;': 8519,
	'risingdotseq;': 8787,
	'triangledown;': 9663,
	'triangleleft;': 9667,
	'varsubsetneq;': 8842,
	'varsupsetneq;': 8843,
	'CircleMinus;': 8854,
	'CircleTimes;': 8855,
	'Equilibrium;': 8652,
	'GreaterLess;': 8823,
	'LeftCeiling;': 8968,
	'LessGreater;': 8822,
	'MediumSpace;': 8287,
	'NotLessLess;': 8810,
	'NotPrecedes;': 8832,
	'NotSucceeds;': 8833,
	'NotSuperset;': 8835,
	'OverBracket;': 9140,
	'RightVector;': 8640,
	'Rrightarrow;': 8667,
	'RuleDelayed;': 10740,
	'SmallCircle;': 8728,
	'SquareUnion;': 8852,
	'SubsetEqual;': 8838,
	'UpDownArrow;': 8597,
	'Updownarrow;': 8661,
	'VerticalBar;': 8739,
	'backepsilon;': 1014,
	'blacksquare;': 9642,
	'circledcirc;': 8858,
	'circleddash;': 8861,
	'curlyeqprec;': 8926,
	'curlyeqsucc;': 8927,
	'diamondsuit;': 9830,
	'eqslantless;': 10901,
	'expectation;': 8496,
	'nRightarrow;': 8655,
	'nrightarrow;': 8603,
	'preccurlyeq;': 8828,
	'precnapprox;': 10937,
	'quaternions;': 8461,
	'straightphi;': 981,
	'succcurlyeq;': 8829,
	'succnapprox;': 10938,
	'thickapprox;': 8776,
	'updownarrow;': 8597,
	'Bernoullis;': 8492,
	'CirclePlus;': 8853,
	'EqualTilde;': 8770,
	'Fouriertrf;': 8497,
	'ImaginaryI;': 8520,
	'Laplacetrf;': 8466,
	'LeftVector;': 8636,
	'Lleftarrow;': 8666,
	'NotElement;': 8713,
	'NotGreater;': 8815,
	'Proportion;': 8759,
	'RightArrow;': 8594,
	'RightFloor;': 8971,
	'Rightarrow;': 8658,
	'ThickSpace;': 8287,
	'TildeEqual;': 8771,
	'TildeTilde;': 8776,
	'UnderBrace;': 9183,
	'UpArrowBar;': 10514,
	'UpTeeArrow;': 8613,
	'circledast;': 8859,
	'complement;': 8705,
	'curlywedge;': 8911,
	'eqslantgtr;': 10902,
	'gtreqqless;': 10892,
	'lessapprox;': 10885,
	'lesseqqgtr;': 10891,
	'lmoustache;': 9136,
	'longmapsto;': 10236,
	'mapstodown;': 8615,
	'mapstoleft;': 8612,
	'nLeftarrow;': 8653,
	'nleftarrow;': 8602,
	'nsubseteqq;': 10949,
	'nsupseteqq;': 10950,
	'precapprox;': 10935,
	'rightarrow;': 8594,
	'rmoustache;': 9137,
	'sqsubseteq;': 8849,
	'sqsupseteq;': 8850,
	'subsetneqq;': 10955,
	'succapprox;': 10936,
	'supsetneqq;': 10956,
	'upuparrows;': 8648,
	'varepsilon;': 1013,
	'varnothing;': 8709,
	'Backslash;': 8726,
	'CenterDot;': 183,
	'CircleDot;': 8857,
	'Congruent;': 8801,
	'Coproduct;': 8720,
	'DoubleDot;': 168,
	'DownArrow;': 8595,
	'DownBreve;': 785,
	'Downarrow;': 8659,
	'HumpEqual;': 8783,
	'LeftArrow;': 8592,
	'LeftFloor;': 8970,
	'Leftarrow;': 8656,
	'LessTilde;': 8818,
	'Mellintrf;': 8499,
	'MinusPlus;': 8723,
	'NotCupCap;': 8813,
	'NotExists;': 8708,
	'NotSubset;': 8834,
	'OverBrace;': 9182,
	'PlusMinus;': 177,
	'Therefore;': 8756,
	'ThinSpace;': 8201,
	'TripleDot;': 8411,
	'UnionPlus;': 8846,
	'backprime;': 8245,
	'backsimeq;': 8909,
	'bigotimes;': 10754,
	'centerdot;': 183,
	'checkmark;': 10003,
	'complexes;': 8450,
	'dotsquare;': 8865,
	'downarrow;': 8595,
	'gtrapprox;': 10886,
	'gtreqless;': 8923,
	'gvertneqq;': 8809,
	'heartsuit;': 9829,
	'leftarrow;': 8592,
	'lesseqgtr;': 8922,
	'lvertneqq;': 8808,
	'ngeqslant;': 10878,
	'nleqslant;': 10877,
	'nparallel;': 8742,
	'nshortmid;': 8740,
	'nsubseteq;': 8840,
	'nsupseteq;': 8841,
	'pitchfork;': 8916,
	'rationals;': 8474,
	'spadesuit;': 9824,
	'subseteqq;': 10949,
	'subsetneq;': 8842,
	'supseteqq;': 10950,
	'supsetneq;': 8843,
	'therefore;': 8756,
	'triangleq;': 8796,
	'varpropto;': 8733,
	'DDotrahd;': 10513,
	'DotEqual;': 8784,
	'Integral;': 8747,
	'LessLess;': 10913,
	'NotEqual;': 8800,
	'NotTilde;': 8769,
	'PartialD;': 8706,
	'Precedes;': 8826,
	'RightTee;': 8866,
	'Succeeds;': 8827,
	'SuchThat;': 8715,
	'Superset;': 8835,
	'Uarrocir;': 10569,
	'UnderBar;': 95,
	'andslope;': 10840,
	'angmsdaa;': 10664,
	'angmsdab;': 10665,
	'angmsdac;': 10666,
	'angmsdad;': 10667,
	'angmsdae;': 10668,
	'angmsdaf;': 10669,
	'angmsdag;': 10670,
	'angmsdah;': 10671,
	'angrtvbd;': 10653,
	'approxeq;': 8778,
	'awconint;': 8755,
	'backcong;': 8780,
	'barwedge;': 8965,
	'bbrktbrk;': 9142,
	'bigoplus;': 10753,
	'bigsqcup;': 10758,
	'biguplus;': 10756,
	'bigwedge;': 8896,
	'boxminus;': 8863,
	'boxtimes;': 8864,
	'bsolhsub;': 10184,
	'capbrcup;': 10825,
	'circledR;': 174,
	'circledS;': 9416,
	'cirfnint;': 10768,
	'clubsuit;': 9827,
	'cupbrcap;': 10824,
	'curlyvee;': 8910,
	'cwconint;': 8754,
	'doteqdot;': 8785,
	'dotminus;': 8760,
	'drbkarow;': 10512,
	'dzigrarr;': 10239,
	'elinters;': 9191,
	'emptyset;': 8709,
	'eqvparsl;': 10725,
	'fpartint;': 10765,
	'geqslant;': 10878,
	'gesdotol;': 10884,
	'gnapprox;': 10890,
	'hksearow;': 10533,
	'hkswarow;': 10534,
	'imagline;': 8464,
	'imagpart;': 8465,
	'infintie;': 10717,
	'integers;': 8484,
	'intercal;': 8890,
	'intlarhk;': 10775,
	'laemptyv;': 10676,
	'ldrushar;': 10571,
	'leqslant;': 10877,
	'lesdotor;': 10883,
	'llcorner;': 8990,
	'lnapprox;': 10889,
	'lrcorner;': 8991,
	'lurdshar;': 10570,
	'mapstoup;': 8613,
	'multimap;': 8888,
	'naturals;': 8469,
	'ncongdot;': 10861,
	'notindot;': 8949,
	'otimesas;': 10806,
	'parallel;': 8741,
	'plusacir;': 10787,
	'pointint;': 10773,
	'precneqq;': 10933,
	'precnsim;': 8936,
	'profalar;': 9006,
	'profline;': 8978,
	'profsurf;': 8979,
	'raemptyv;': 10675,
	'realpart;': 8476,
	'rppolint;': 10770,
	'rtriltri;': 10702,
	'scpolint;': 10771,
	'setminus;': 8726,
	'shortmid;': 8739,
	'smeparsl;': 10724,
	'sqsubset;': 8847,
	'sqsupset;': 8848,
	'subseteq;': 8838,
	'succneqq;': 10934,
	'succnsim;': 8937,
	'supseteq;': 8839,
	'thetasym;': 977,
	'thicksim;': 8764,
	'timesbar;': 10801,
	'triangle;': 9653,
	'triminus;': 10810,
	'trpezium;': 9186,
	'ulcorner;': 8988,
	'urcorner;': 8989,
	'varkappa;': 1008,
	'varsigma;': 962,
	'vartheta;': 977,
	'Because;': 8757,
	'Cayleys;': 8493,
	'Cconint;': 8752,
	'Cedilla;': 184,
	'Diamond;': 8900,
	'DownTee;': 8868,
	'Element;': 8712,
	'Epsilon;': 917,
	'Implies;': 8658,
	'LeftTee;': 8867,
	'NewLine;': 10,
	'NoBreak;': 8288,
	'NotLess;': 8814,
	'Omicron;': 927,
	'OverBar;': 8254,
	'Product;': 8719,
	'UpArrow;': 8593,
	'Uparrow;': 8657,
	'Upsilon;': 933,
	'alefsym;': 8501,
	'angrtvb;': 8894,
	'angzarr;': 9084,
	'asympeq;': 8781,
	'backsim;': 8765,
	'because;': 8757,
	'bemptyv;': 10672,
	'between;': 8812,
	'bigcirc;': 9711,
	'bigodot;': 10752,
	'bigstar;': 9733,
	'bnequiv;': 8801,
	'boxplus;': 8862,
	'ccupssm;': 10832,
	'cemptyv;': 10674,
	'cirscir;': 10690,
	'coloneq;': 8788,
	'congdot;': 10861,
	'cudarrl;': 10552,
	'cudarrr;': 10549,
	'cularrp;': 10557,
	'curarrm;': 10556,
	'dbkarow;': 10511,
	'ddagger;': 8225,
	'ddotseq;': 10871,
	'demptyv;': 10673,
	'diamond;': 8900,
	'digamma;': 989,
	'dotplus;': 8724,
	'dwangle;': 10662,
	'epsilon;': 949,
	'eqcolon;': 8789,
	'equivDD;': 10872,
	'gesdoto;': 10882,
	'gtquest;': 10876,
	'gtrless;': 8823,
	'harrcir;': 10568,
	'intprod;': 10812,
	'isindot;': 8949,
	'larrbfs;': 10527,
	'larrsim;': 10611,
	'lbrksld;': 10639,
	'lbrkslu;': 10637,
	'ldrdhar;': 10599,
	'lesdoto;': 10881,
	'lessdot;': 8918,
	'lessgtr;': 8822,
	'lesssim;': 8818,
	'lotimes;': 10804,
	'lozenge;': 9674,
	'ltquest;': 10875,
	'luruhar;': 10598,
	'maltese;': 10016,
	'minusdu;': 10794,
	'napprox;': 8777,
	'natural;': 9838,
	'nearrow;': 8599,
	'nexists;': 8708,
	'notinva;': 8713,
	'notinvb;': 8951,
	'notinvc;': 8950,
	'notniva;': 8716,
	'notnivb;': 8958,
	'notnivc;': 8957,
	'npolint;': 10772,
	'npreceq;': 10927,
	'nsqsube;': 8930,
	'nsqsupe;': 8931,
	'nsubset;': 8834,
	'nsucceq;': 10928,
	'nsupset;': 8835,
	'nvinfin;': 10718,
	'nvltrie;': 8884,
	'nvrtrie;': 8885,
	'nwarrow;': 8598,
	'olcross;': 10683,
	'omicron;': 959,
	'orderof;': 8500,
	'orslope;': 10839,
	'pertenk;': 8241,
	'planckh;': 8462,
	'pluscir;': 10786,
	'plussim;': 10790,
	'plustwo;': 10791,
	'precsim;': 8830,
	'quatint;': 10774,
	'questeq;': 8799,
	'rarrbfs;': 10528,
	'rarrsim;': 10612,
	'rbrksld;': 10638,
	'rbrkslu;': 10640,
	'rdldhar;': 10601,
	'realine;': 8475,
	'rotimes;': 10805,
	'ruluhar;': 10600,
	'searrow;': 8600,
	'simplus;': 10788,
	'simrarr;': 10610,
	'subedot;': 10947,
	'submult;': 10945,
	'subplus;': 10943,
	'subrarr;': 10617,
	'succsim;': 8831,
	'supdsub;': 10968,
	'supedot;': 10948,
	'suphsol;': 10185,
	'suphsub;': 10967,
	'suplarr;': 10619,
	'supmult;': 10946,
	'supplus;': 10944,
	'swarrow;': 8601,
	'topfork;': 10970,
	'triplus;': 10809,
	'tritime;': 10811,
	'uparrow;': 8593,
	'upsilon;': 965,
	'uwangle;': 10663,
	'vzigzag;': 10650,
	'zigrarr;': 8669,
	'Aacute;': 193,
	'Abreve;': 258,
	'Agrave;': 192,
	'Assign;': 8788,
	'Atilde;': 195,
	'Barwed;': 8966,
	'Bumpeq;': 8782,
	'Cacute;': 262,
	'Ccaron;': 268,
	'Ccedil;': 199,
	'Colone;': 10868,
	'Conint;': 8751,
	'CupCap;': 8781,
	'Dagger;': 8225,
	'Dcaron;': 270,
	'DotDot;': 8412,
	'Dstrok;': 272,
	'Eacute;': 201,
	'Ecaron;': 282,
	'Egrave;': 200,
	'Exists;': 8707,
	'ForAll;': 8704,
	'Gammad;': 988,
	'Gbreve;': 286,
	'Gcedil;': 290,
	'HARDcy;': 1066,
	'Hstrok;': 294,
	'Iacute;': 205,
	'Igrave;': 204,
	'Itilde;': 296,
	'Jsercy;': 1032,
	'Kcedil;': 310,
	'Lacute;': 313,
	'Lambda;': 923,
	'Lcaron;': 317,
	'Lcedil;': 315,
	'Lmidot;': 319,
	'Lstrok;': 321,
	'Nacute;': 323,
	'Ncaron;': 327,
	'Ncedil;': 325,
	'Ntilde;': 209,
	'Oacute;': 211,
	'Odblac;': 336,
	'Ograve;': 210,
	'Oslash;': 216,
	'Otilde;': 213,
	'Otimes;': 10807,
	'Racute;': 340,
	'Rarrtl;': 10518,
	'Rcaron;': 344,
	'Rcedil;': 342,
	'SHCHcy;': 1065,
	'SOFTcy;': 1068,
	'Sacute;': 346,
	'Scaron;': 352,
	'Scedil;': 350,
	'Square;': 9633,
	'Subset;': 8912,
	'Supset;': 8913,
	'Tcaron;': 356,
	'Tcedil;': 354,
	'Tstrok;': 358,
	'Uacute;': 218,
	'Ubreve;': 364,
	'Udblac;': 368,
	'Ugrave;': 217,
	'Utilde;': 360,
	'Vdashl;': 10982,
	'Verbar;': 8214,
	'Vvdash;': 8874,
	'Yacute;': 221,
	'Zacute;': 377,
	'Zcaron;': 381,
	'aacute;': 225,
	'abreve;': 259,
	'agrave;': 224,
	'andand;': 10837,
	'angmsd;': 8737,
	'angsph;': 8738,
	'apacir;': 10863,
	'approx;': 8776,
	'atilde;': 227,
	'barvee;': 8893,
	'barwed;': 8965,
	'becaus;': 8757,
	'bernou;': 8492,
	'bigcap;': 8898,
	'bigcup;': 8899,
	'bigvee;': 8897,
	'bkarow;': 10509,
	'bottom;': 8869,
	'bowtie;': 8904,
	'boxbox;': 10697,
	'bprime;': 8245,
	'brvbar;': 166,
	'bullet;': 8226,
	'bumpeq;': 8783,
	'cacute;': 263,
	'capand;': 10820,
	'capcap;': 10827,
	'capcup;': 10823,
	'capdot;': 10816,
	'ccaron;': 269,
	'ccedil;': 231,
	'circeq;': 8791,
	'cirmid;': 10991,
	'colone;': 8788,
	'commat;': 64,
	'compfn;': 8728,
	'conint;': 8750,
	'coprod;': 8720,
	'copysr;': 8471,
	'cularr;': 8630,
	'cupcap;': 10822,
	'cupcup;': 10826,
	'cupdot;': 8845,
	'curarr;': 8631,
	'curren;': 164,
	'cylcty;': 9005,
	'dagger;': 8224,
	'daleth;': 8504,
	'dcaron;': 271,
	'dfisht;': 10623,
	'divide;': 247,
	'divonx;': 8903,
	'dlcorn;': 8990,
	'dlcrop;': 8973,
	'dollar;': 36,
	'drcorn;': 8991,
	'drcrop;': 8972,
	'dstrok;': 273,
	'eacute;': 233,
	'easter;': 10862,
	'ecaron;': 283,
	'ecolon;': 8789,
	'egrave;': 232,
	'egsdot;': 10904,
	'elsdot;': 10903,
	'emptyv;': 8709,
	'emsp13;': 8196,
	'emsp14;': 8197,
	'eparsl;': 10723,
	'eqcirc;': 8790,
	'equals;': 61,
	'equest;': 8799,
	'female;': 9792,
	'ffilig;': 64259,
	'ffllig;': 64260,
	'forall;': 8704,
	'frac12;': 189,
	'frac13;': 8531,
	'frac14;': 188,
	'frac15;': 8533,
	'frac16;': 8537,
	'frac18;': 8539,
	'frac23;': 8532,
	'frac25;': 8534,
	'frac34;': 190,
	'frac35;': 8535,
	'frac38;': 8540,
	'frac45;': 8536,
	'frac56;': 8538,
	'frac58;': 8541,
	'frac78;': 8542,
	'gacute;': 501,
	'gammad;': 989,
	'gbreve;': 287,
	'gesdot;': 10880,
	'gesles;': 10900,
	'gtlPar;': 10645,
	'gtrarr;': 10616,
	'gtrdot;': 8919,
	'gtrsim;': 8819,
	'hairsp;': 8202,
	'hamilt;': 8459,
	'hardcy;': 1098,
	'hearts;': 9829,
	'hellip;': 8230,
	'hercon;': 8889,
	'homtht;': 8763,
	'horbar;': 8213,
	'hslash;': 8463,
	'hstrok;': 295,
	'hybull;': 8259,
	'hyphen;': 8208,
	'iacute;': 237,
	'igrave;': 236,
	'iiiint;': 10764,
	'iinfin;': 10716,
	'incare;': 8453,
	'inodot;': 305,
	'intcal;': 8890,
	'iquest;': 191,
	'isinsv;': 8947,
	'itilde;': 297,
	'jsercy;': 1112,
	'kappav;': 1008,
	'kcedil;': 311,
	'kgreen;': 312,
	'lAtail;': 10523,
	'lacute;': 314,
	'lagran;': 8466,
	'lambda;': 955,
	'langle;': 10216,
	'larrfs;': 10525,
	'larrhk;': 8617,
	'larrlp;': 8619,
	'larrpl;': 10553,
	'larrtl;': 8610,
	'latail;': 10521,
	'lbrace;': 123,
	'lbrack;': 91,
	'lcaron;': 318,
	'lcedil;': 316,
	'ldquor;': 8222,
	'lesdot;': 10879,
	'lesges;': 10899,
	'lfisht;': 10620,
	'lfloor;': 8970,
	'lharul;': 10602,
	'llhard;': 10603,
	'lmidot;': 320,
	'lmoust;': 9136,
	'loplus;': 10797,
	'lowast;': 8727,
	'lowbar;': 95,
	'lparlt;': 10643,
	'lrhard;': 10605,
	'lsaquo;': 8249,
	'lsquor;': 8218,
	'lstrok;': 322,
	'lthree;': 8907,
	'ltimes;': 8905,
	'ltlarr;': 10614,
	'ltrPar;': 10646,
	'mapsto;': 8614,
	'marker;': 9646,
	'mcomma;': 10793,
	'midast;': 42,
	'midcir;': 10992,
	'middot;': 183,
	'minusb;': 8863,
	'minusd;': 8760,
	'mnplus;': 8723,
	'models;': 8871,
	'mstpos;': 8766,
	'nVDash;': 8879,
	'nVdash;': 8878,
	'nacute;': 324,
	'nbumpe;': 8783,
	'ncaron;': 328,
	'ncedil;': 326,
	'nearhk;': 10532,
	'nequiv;': 8802,
	'nesear;': 10536,
	'nexist;': 8708,
	'nltrie;': 8940,
	'notinE;': 8953,
	'nparsl;': 11005,
	'nprcue;': 8928,
	'nrarrc;': 10547,
	'nrarrw;': 8605,
	'nrtrie;': 8941,
	'nsccue;': 8929,
	'nsimeq;': 8772,
	'ntilde;': 241,
	'numero;': 8470,
	'nvDash;': 8877,
	'nvHarr;': 10500,
	'nvdash;': 8876,
	'nvlArr;': 10498,
	'nvrArr;': 10499,
	'nwarhk;': 10531,
	'nwnear;': 10535,
	'oacute;': 243,
	'odblac;': 337,
	'odsold;': 10684,
	'ograve;': 242,
	'ominus;': 8854,
	'origof;': 8886,
	'oslash;': 248,
	'otilde;': 245,
	'otimes;': 8855,
	'parsim;': 10995,
	'percnt;': 37,
	'period;': 46,
	'permil;': 8240,
	'phmmat;': 8499,
	'planck;': 8463,
	'plankv;': 8463,
	'plusdo;': 8724,
	'plusdu;': 10789,
	'plusmn;': 177,
	'preceq;': 10927,
	'primes;': 8473,
	'prnsim;': 8936,
	'propto;': 8733,
	'prurel;': 8880,
	'puncsp;': 8200,
	'qprime;': 8279,
	'rAtail;': 10524,
	'racute;': 341,
	'rangle;': 10217,
	'rarrap;': 10613,
	'rarrfs;': 10526,
	'rarrhk;': 8618,
	'rarrlp;': 8620,
	'rarrpl;': 10565,
	'rarrtl;': 8611,
	'ratail;': 10522,
	'rbrace;': 125,
	'rbrack;': 93,
	'rcaron;': 345,
	'rcedil;': 343,
	'rdquor;': 8221,
	'rfisht;': 10621,
	'rfloor;': 8971,
	'rharul;': 10604,
	'rmoust;': 9137,
	'roplus;': 10798,
	'rpargt;': 10644,
	'rsaquo;': 8250,
	'rsquor;': 8217,
	'rthree;': 8908,
	'rtimes;': 8906,
	'sacute;': 347,
	'scaron;': 353,
	'scedil;': 351,
	'scnsim;': 8937,
	'searhk;': 10533,
	'seswar;': 10537,
	'sfrown;': 8994,
	'shchcy;': 1097,
	'sigmaf;': 962,
	'sigmav;': 962,
	'simdot;': 10858,
	'smashp;': 10803,
	'softcy;': 1100,
	'solbar;': 9023,
	'spades;': 9824,
	'sqcaps;': 8851,
	'sqcups;': 8852,
	'sqsube;': 8849,
	'sqsupe;': 8850,
	'square;': 9633,
	'squarf;': 9642,
	'ssetmn;': 8726,
	'ssmile;': 8995,
	'sstarf;': 8902,
	'subdot;': 10941,
	'subset;': 8834,
	'subsim;': 10951,
	'subsub;': 10965,
	'subsup;': 10963,
	'succeq;': 10928,
	'supdot;': 10942,
	'supset;': 8835,
	'supsim;': 10952,
	'supsub;': 10964,
	'supsup;': 10966,
	'swarhk;': 10534,
	'swnwar;': 10538,
	'target;': 8982,
	'tcaron;': 357,
	'tcedil;': 355,
	'telrec;': 8981,
	'there4;': 8756,
	'thetav;': 977,
	'thinsp;': 8201,
	'thksim;': 8764,
	'timesb;': 8864,
	'timesd;': 10800,
	'topbot;': 9014,
	'topcir;': 10993,
	'tprime;': 8244,
	'tridot;': 9708,
	'tstrok;': 359,
	'uacute;': 250,
	'ubreve;': 365,
	'udblac;': 369,
	'ufisht;': 10622,
	'ugrave;': 249,
	'ulcorn;': 8988,
	'ulcrop;': 8975,
	'urcorn;': 8989,
	'urcrop;': 8974,
	'utilde;': 361,
	'vangrt;': 10652,
	'varphi;': 981,
	'varrho;': 1009,
	'veebar;': 8891,
	'vellip;': 8942,
	'verbar;': 124,
	'vsubnE;': 10955,
	'vsubne;': 8842,
	'vsupnE;': 10956,
	'vsupne;': 8843,
	'wedbar;': 10847,
	'wedgeq;': 8793,
	'weierp;': 8472,
	'wreath;': 8768,
	'xoplus;': 10753,
	'xotime;': 10754,
	'xsqcup;': 10758,
	'xuplus;': 10756,
	'xwedge;': 8896,
	'yacute;': 253,
	'zacute;': 378,
	'zcaron;': 382,
	'zeetrf;': 8488,
	'AElig;': 198,
	Aacute: 193,
	'Acirc;': 194,
	Agrave: 192,
	'Alpha;': 913,
	'Amacr;': 256,
	'Aogon;': 260,
	'Aring;': 197,
	Atilde: 195,
	'Breve;': 728,
	Ccedil: 199,
	'Ccirc;': 264,
	'Colon;': 8759,
	'Cross;': 10799,
	'Dashv;': 10980,
	'Delta;': 916,
	Eacute: 201,
	'Ecirc;': 202,
	Egrave: 200,
	'Emacr;': 274,
	'Eogon;': 280,
	'Equal;': 10869,
	'Gamma;': 915,
	'Gcirc;': 284,
	'Hacek;': 711,
	'Hcirc;': 292,
	'IJlig;': 306,
	Iacute: 205,
	'Icirc;': 206,
	Igrave: 204,
	'Imacr;': 298,
	'Iogon;': 302,
	'Iukcy;': 1030,
	'Jcirc;': 308,
	'Jukcy;': 1028,
	'Kappa;': 922,
	Ntilde: 209,
	'OElig;': 338,
	Oacute: 211,
	'Ocirc;': 212,
	Ograve: 210,
	'Omacr;': 332,
	'Omega;': 937,
	Oslash: 216,
	Otilde: 213,
	'Prime;': 8243,
	'RBarr;': 10512,
	'Scirc;': 348,
	'Sigma;': 931,
	'THORN;': 222,
	'TRADE;': 8482,
	'TSHcy;': 1035,
	'Theta;': 920,
	'Tilde;': 8764,
	Uacute: 218,
	'Ubrcy;': 1038,
	'Ucirc;': 219,
	Ugrave: 217,
	'Umacr;': 362,
	'Union;': 8899,
	'Uogon;': 370,
	'UpTee;': 8869,
	'Uring;': 366,
	'VDash;': 8875,
	'Vdash;': 8873,
	'Wcirc;': 372,
	'Wedge;': 8896,
	Yacute: 221,
	'Ycirc;': 374,
	aacute: 225,
	'acirc;': 226,
	'acute;': 180,
	'aelig;': 230,
	agrave: 224,
	'aleph;': 8501,
	'alpha;': 945,
	'amacr;': 257,
	'amalg;': 10815,
	'angle;': 8736,
	'angrt;': 8735,
	'angst;': 197,
	'aogon;': 261,
	'aring;': 229,
	'asymp;': 8776,
	atilde: 227,
	'awint;': 10769,
	'bcong;': 8780,
	'bdquo;': 8222,
	'bepsi;': 1014,
	'blank;': 9251,
	'blk12;': 9618,
	'blk14;': 9617,
	'blk34;': 9619,
	'block;': 9608,
	'boxDL;': 9559,
	'boxDR;': 9556,
	'boxDl;': 9558,
	'boxDr;': 9555,
	'boxHD;': 9574,
	'boxHU;': 9577,
	'boxHd;': 9572,
	'boxHu;': 9575,
	'boxUL;': 9565,
	'boxUR;': 9562,
	'boxUl;': 9564,
	'boxUr;': 9561,
	'boxVH;': 9580,
	'boxVL;': 9571,
	'boxVR;': 9568,
	'boxVh;': 9579,
	'boxVl;': 9570,
	'boxVr;': 9567,
	'boxdL;': 9557,
	'boxdR;': 9554,
	'boxdl;': 9488,
	'boxdr;': 9484,
	'boxhD;': 9573,
	'boxhU;': 9576,
	'boxhd;': 9516,
	'boxhu;': 9524,
	'boxuL;': 9563,
	'boxuR;': 9560,
	'boxul;': 9496,
	'boxur;': 9492,
	'boxvH;': 9578,
	'boxvL;': 9569,
	'boxvR;': 9566,
	'boxvh;': 9532,
	'boxvl;': 9508,
	'boxvr;': 9500,
	'breve;': 728,
	brvbar: 166,
	'bsemi;': 8271,
	'bsime;': 8909,
	'bsolb;': 10693,
	'bumpE;': 10926,
	'bumpe;': 8783,
	'caret;': 8257,
	'caron;': 711,
	'ccaps;': 10829,
	ccedil: 231,
	'ccirc;': 265,
	'ccups;': 10828,
	'cedil;': 184,
	'check;': 10003,
	'clubs;': 9827,
	'colon;': 58,
	'comma;': 44,
	'crarr;': 8629,
	'cross;': 10007,
	'csube;': 10961,
	'csupe;': 10962,
	'ctdot;': 8943,
	'cuepr;': 8926,
	'cuesc;': 8927,
	'cupor;': 10821,
	curren: 164,
	'cuvee;': 8910,
	'cuwed;': 8911,
	'cwint;': 8753,
	'dashv;': 8867,
	'dblac;': 733,
	'ddarr;': 8650,
	'delta;': 948,
	'dharl;': 8643,
	'dharr;': 8642,
	'diams;': 9830,
	'disin;': 8946,
	divide: 247,
	'doteq;': 8784,
	'dtdot;': 8945,
	'dtrif;': 9662,
	'duarr;': 8693,
	'duhar;': 10607,
	'eDDot;': 10871,
	eacute: 233,
	'ecirc;': 234,
	'efDot;': 8786,
	egrave: 232,
	'emacr;': 275,
	'empty;': 8709,
	'eogon;': 281,
	'eplus;': 10865,
	'epsiv;': 1013,
	'eqsim;': 8770,
	'equiv;': 8801,
	'erDot;': 8787,
	'erarr;': 10609,
	'esdot;': 8784,
	'exist;': 8707,
	'fflig;': 64256,
	'filig;': 64257,
	'fjlig;': 102,
	'fllig;': 64258,
	'fltns;': 9649,
	'forkv;': 10969,
	frac12: 189,
	frac14: 188,
	frac34: 190,
	'frasl;': 8260,
	'frown;': 8994,
	'gamma;': 947,
	'gcirc;': 285,
	'gescc;': 10921,
	'gimel;': 8503,
	'gneqq;': 8809,
	'gnsim;': 8935,
	'grave;': 96,
	'gsime;': 10894,
	'gsiml;': 10896,
	'gtcir;': 10874,
	'gtdot;': 8919,
	'harrw;': 8621,
	'hcirc;': 293,
	'hoarr;': 8703,
	iacute: 237,
	'icirc;': 238,
	'iexcl;': 161,
	igrave: 236,
	'iiint;': 8749,
	'iiota;': 8489,
	'ijlig;': 307,
	'imacr;': 299,
	'image;': 8465,
	'imath;': 305,
	'imped;': 437,
	'infin;': 8734,
	'iogon;': 303,
	'iprod;': 10812,
	iquest: 191,
	'isinE;': 8953,
	'isins;': 8948,
	'isinv;': 8712,
	'iukcy;': 1110,
	'jcirc;': 309,
	'jmath;': 567,
	'jukcy;': 1108,
	'kappa;': 954,
	'lAarr;': 8666,
	'lBarr;': 10510,
	'langd;': 10641,
	'laquo;': 171,
	'larrb;': 8676,
	'lates;': 10925,
	'lbarr;': 10508,
	'lbbrk;': 10098,
	'lbrke;': 10635,
	'lceil;': 8968,
	'ldquo;': 8220,
	'lescc;': 10920,
	'lhard;': 8637,
	'lharu;': 8636,
	'lhblk;': 9604,
	'llarr;': 8647,
	'lltri;': 9722,
	'lneqq;': 8808,
	'lnsim;': 8934,
	'loang;': 10220,
	'loarr;': 8701,
	'lobrk;': 10214,
	'lopar;': 10629,
	'lrarr;': 8646,
	'lrhar;': 8651,
	'lrtri;': 8895,
	'lsime;': 10893,
	'lsimg;': 10895,
	'lsquo;': 8216,
	'ltcir;': 10873,
	'ltdot;': 8918,
	'ltrie;': 8884,
	'ltrif;': 9666,
	'mDDot;': 8762,
	'mdash;': 8212,
	'micro;': 181,
	middot: 183,
	'minus;': 8722,
	'mumap;': 8888,
	'nabla;': 8711,
	'napid;': 8779,
	'napos;': 329,
	'natur;': 9838,
	'nbump;': 8782,
	'ncong;': 8775,
	'ndash;': 8211,
	'neArr;': 8663,
	'nearr;': 8599,
	'nedot;': 8784,
	'nesim;': 8770,
	'ngeqq;': 8807,
	'ngsim;': 8821,
	'nhArr;': 8654,
	'nharr;': 8622,
	'nhpar;': 10994,
	'nlArr;': 8653,
	'nlarr;': 8602,
	'nleqq;': 8806,
	'nless;': 8814,
	'nlsim;': 8820,
	'nltri;': 8938,
	'notin;': 8713,
	'notni;': 8716,
	'npart;': 8706,
	'nprec;': 8832,
	'nrArr;': 8655,
	'nrarr;': 8603,
	'nrtri;': 8939,
	'nsime;': 8772,
	'nsmid;': 8740,
	'nspar;': 8742,
	'nsubE;': 10949,
	'nsube;': 8840,
	'nsucc;': 8833,
	'nsupE;': 10950,
	'nsupe;': 8841,
	ntilde: 241,
	'numsp;': 8199,
	'nvsim;': 8764,
	'nwArr;': 8662,
	'nwarr;': 8598,
	oacute: 243,
	'ocirc;': 244,
	'odash;': 8861,
	'oelig;': 339,
	'ofcir;': 10687,
	ograve: 242,
	'ohbar;': 10677,
	'olarr;': 8634,
	'olcir;': 10686,
	'oline;': 8254,
	'omacr;': 333,
	'omega;': 969,
	'operp;': 10681,
	'oplus;': 8853,
	'orarr;': 8635,
	'order;': 8500,
	oslash: 248,
	otilde: 245,
	'ovbar;': 9021,
	'parsl;': 11005,
	'phone;': 9742,
	'plusb;': 8862,
	'pluse;': 10866,
	plusmn: 177,
	'pound;': 163,
	'prcue;': 8828,
	'prime;': 8242,
	'prnap;': 10937,
	'prsim;': 8830,
	'quest;': 63,
	'rAarr;': 8667,
	'rBarr;': 10511,
	'radic;': 8730,
	'rangd;': 10642,
	'range;': 10661,
	'raquo;': 187,
	'rarrb;': 8677,
	'rarrc;': 10547,
	'rarrw;': 8605,
	'ratio;': 8758,
	'rbarr;': 10509,
	'rbbrk;': 10099,
	'rbrke;': 10636,
	'rceil;': 8969,
	'rdquo;': 8221,
	'reals;': 8477,
	'rhard;': 8641,
	'rharu;': 8640,
	'rlarr;': 8644,
	'rlhar;': 8652,
	'rnmid;': 10990,
	'roang;': 10221,
	'roarr;': 8702,
	'robrk;': 10215,
	'ropar;': 10630,
	'rrarr;': 8649,
	'rsquo;': 8217,
	'rtrie;': 8885,
	'rtrif;': 9656,
	'sbquo;': 8218,
	'sccue;': 8829,
	'scirc;': 349,
	'scnap;': 10938,
	'scsim;': 8831,
	'sdotb;': 8865,
	'sdote;': 10854,
	'seArr;': 8664,
	'searr;': 8600,
	'setmn;': 8726,
	'sharp;': 9839,
	'sigma;': 963,
	'simeq;': 8771,
	'simgE;': 10912,
	'simlE;': 10911,
	'simne;': 8774,
	'slarr;': 8592,
	'smile;': 8995,
	'smtes;': 10924,
	'sqcap;': 8851,
	'sqcup;': 8852,
	'sqsub;': 8847,
	'sqsup;': 8848,
	'srarr;': 8594,
	'starf;': 9733,
	'strns;': 175,
	'subnE;': 10955,
	'subne;': 8842,
	'supnE;': 10956,
	'supne;': 8843,
	'swArr;': 8665,
	'swarr;': 8601,
	'szlig;': 223,
	'theta;': 952,
	'thkap;': 8776,
	'thorn;': 254,
	'tilde;': 732,
	'times;': 215,
	'trade;': 8482,
	'trisb;': 10701,
	'tshcy;': 1115,
	'twixt;': 8812,
	uacute: 250,
	'ubrcy;': 1118,
	'ucirc;': 251,
	'udarr;': 8645,
	'udhar;': 10606,
	ugrave: 249,
	'uharl;': 8639,
	'uharr;': 8638,
	'uhblk;': 9600,
	'ultri;': 9720,
	'umacr;': 363,
	'uogon;': 371,
	'uplus;': 8846,
	'upsih;': 978,
	'uring;': 367,
	'urtri;': 9721,
	'utdot;': 8944,
	'utrif;': 9652,
	'uuarr;': 8648,
	'vBarv;': 10985,
	'vDash;': 8872,
	'varpi;': 982,
	'vdash;': 8866,
	'veeeq;': 8794,
	'vltri;': 8882,
	'vnsub;': 8834,
	'vnsup;': 8835,
	'vprop;': 8733,
	'vrtri;': 8883,
	'wcirc;': 373,
	'wedge;': 8743,
	'xcirc;': 9711,
	'xdtri;': 9661,
	'xhArr;': 10234,
	'xharr;': 10231,
	'xlArr;': 10232,
	'xlarr;': 10229,
	'xodot;': 10752,
	'xrArr;': 10233,
	'xrarr;': 10230,
	'xutri;': 9651,
	yacute: 253,
	'ycirc;': 375,
	AElig: 198,
	Acirc: 194,
	'Aopf;': 120120,
	Aring: 197,
	'Ascr;': 119964,
	'Auml;': 196,
	'Barv;': 10983,
	'Beta;': 914,
	'Bopf;': 120121,
	'Bscr;': 8492,
	'CHcy;': 1063,
	'COPY;': 169,
	'Cdot;': 266,
	'Copf;': 8450,
	'Cscr;': 119966,
	'DJcy;': 1026,
	'DScy;': 1029,
	'DZcy;': 1039,
	'Darr;': 8609,
	'Dopf;': 120123,
	'Dscr;': 119967,
	Ecirc: 202,
	'Edot;': 278,
	'Eopf;': 120124,
	'Escr;': 8496,
	'Esim;': 10867,
	'Euml;': 203,
	'Fopf;': 120125,
	'Fscr;': 8497,
	'GJcy;': 1027,
	'Gdot;': 288,
	'Gopf;': 120126,
	'Gscr;': 119970,
	'Hopf;': 8461,
	'Hscr;': 8459,
	'IEcy;': 1045,
	'IOcy;': 1025,
	Icirc: 206,
	'Idot;': 304,
	'Iopf;': 120128,
	'Iota;': 921,
	'Iscr;': 8464,
	'Iuml;': 207,
	'Jopf;': 120129,
	'Jscr;': 119973,
	'KHcy;': 1061,
	'KJcy;': 1036,
	'Kopf;': 120130,
	'Kscr;': 119974,
	'LJcy;': 1033,
	'Lang;': 10218,
	'Larr;': 8606,
	'Lopf;': 120131,
	'Lscr;': 8466,
	'Mopf;': 120132,
	'Mscr;': 8499,
	'NJcy;': 1034,
	'Nopf;': 8469,
	'Nscr;': 119977,
	Ocirc: 212,
	'Oopf;': 120134,
	'Oscr;': 119978,
	'Ouml;': 214,
	'Popf;': 8473,
	'Pscr;': 119979,
	'QUOT;': 34,
	'Qopf;': 8474,
	'Qscr;': 119980,
	'Rang;': 10219,
	'Rarr;': 8608,
	'Ropf;': 8477,
	'Rscr;': 8475,
	'SHcy;': 1064,
	'Sopf;': 120138,
	'Sqrt;': 8730,
	'Sscr;': 119982,
	'Star;': 8902,
	THORN: 222,
	'TScy;': 1062,
	'Topf;': 120139,
	'Tscr;': 119983,
	'Uarr;': 8607,
	Ucirc: 219,
	'Uopf;': 120140,
	'Upsi;': 978,
	'Uscr;': 119984,
	'Uuml;': 220,
	'Vbar;': 10987,
	'Vert;': 8214,
	'Vopf;': 120141,
	'Vscr;': 119985,
	'Wopf;': 120142,
	'Wscr;': 119986,
	'Xopf;': 120143,
	'Xscr;': 119987,
	'YAcy;': 1071,
	'YIcy;': 1031,
	'YUcy;': 1070,
	'Yopf;': 120144,
	'Yscr;': 119988,
	'Yuml;': 376,
	'ZHcy;': 1046,
	'Zdot;': 379,
	'Zeta;': 918,
	'Zopf;': 8484,
	'Zscr;': 119989,
	acirc: 226,
	acute: 180,
	aelig: 230,
	'andd;': 10844,
	'andv;': 10842,
	'ange;': 10660,
	'aopf;': 120146,
	'apid;': 8779,
	'apos;': 39,
	aring: 229,
	'ascr;': 119990,
	'auml;': 228,
	'bNot;': 10989,
	'bbrk;': 9141,
	'beta;': 946,
	'beth;': 8502,
	'bnot;': 8976,
	'bopf;': 120147,
	'boxH;': 9552,
	'boxV;': 9553,
	'boxh;': 9472,
	'boxv;': 9474,
	'bscr;': 119991,
	'bsim;': 8765,
	'bsol;': 92,
	'bull;': 8226,
	'bump;': 8782,
	'caps;': 8745,
	'cdot;': 267,
	cedil: 184,
	'cent;': 162,
	'chcy;': 1095,
	'cirE;': 10691,
	'circ;': 710,
	'cire;': 8791,
	'comp;': 8705,
	'cong;': 8773,
	'copf;': 120148,
	'copy;': 169,
	'cscr;': 119992,
	'csub;': 10959,
	'csup;': 10960,
	'cups;': 8746,
	'dArr;': 8659,
	'dHar;': 10597,
	'darr;': 8595,
	'dash;': 8208,
	'diam;': 8900,
	'djcy;': 1106,
	'dopf;': 120149,
	'dscr;': 119993,
	'dscy;': 1109,
	'dsol;': 10742,
	'dtri;': 9663,
	'dzcy;': 1119,
	'eDot;': 8785,
	'ecir;': 8790,
	ecirc: 234,
	'edot;': 279,
	'emsp;': 8195,
	'ensp;': 8194,
	'eopf;': 120150,
	'epar;': 8917,
	'epsi;': 949,
	'escr;': 8495,
	'esim;': 8770,
	'euml;': 235,
	'euro;': 8364,
	'excl;': 33,
	'flat;': 9837,
	'fnof;': 402,
	'fopf;': 120151,
	'fork;': 8916,
	'fscr;': 119995,
	'gdot;': 289,
	'geqq;': 8807,
	'gesl;': 8923,
	'gjcy;': 1107,
	'gnap;': 10890,
	'gneq;': 10888,
	'gopf;': 120152,
	'gscr;': 8458,
	'gsim;': 8819,
	'gtcc;': 10919,
	'gvnE;': 8809,
	'hArr;': 8660,
	'half;': 189,
	'harr;': 8596,
	'hbar;': 8463,
	'hopf;': 120153,
	'hscr;': 119997,
	icirc: 238,
	'iecy;': 1077,
	iexcl: 161,
	'imof;': 8887,
	'iocy;': 1105,
	'iopf;': 120154,
	'iota;': 953,
	'iscr;': 119998,
	'isin;': 8712,
	'iuml;': 239,
	'jopf;': 120155,
	'jscr;': 119999,
	'khcy;': 1093,
	'kjcy;': 1116,
	'kopf;': 120156,
	'kscr;': 120000,
	'lArr;': 8656,
	'lHar;': 10594,
	'lang;': 10216,
	laquo: 171,
	'larr;': 8592,
	'late;': 10925,
	'lcub;': 123,
	'ldca;': 10550,
	'ldsh;': 8626,
	'leqq;': 8806,
	'lesg;': 8922,
	'ljcy;': 1113,
	'lnap;': 10889,
	'lneq;': 10887,
	'lopf;': 120157,
	'lozf;': 10731,
	'lpar;': 40,
	'lscr;': 120001,
	'lsim;': 8818,
	'lsqb;': 91,
	'ltcc;': 10918,
	'ltri;': 9667,
	'lvnE;': 8808,
	'macr;': 175,
	'male;': 9794,
	'malt;': 10016,
	micro: 181,
	'mlcp;': 10971,
	'mldr;': 8230,
	'mopf;': 120158,
	'mscr;': 120002,
	'nGtv;': 8811,
	'nLtv;': 8810,
	'nang;': 8736,
	'napE;': 10864,
	'nbsp;': 160,
	'ncap;': 10819,
	'ncup;': 10818,
	'ngeq;': 8817,
	'nges;': 10878,
	'ngtr;': 8815,
	'nisd;': 8954,
	'njcy;': 1114,
	'nldr;': 8229,
	'nleq;': 8816,
	'nles;': 10877,
	'nmid;': 8740,
	'nopf;': 120159,
	'npar;': 8742,
	'npre;': 10927,
	'nsce;': 10928,
	'nscr;': 120003,
	'nsim;': 8769,
	'nsub;': 8836,
	'nsup;': 8837,
	'ntgl;': 8825,
	'ntlg;': 8824,
	'nvap;': 8781,
	'nvge;': 8805,
	'nvgt;': 62,
	'nvle;': 8804,
	'nvlt;': 60,
	'oast;': 8859,
	'ocir;': 8858,
	ocirc: 244,
	'odiv;': 10808,
	'odot;': 8857,
	'ogon;': 731,
	'oint;': 8750,
	'omid;': 10678,
	'oopf;': 120160,
	'opar;': 10679,
	'ordf;': 170,
	'ordm;': 186,
	'oror;': 10838,
	'oscr;': 8500,
	'osol;': 8856,
	'ouml;': 246,
	'para;': 182,
	'part;': 8706,
	'perp;': 8869,
	'phiv;': 981,
	'plus;': 43,
	'popf;': 120161,
	pound: 163,
	'prap;': 10935,
	'prec;': 8826,
	'prnE;': 10933,
	'prod;': 8719,
	'prop;': 8733,
	'pscr;': 120005,
	'qint;': 10764,
	'qopf;': 120162,
	'qscr;': 120006,
	'quot;': 34,
	'rArr;': 8658,
	'rHar;': 10596,
	'race;': 8765,
	'rang;': 10217,
	raquo: 187,
	'rarr;': 8594,
	'rcub;': 125,
	'rdca;': 10551,
	'rdsh;': 8627,
	'real;': 8476,
	'rect;': 9645,
	'rhov;': 1009,
	'ring;': 730,
	'ropf;': 120163,
	'rpar;': 41,
	'rscr;': 120007,
	'rsqb;': 93,
	'rtri;': 9657,
	'scap;': 10936,
	'scnE;': 10934,
	'sdot;': 8901,
	'sect;': 167,
	'semi;': 59,
	'sext;': 10038,
	'shcy;': 1096,
	'sime;': 8771,
	'simg;': 10910,
	'siml;': 10909,
	'smid;': 8739,
	'smte;': 10924,
	'solb;': 10692,
	'sopf;': 120164,
	'spar;': 8741,
	'squf;': 9642,
	'sscr;': 120008,
	'star;': 9734,
	'subE;': 10949,
	'sube;': 8838,
	'succ;': 8827,
	'sung;': 9834,
	'sup1;': 185,
	'sup2;': 178,
	'sup3;': 179,
	'supE;': 10950,
	'supe;': 8839,
	szlig: 223,
	'tbrk;': 9140,
	'tdot;': 8411,
	thorn: 254,
	times: 215,
	'tint;': 8749,
	'toea;': 10536,
	'topf;': 120165,
	'tosa;': 10537,
	'trie;': 8796,
	'tscr;': 120009,
	'tscy;': 1094,
	'uArr;': 8657,
	'uHar;': 10595,
	'uarr;': 8593,
	ucirc: 251,
	'uopf;': 120166,
	'upsi;': 965,
	'uscr;': 120010,
	'utri;': 9653,
	'uuml;': 252,
	'vArr;': 8661,
	'vBar;': 10984,
	'varr;': 8597,
	'vert;': 124,
	'vopf;': 120167,
	'vscr;': 120011,
	'wopf;': 120168,
	'wscr;': 120012,
	'xcap;': 8898,
	'xcup;': 8899,
	'xmap;': 10236,
	'xnis;': 8955,
	'xopf;': 120169,
	'xscr;': 120013,
	'xvee;': 8897,
	'yacy;': 1103,
	'yicy;': 1111,
	'yopf;': 120170,
	'yscr;': 120014,
	'yucy;': 1102,
	'yuml;': 255,
	'zdot;': 380,
	'zeta;': 950,
	'zhcy;': 1078,
	'zopf;': 120171,
	'zscr;': 120015,
	'zwnj;': 8204,
	'AMP;': 38,
	'Acy;': 1040,
	'Afr;': 120068,
	'And;': 10835,
	Auml: 196,
	'Bcy;': 1041,
	'Bfr;': 120069,
	COPY: 169,
	'Cap;': 8914,
	'Cfr;': 8493,
	'Chi;': 935,
	'Cup;': 8915,
	'Dcy;': 1044,
	'Del;': 8711,
	'Dfr;': 120071,
	'Dot;': 168,
	'ENG;': 330,
	'ETH;': 208,
	'Ecy;': 1069,
	'Efr;': 120072,
	'Eta;': 919,
	Euml: 203,
	'Fcy;': 1060,
	'Ffr;': 120073,
	'Gcy;': 1043,
	'Gfr;': 120074,
	'Hat;': 94,
	'Hfr;': 8460,
	'Icy;': 1048,
	'Ifr;': 8465,
	'Int;': 8748,
	Iuml: 207,
	'Jcy;': 1049,
	'Jfr;': 120077,
	'Kcy;': 1050,
	'Kfr;': 120078,
	'Lcy;': 1051,
	'Lfr;': 120079,
	'Lsh;': 8624,
	'Map;': 10501,
	'Mcy;': 1052,
	'Mfr;': 120080,
	'Ncy;': 1053,
	'Nfr;': 120081,
	'Not;': 10988,
	'Ocy;': 1054,
	'Ofr;': 120082,
	Ouml: 214,
	'Pcy;': 1055,
	'Pfr;': 120083,
	'Phi;': 934,
	'Psi;': 936,
	QUOT: 34,
	'Qfr;': 120084,
	'REG;': 174,
	'Rcy;': 1056,
	'Rfr;': 8476,
	'Rho;': 929,
	'Rsh;': 8625,
	'Scy;': 1057,
	'Sfr;': 120086,
	'Sub;': 8912,
	'Sum;': 8721,
	'Sup;': 8913,
	'Tab;': 9,
	'Tau;': 932,
	'Tcy;': 1058,
	'Tfr;': 120087,
	'Ucy;': 1059,
	'Ufr;': 120088,
	Uuml: 220,
	'Vcy;': 1042,
	'Vee;': 8897,
	'Vfr;': 120089,
	'Wfr;': 120090,
	'Xfr;': 120091,
	'Ycy;': 1067,
	'Yfr;': 120092,
	'Zcy;': 1047,
	'Zfr;': 8488,
	'acE;': 8766,
	'acd;': 8767,
	'acy;': 1072,
	'afr;': 120094,
	'amp;': 38,
	'and;': 8743,
	'ang;': 8736,
	'apE;': 10864,
	'ape;': 8778,
	'ast;': 42,
	auml: 228,
	'bcy;': 1073,
	'bfr;': 120095,
	'bne;': 61,
	'bot;': 8869,
	'cap;': 8745,
	cent: 162,
	'cfr;': 120096,
	'chi;': 967,
	'cir;': 9675,
	copy: 169,
	'cup;': 8746,
	'dcy;': 1076,
	'deg;': 176,
	'dfr;': 120097,
	'die;': 168,
	'div;': 247,
	'dot;': 729,
	'ecy;': 1101,
	'efr;': 120098,
	'egs;': 10902,
	'ell;': 8467,
	'els;': 10901,
	'eng;': 331,
	'eta;': 951,
	'eth;': 240,
	euml: 235,
	'fcy;': 1092,
	'ffr;': 120099,
	'gEl;': 10892,
	'gap;': 10886,
	'gcy;': 1075,
	'gel;': 8923,
	'geq;': 8805,
	'ges;': 10878,
	'gfr;': 120100,
	'ggg;': 8921,
	'glE;': 10898,
	'gla;': 10917,
	'glj;': 10916,
	'gnE;': 8809,
	'gne;': 10888,
	'hfr;': 120101,
	'icy;': 1080,
	'iff;': 8660,
	'ifr;': 120102,
	'int;': 8747,
	iuml: 239,
	'jcy;': 1081,
	'jfr;': 120103,
	'kcy;': 1082,
	'kfr;': 120104,
	'lEg;': 10891,
	'lap;': 10885,
	'lat;': 10923,
	'lcy;': 1083,
	'leg;': 8922,
	'leq;': 8804,
	'les;': 10877,
	'lfr;': 120105,
	'lgE;': 10897,
	'lnE;': 8808,
	'lne;': 10887,
	'loz;': 9674,
	'lrm;': 8206,
	'lsh;': 8624,
	macr: 175,
	'map;': 8614,
	'mcy;': 1084,
	'mfr;': 120106,
	'mho;': 8487,
	'mid;': 8739,
	'nGg;': 8921,
	'nGt;': 8811,
	'nLl;': 8920,
	'nLt;': 8810,
	'nap;': 8777,
	nbsp: 160,
	'ncy;': 1085,
	'nfr;': 120107,
	'ngE;': 8807,
	'nge;': 8817,
	'ngt;': 8815,
	'nis;': 8956,
	'niv;': 8715,
	'nlE;': 8806,
	'nle;': 8816,
	'nlt;': 8814,
	'not;': 172,
	'npr;': 8832,
	'nsc;': 8833,
	'num;': 35,
	'ocy;': 1086,
	'ofr;': 120108,
	'ogt;': 10689,
	'ohm;': 937,
	'olt;': 10688,
	'ord;': 10845,
	ordf: 170,
	ordm: 186,
	'orv;': 10843,
	ouml: 246,
	'par;': 8741,
	para: 182,
	'pcy;': 1087,
	'pfr;': 120109,
	'phi;': 966,
	'piv;': 982,
	'prE;': 10931,
	'pre;': 10927,
	'psi;': 968,
	'qfr;': 120110,
	quot: 34,
	'rcy;': 1088,
	'reg;': 174,
	'rfr;': 120111,
	'rho;': 961,
	'rlm;': 8207,
	'rsh;': 8625,
	'scE;': 10932,
	'sce;': 10928,
	'scy;': 1089,
	sect: 167,
	'sfr;': 120112,
	'shy;': 173,
	'sim;': 8764,
	'smt;': 10922,
	'sol;': 47,
	'squ;': 9633,
	'sub;': 8834,
	'sum;': 8721,
	sup1: 185,
	sup2: 178,
	sup3: 179,
	'sup;': 8835,
	'tau;': 964,
	'tcy;': 1090,
	'tfr;': 120113,
	'top;': 8868,
	'ucy;': 1091,
	'ufr;': 120114,
	'uml;': 168,
	uuml: 252,
	'vcy;': 1074,
	'vee;': 8744,
	'vfr;': 120115,
	'wfr;': 120116,
	'xfr;': 120117,
	'ycy;': 1099,
	'yen;': 165,
	'yfr;': 120118,
	yuml: 255,
	'zcy;': 1079,
	'zfr;': 120119,
	'zwj;': 8205,
	AMP: 38,
	'DD;': 8517,
	ETH: 208,
	'GT;': 62,
	'Gg;': 8921,
	'Gt;': 8811,
	'Im;': 8465,
	'LT;': 60,
	'Ll;': 8920,
	'Lt;': 8810,
	'Mu;': 924,
	'Nu;': 925,
	'Or;': 10836,
	'Pi;': 928,
	'Pr;': 10939,
	REG: 174,
	'Re;': 8476,
	'Sc;': 10940,
	'Xi;': 926,
	'ac;': 8766,
	'af;': 8289,
	amp: 38,
	'ap;': 8776,
	'dd;': 8518,
	deg: 176,
	'ee;': 8519,
	'eg;': 10906,
	'el;': 10905,
	eth: 240,
	'gE;': 8807,
	'ge;': 8805,
	'gg;': 8811,
	'gl;': 8823,
	'gt;': 62,
	'ic;': 8291,
	'ii;': 8520,
	'in;': 8712,
	'it;': 8290,
	'lE;': 8806,
	'le;': 8804,
	'lg;': 8822,
	'll;': 8810,
	'lt;': 60,
	'mp;': 8723,
	'mu;': 956,
	'ne;': 8800,
	'ni;': 8715,
	not: 172,
	'nu;': 957,
	'oS;': 9416,
	'or;': 8744,
	'pi;': 960,
	'pm;': 177,
	'pr;': 8826,
	reg: 174,
	'rx;': 8478,
	'sc;': 8827,
	shy: 173,
	uml: 168,
	'wp;': 8472,
	'wr;': 8768,
	'xi;': 958,
	yen: 165,
	GT: 62,
	LT: 60,
	gt: 62,
	lt: 60
};

const windows_1252 = [
	8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216,
	8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376
];

/**
 * @param {string} entity_name
 * @param {boolean} is_attribute_value
 */
function reg_exp_entity(entity_name, is_attribute_value) {
	// https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
	// doesn't decode the html entity which not ends with ; and next character is =, number or alphabet in attribute value.
	if (is_attribute_value && !entity_name.endsWith(';')) {
		return `${entity_name}\\b(?!=)`;
	}
	return entity_name;
}

/**
 * @param {boolean} is_attribute_value
 */
function get_entity_pattern(is_attribute_value) {
	const reg_exp_num = '#(?:x[a-fA-F\\d]+|\\d+)(?:;)?';
	const reg_exp_entities = Object.keys(entities$1).map((entity_name) =>
		reg_exp_entity(entity_name, is_attribute_value)
	);
	const entity_pattern = new RegExp(`&(${reg_exp_num}|${reg_exp_entities.join('|')})`, 'g');
	return entity_pattern;
}
const entity_pattern_content = get_entity_pattern(false);
const entity_pattern_attr_value = get_entity_pattern(true);

/**
 * @param {string} html
 * @param {boolean} is_attribute_value
 */
function decode_character_references(html, is_attribute_value) {
	const entity_pattern = is_attribute_value ? entity_pattern_attr_value : entity_pattern_content;
	return html.replace(entity_pattern, (match, entity) => {
		let code;
		// Handle named entities
		if (entity[0] !== '#') {
			code = entities$1[entity];
		} else if (entity[1] === 'x') {
			code = parseInt(entity.substring(2), 16);
		} else {
			code = parseInt(entity.substring(1), 10);
		}
		if (!code) {
			return match;
		}
		return String.fromCodePoint(validate_code(code));
	});
}
const NUL = 0;
// some code points are verboten. If we were inserting HTML, the browser would replace the illegal
// code points with alternatives in some cases - since we're bypassing that mechanism, we need
// to replace them ourselves
//
// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters

/**
 * @param {number} code
 */
function validate_code(code) {
	// line feed becomes generic whitespace
	if (code === 10) {
		return 32;
	}
	// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
	if (code < 128) {
		return code;
	}
	// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
	// to correct the mistake or we'll end up with missing € signs and so on
	if (code <= 159) {
		return windows_1252[code - 128];
	}
	// basic multilingual plane
	if (code < 55296) {
		return code;
	}
	// UTF-16 surrogate halves
	if (code <= 57343) {
		return NUL;
	}
	// rest of the basic multilingual plane
	if (code <= 65535) {
		return code;
	}
	// supplementary multilingual plane 0x10000 - 0x1ffff
	if (code >= 65536 && code <= 131071) {
		return code;
	}
	// supplementary ideographic plane 0x20000 - 0x2ffff
	if (code >= 131072 && code <= 196607) {
		return code;
	}
	return NUL;
}
// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
const disallowed_contents = new Map([
	['li', new Set(['li'])],
	['dt', new Set(['dt', 'dd'])],
	['dd', new Set(['dt', 'dd'])],
	[
		'p',
		new Set(
			'address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split(
				' '
			)
		)
	],
	['rt', new Set(['rt', 'rp'])],
	['rp', new Set(['rt', 'rp'])],
	['optgroup', new Set(['optgroup'])],
	['option', new Set(['option', 'optgroup'])],
	['thead', new Set(['tbody', 'tfoot'])],
	['tbody', new Set(['tbody', 'tfoot'])],
	['tfoot', new Set(['tbody'])],
	['tr', new Set(['tr', 'tbody'])],
	['td', new Set(['td', 'th', 'tr'])],
	['th', new Set(['td', 'th', 'tr'])]
]);
// can this be a child of the parent element, or does it implicitly
// close it, like `<li>one<li>two`?

/**
 * @param {string} current
 * @param {string} [next]
 */
function closing_tag_omitted(current, next) {
	if (disallowed_contents.has(current)) {
		if (!next || disallowed_contents.get(current).has(next)) {
			return true;
		}
	}
	return false;
}

// eslint-disable-next-line no-useless-escape
const valid_tag_name = /^\!?[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
/** Invalid attribute characters if the attribute is not surrounded by quotes */
const regex_starts_with_invalid_attr_value = /^(\/>|[\s"'=<>`])/;
const meta_tags = new Map([
	['svelte:head', 'Head'],
	['svelte:options', 'Options'],
	['svelte:window', 'Window'],
	['svelte:document', 'Document'],
	['svelte:body', 'Body']
]);
const valid_meta_tags = Array.from(meta_tags.keys()).concat(
	'svelte:self',
	'svelte:component',
	'svelte:fragment',
	'svelte:element'
);
const specials = new Map([
	[
		'script',
		{
			read: read_script,
			property: 'js'
		}
	],
	[
		'style',
		{
			read: read_style,
			property: 'css'
		}
	]
]);
const SELF = /^svelte:self(?=[\s/>])/;
const COMPONENT = /^svelte:component(?=[\s/>])/;
const SLOT = /^svelte:fragment(?=[\s/>])/;
const ELEMENT = /^svelte:element(?=[\s/>])/;
function parent_is_head(stack) {
	let i = stack.length;
	while (i--) {
		const { type } = stack[i];
		if (type === 'Head') return true;
		if (type === 'Element' || type === 'InlineComponent') return false;
	}
	return false;
}
const regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i;
const regex_closing_comment = /-->/;
const regex_capital_letter = /[A-Z]/;

/**
 * @param {import('../index.js').Parser} parser
 */
function tag$3(parser) {
	const start = parser.index++;
	let parent = parser.current();
	if (parser.eat('!--')) {
		const data = parser.read_until(regex_closing_comment);
		parser.eat('-->', true, parser_errors.unclosed_comment);
		parser.current().children.push({
			start,
			end: parser.index,
			type: 'Comment',
			data,
			ignores: extract_svelte_ignore(data)
		});
		return;
	}
	const is_closing_tag = parser.eat('/');
	const name = read_tag_name(parser);
	if (meta_tags.has(name)) {
		const slug = meta_tags.get(name).toLowerCase();
		if (is_closing_tag) {
			if (
				(name === 'svelte:window' || name === 'svelte:body') &&
				parser.current().children.length
			) {
				parser.error(
					parser_errors.invalid_element_content(slug, name),
					parser.current().children[0].start
				);
			}
		} else {
			if (name in parser.meta_tags) {
				parser.error(parser_errors.duplicate_element(slug, name), start);
			}
			if (parser.stack.length > 1) {
				parser.error(parser_errors.invalid_element_placement(slug, name), start);
			}
			parser.meta_tags[name] = true;
		}
	}
	const type = meta_tags.has(name)
		? meta_tags.get(name)
		: regex_capital_letter.test(name[0]) || name === 'svelte:self' || name === 'svelte:component'
		? 'InlineComponent'
		: name === 'svelte:fragment'
		? 'SlotTemplate'
		: name === 'title' && parent_is_head(parser.stack)
		? 'Title'
		: name === 'slot'
		? 'Slot'
		: 'Element';

	/**
	 * @type {import('../../interfaces.js').TemplateNode}
	 */
	const element = {
		start,
		end: null,
		type,
		name,
		attributes: [],
		children: []
	};
	parser.allow_whitespace();
	if (is_closing_tag) {
		if (is_void(name)) {
			parser.error(parser_errors.invalid_void_content(name), start);
		}
		parser.eat('>', true);
		// close any elements that don't have their own closing tags, e.g. <div><p></div>
		while (parent.name !== name) {
			if (parent.type !== 'Element') {
				const error =
					parser.last_auto_closed_tag && parser.last_auto_closed_tag.tag === name
						? parser_errors.invalid_closing_tag_autoclosed(name, parser.last_auto_closed_tag.reason)
						: parser_errors.invalid_closing_tag_unopened(name);
				parser.error(error, start);
			}
			parent.end = start;
			parser.stack.pop();
			parent = parser.current();
		}
		parent.end = parser.index;
		parser.stack.pop();
		if (parser.last_auto_closed_tag && parser.stack.length < parser.last_auto_closed_tag.depth) {
			parser.last_auto_closed_tag = null;
		}
		return;
	} else if (closing_tag_omitted(parent.name, name)) {
		parent.end = start;
		parser.stack.pop();
		parser.last_auto_closed_tag = {
			tag: parent.name,
			reason: name,
			depth: parser.stack.length
		};
	}

	/**
	 * @type {Set<string>}
	 */
	const unique_names = new Set();
	let attribute;
	while ((attribute = read_attribute(parser, unique_names))) {
		element.attributes.push(attribute);
		parser.allow_whitespace();
	}
	if (name === 'svelte:component') {
		const index = element.attributes.findIndex(
			(attr) => attr.type === 'Attribute' && attr.name === 'this'
		);
		if (index === -1) {
			parser.error(parser_errors.missing_component_definition, start);
		}
		const definition = element.attributes.splice(index, 1)[0];
		if (
			definition.value === true ||
			definition.value.length !== 1 ||
			definition.value[0].type === 'Text'
		) {
			parser.error(parser_errors.invalid_component_definition, definition.start);
		}
		element.expression = definition.value[0].expression;
	}
	if (name === 'svelte:element') {
		const index = element.attributes.findIndex(
			(attr) => attr.type === 'Attribute' && attr.name === 'this'
		);
		if (index === -1) {
			parser.error(parser_errors.missing_element_definition, start);
		}
		const definition = element.attributes.splice(index, 1)[0];
		if (definition.value === true) {
			parser.error(parser_errors.invalid_element_definition, definition.start);
		}
		element.tag = definition.value[0].data || definition.value[0].expression;
	}
	// special cases – top-level <script> and <style>
	if (specials.has(name) && parser.stack.length === 1) {
		const special = specials.get(name);
		parser.eat('>', true);
		const content = special.read(parser, start, element.attributes);
		if (content) parser[special.property].push(content);
		return;
	}
	parser.current().children.push(element);
	const self_closing = parser.eat('/') || is_void(name);
	parser.eat('>', true);
	if (self_closing) {
		// don't push self-closing elements onto the stack
		element.end = parser.index;
	} else if (name === 'textarea') {
		// special case
		element.children = read_sequence(
			parser,
			() => regex_closing_textarea_tag.test(parser.template.slice(parser.index)),
			'inside <textarea>'
		);
		parser.read(regex_closing_textarea_tag);
		element.end = parser.index;
	} else if (name === 'script' || name === 'style') {
		// special case
		const start = parser.index;
		const data = parser.read_until(new RegExp(`</${name}>`));
		const end = parser.index;
		element.children.push({ start, end, type: 'Text', data });
		parser.eat(`</${name}>`, true);
		element.end = parser.index;
	} else {
		parser.stack.push(element);
	}
}
const regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/;

/**
 * @param {import('../index.js').Parser} parser
 */
function read_tag_name(parser) {
	const start = parser.index;
	if (parser.read(SELF)) {
		// check we're inside a block, otherwise this
		// will cause infinite recursion
		let i = parser.stack.length;
		let legal = false;
		while (i--) {
			const fragment = parser.stack[i];
			if (
				fragment.type === 'IfBlock' ||
				fragment.type === 'EachBlock' ||
				fragment.type === 'InlineComponent'
			) {
				legal = true;
				break;
			}
		}
		if (!legal) {
			parser.error(parser_errors.invalid_self_placement, start);
		}
		return 'svelte:self';
	}
	if (parser.read(COMPONENT)) return 'svelte:component';
	if (parser.read(ELEMENT)) return 'svelte:element';
	if (parser.read(SLOT)) return 'svelte:fragment';
	const name = parser.read_until(regex_whitespace_or_slash_or_closing_tag);
	if (meta_tags.has(name)) return name;
	if (name.startsWith('svelte:')) {
		const match = fuzzymatch(name.slice(7), valid_meta_tags);
		parser.error(parser_errors.invalid_tag_name_svelte_element(valid_meta_tags, match), start);
	}
	if (!valid_tag_name.test(name)) {
		parser.error(parser_errors.invalid_tag_name, start);
	}
	return name;
}
// eslint-disable-next-line no-useless-escape
const regex_token_ending_character = /[\s=\/>"']/;
const regex_starts_with_quote_characters = /^["']/;

/**
 * @param {import('../index.js').Parser} parser
 * @param {Set<string>} unique_names
 */
function read_attribute(parser, unique_names) {
	const start = parser.index;

	/**
	 * @param {string} name
	 */
	function check_unique(name) {
		if (unique_names.has(name)) {
			parser.error(parser_errors.duplicate_attribute, start);
		}
		unique_names.add(name);
	}
	if (parser.eat('{')) {
		parser.allow_whitespace();
		if (parser.eat('...')) {
			const expression = read_expression(parser);
			parser.allow_whitespace();
			parser.eat('}', true);
			return {
				start,
				end: parser.index,
				type: 'Spread',
				expression
			};
		} else {
			const value_start = parser.index;
			const name = parser.read_identifier();
			parser.allow_whitespace();
			parser.eat('}', true);
			if (name === null) {
				parser.error(parser_errors.empty_attribute_shorthand, start);
			}
			check_unique(name);
			return {
				start,
				end: parser.index,
				type: 'Attribute',
				name,
				value: [
					{
						start: value_start,
						end: value_start + name.length,
						type: 'AttributeShorthand',
						expression: {
							start: value_start,
							end: value_start + name.length,
							type: 'Identifier',
							name
						}
					}
				]
			};
		}
	}
	const name = parser.read_until(regex_token_ending_character);
	if (!name) return null;
	let end = parser.index;
	parser.allow_whitespace();
	const colon_index = name.indexOf(':');
	const type = colon_index !== -1 && get_directive_type(name.slice(0, colon_index));

	/**
	 * @type {any[] | true}
	 */
	let value = true;
	if (parser.eat('=')) {
		parser.allow_whitespace();
		value = read_attribute_value(parser);
		end = parser.index;
	} else if (parser.match_regex(regex_starts_with_quote_characters)) {
		parser.error(parser_errors.unexpected_token('='), parser.index);
	}
	if (type) {
		const [directive_name, ...modifiers] = name.slice(colon_index + 1).split('|');
		if (directive_name === '') {
			parser.error(parser_errors.empty_directive_name(type), start + colon_index + 1);
		}
		if (type === 'Binding' && directive_name !== 'this') {
			check_unique(directive_name);
		} else if (type !== 'EventHandler' && type !== 'Action') {
			check_unique(name);
		}
		if (type === 'Ref') {
			parser.error(parser_errors.invalid_ref_directive(directive_name), start);
		}
		if (type === 'StyleDirective') {
			return {
				start,
				end,
				type,
				name: directive_name,
				modifiers,
				value
			};
		}
		const first_value = value[0];
		let expression = null;
		if (first_value) {
			const attribute_contains_text =
				/** @type {any[]} */ (value).length > 1 || first_value.type === 'Text';
			if (attribute_contains_text) {
				parser.error(parser_errors.invalid_directive_value, first_value.start);
			} else {
				expression = first_value.expression;
			}
		}
		const directive = {
			start,
			end,
			type,
			name: directive_name,
			modifiers,
			expression
		};
		if (type === 'Transition') {
			const direction = name.slice(0, colon_index);
			directive.intro = direction === 'in' || direction === 'transition';
			directive.outro = direction === 'out' || direction === 'transition';
		}
		// Directive name is expression, e.g. <p class:isRed />
		if (!directive.expression && (type === 'Binding' || type === 'Class')) {
			directive.expression = {
				start: directive.start + colon_index + 1,
				end: directive.end,
				type: 'Identifier',
				name: directive.name
			};
		}
		return directive;
	}
	check_unique(name);
	return {
		start,
		end,
		type: 'Attribute',
		name,
		value
	};
}

/**
 * @param {string} name
 * @returns {import('../../interfaces.js').DirectiveType}
 */
function get_directive_type(name) {
	if (name === 'use') return 'Action';
	if (name === 'animate') return 'Animation';
	if (name === 'bind') return 'Binding';
	if (name === 'class') return 'Class';
	if (name === 'style') return 'StyleDirective';
	if (name === 'on') return 'EventHandler';
	if (name === 'let') return 'Let';
	if (name === 'in' || name === 'out' || name === 'transition') return 'Transition';
}

/**
 * @param {import('../index.js').Parser} parser
 */
function read_attribute_value(parser) {
	const quote_mark = parser.eat("'") ? "'" : parser.eat('"') ? '"' : null;
	if (quote_mark && parser.eat(quote_mark)) {
		return [
			{
				start: parser.index - 1,
				end: parser.index - 1,
				type: 'Text',
				raw: '',
				data: ''
			}
		];
	}
	let value;
	try {
		value = read_sequence(
			parser,
			() => {
				// handle common case of quote marks existing outside of regex for performance reasons
				if (quote_mark) return parser.match(quote_mark);
				return !!parser.match_regex(regex_starts_with_invalid_attr_value);
			},
			'in attribute value'
		);
	} catch (error) {
		if (error.code === 'parse-error') {
			// if the attribute value didn't close + self-closing tag
			// eg: `<Component test={{a:1} />`
			// acorn may throw a `Unterminated regular expression` because of `/>`
			if (parser.template.slice(error.pos - 1, error.pos + 1) === '/>') {
				parser.index = error.pos;
				parser.error(parser_errors.unclosed_attribute_value(quote_mark || '}'));
			}
		}
		throw error;
	}
	if (value.length === 0 && !quote_mark) {
		parser.error(parser_errors.missing_attribute_value);
	}
	if (quote_mark) parser.index += 1;
	return value;
}

/**
 * @param {import('../index.js').Parser} parser
 * @param {() => boolean} done
 * @param {string} location
 * @returns {import('../../interfaces.js').TemplateNode[]}
 */
function read_sequence(parser, done, location) {
	/**
	 * @type {import('../../interfaces.js').Text}
	 */
	let current_chunk = {
		start: parser.index,
		end: null,
		type: 'Text',
		raw: '',
		data: null
	};

	/**
	 * @type {import('../../interfaces.js').TemplateNode[]}
	 */
	const chunks = [];

	/**
	 * @param {number} end
	 */
	function flush(end) {
		if (current_chunk.raw) {
			current_chunk.data = decode_character_references(current_chunk.raw, true);
			current_chunk.end = end;
			chunks.push(current_chunk);
		}
	}
	while (parser.index < parser.template.length) {
		const index = parser.index;
		if (done()) {
			flush(parser.index);
			return chunks;
		} else if (parser.eat('{')) {
			if (parser.match('#')) {
				const index = parser.index - 1;
				parser.eat('#');
				const name = parser.read_until(/[^a-z]/);
				parser.error(parser_errors.invalid_logic_block_placement(location, name), index);
			} else if (parser.match('@')) {
				const index = parser.index - 1;
				parser.eat('@');
				const name = parser.read_until(/[^a-z]/);
				parser.error(parser_errors.invalid_tag_placement(location, name), index);
			}
			flush(parser.index - 1);
			parser.allow_whitespace();
			const expression = read_expression(parser);
			parser.allow_whitespace();
			parser.eat('}', true);
			chunks.push({
				start: index,
				end: parser.index,
				type: 'MustacheTag',
				expression
			});
			current_chunk = {
				start: parser.index,
				end: null,
				type: 'Text',
				raw: '',
				data: null
			};
		} else {
			current_chunk.raw += parser.template[parser.index++];
		}
	}
	parser.error(parser_errors.unexpected_eof);
}

// Adapted from https://github.com/acornjs/acorn/blob/6584815dca7440e00de841d1dad152302fdd7ca5/src/tokenize.js
// Reproduced under MIT License https://github.com/acornjs/acorn/blob/master/LICENSE

/**
 * @param {string} str
 * @param {number} i
 * @returns {number}
 */
function full_char_code_at(str, i) {
	const code = str.charCodeAt(i);
	if (code <= 0xd7ff || code >= 0xe000) return code;

	const next = str.charCodeAt(i + 1);
	return (code << 10) + next - 0x35fdc00;
}

const SQUARE_BRACKET_OPEN = '['.charCodeAt(0);
const SQUARE_BRACKET_CLOSE = ']'.charCodeAt(0);
const CURLY_BRACKET_OPEN = '{'.charCodeAt(0);
const CURLY_BRACKET_CLOSE = '}'.charCodeAt(0);

function is_bracket_open(code) {
	return code === SQUARE_BRACKET_OPEN || code === CURLY_BRACKET_OPEN;
}

function is_bracket_close(code) {
	return code === SQUARE_BRACKET_CLOSE || code === CURLY_BRACKET_CLOSE;
}

function is_bracket_pair(open, close) {
	return (
		(open === SQUARE_BRACKET_OPEN && close === SQUARE_BRACKET_CLOSE) ||
		(open === CURLY_BRACKET_OPEN && close === CURLY_BRACKET_CLOSE)
	);
}

function get_bracket_close(open) {
	if (open === SQUARE_BRACKET_OPEN) {
		return SQUARE_BRACKET_CLOSE;
	}
	if (open === CURLY_BRACKET_OPEN) {
		return CURLY_BRACKET_CLOSE;
	}
}

/**
 * @param {import('../index.js').Parser} parser
 * @returns {import('estree').Pattern & { start: number; end: number }}
 */
function read_context(parser) {
	const start = parser.index;
	let i = parser.index;

	const code = full_char_code_at(parser.template, i);
	if (isIdentifierStart$1(code, true)) {
		return {
			type: 'Identifier',
			name: parser.read_identifier(),
			start,
			end: parser.index
		};
	}

	if (!is_bracket_open(code)) {
		parser.error(parser_errors.unexpected_token_destructure);
	}

	const bracket_stack = [code];
	i += code <= 0xffff ? 1 : 2;

	while (i < parser.template.length) {
		const code = full_char_code_at(parser.template, i);
		if (is_bracket_open(code)) {
			bracket_stack.push(code);
		} else if (is_bracket_close(code)) {
			if (!is_bracket_pair(bracket_stack[bracket_stack.length - 1], code)) {
				parser.error(
					parser_errors.unexpected_token(
						String.fromCharCode(get_bracket_close(bracket_stack[bracket_stack.length - 1]))
					)
				);
			}
			bracket_stack.pop();
			if (bracket_stack.length === 0) {
				i += code <= 0xffff ? 1 : 2;
				break;
			}
		}
		i += code <= 0xffff ? 1 : 2;
	}

	parser.index = i;

	const pattern_string = parser.template.slice(start, i);
	try {
		// the length of the `space_with_newline` has to be start - 1
		// because we added a `(` in front of the pattern_string,
		// which shifted the entire string to right by 1
		// so we offset it by removing 1 character in the `space_with_newline`
		// to achieve that, we remove the 1st space encountered,
		// so it will not affect the `column` of the node
		let space_with_newline = parser.template
			.slice(0, start)
			.replace(regex_not_newline_characters, ' ');
		const first_space = space_with_newline.indexOf(' ');
		space_with_newline =
			space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);

		return /** @type {any} */ (
			parse_expression_at(`${space_with_newline}(${pattern_string} = 1)`, start - 1)
		).left;
	} catch (error) {
		parser.acorn_error(error);
	}
}

/**
 * @param {string} str
 */
function trim_start(str) {
	return str.replace(regex_starts_with_whitespaces, '');
}

/**
 * @param {string} str
 */
function trim_end(str) {
	return str.replace(regex_ends_with_whitespaces, '');
}

/**
 * @param {import("../../interfaces.js").TemplateNode} node
 */
function to_string(node) {
	switch (node.type) {
		case 'IfBlock':
			return '{#if} block';
		case 'ThenBlock':
			return '{:then} block';
		case 'ElseBlock':
			return '{:else} block';
		case 'PendingBlock':
		case 'AwaitBlock':
			return '{#await} block';
		case 'CatchBlock':
			return '{:catch} block';
		case 'EachBlock':
			return '{#each} block';
		case 'RawMustacheTag':
			return '{@html} block';
		case 'DebugTag':
			return '{@debug} block';
		case 'ConstTag':
			return '{@const} tag';
		case 'Element':
		case 'InlineComponent':
		case 'Slot':
		case 'Title':
			return `<${node.name}> tag`;
		default:
			return node.type;
	}
}

/**
 * @param {import('../../interfaces.js').TemplateNode} block
 * @param {boolean} trim_before
 * @param {boolean} trim_after
 */
function trim_whitespace(block, trim_before, trim_after) {
	if (!block.children || block.children.length === 0) return; // AwaitBlock
	const first_child = block.children[0];
	const last_child = block.children[block.children.length - 1];
	if (first_child.type === 'Text' && trim_before) {
		first_child.data = trim_start(first_child.data);
		if (!first_child.data) block.children.shift();
	}
	if (last_child.type === 'Text' && trim_after) {
		last_child.data = trim_end(last_child.data);
		if (!last_child.data) block.children.pop();
	}
	if (block.else) {
		trim_whitespace(block.else, trim_before, trim_after);
	}
	if (first_child.elseif) {
		trim_whitespace(first_child, trim_before, trim_after);
	}
}
const regex_whitespace_with_closing_curly_brace = /^\s*}/;

/**
 * @param {import('../index.js').Parser} parser
 */
function mustache(parser) {
	const start = parser.index;
	parser.index += 1;
	parser.allow_whitespace();
	// {/if}, {/each}, {/await} or {/key}
	if (parser.eat('/')) {
		let block = parser.current();
		let expected;
		if (closing_tag_omitted(block.name)) {
			block.end = start;
			parser.stack.pop();
			block = parser.current();
		}
		if (
			block.type === 'ElseBlock' ||
			block.type === 'PendingBlock' ||
			block.type === 'ThenBlock' ||
			block.type === 'CatchBlock'
		) {
			block.end = start;
			parser.stack.pop();
			block = parser.current();
			expected = 'await';
		}
		if (block.type === 'IfBlock') {
			expected = 'if';
		} else if (block.type === 'EachBlock') {
			expected = 'each';
		} else if (block.type === 'AwaitBlock') {
			expected = 'await';
		} else if (block.type === 'KeyBlock') {
			expected = 'key';
		} else {
			parser.error(parser_errors.unexpected_block_close);
		}
		parser.eat(expected, true);
		parser.allow_whitespace();
		parser.eat('}', true);
		while (block.elseif) {
			block.end = parser.index;
			parser.stack.pop();
			block = parser.current();
			if (block.else) {
				block.else.end = start;
			}
		}
		// strip leading/trailing whitespace as necessary
		const char_before = parser.template[block.start - 1];
		const char_after = parser.template[parser.index];
		const trim_before = !char_before || regex_whitespace.test(char_before);
		const trim_after = !char_after || regex_whitespace.test(char_after);
		trim_whitespace(block, trim_before, trim_after);
		block.end = parser.index;
		parser.stack.pop();
	} else if (parser.eat(':else')) {
		if (parser.eat('if')) {
			parser.error(parser_errors.invalid_elseif);
		}
		parser.allow_whitespace();
		// :else if
		if (parser.eat('if')) {
			const block = parser.current();
			if (block.type !== 'IfBlock') {
				parser.error(
					parser.stack.some((block) => block.type === 'IfBlock')
						? parser_errors.invalid_elseif_placement_unclosed_block(to_string(block))
						: parser_errors.invalid_elseif_placement_outside_if
				);
			}
			parser.require_whitespace();
			const expression = read_expression(parser);
			parser.allow_whitespace();
			parser.eat('}', true);
			block.else = {
				start: parser.index,
				end: null,
				type: 'ElseBlock',
				children: [
					{
						start: parser.index,
						end: null,
						type: 'IfBlock',
						elseif: true,
						expression,
						children: []
					}
				]
			};
			parser.stack.push(block.else.children[0]);
		} else {
			// :else
			const block = parser.current();
			if (block.type !== 'IfBlock' && block.type !== 'EachBlock') {
				parser.error(
					parser.stack.some((block) => block.type === 'IfBlock' || block.type === 'EachBlock')
						? parser_errors.invalid_else_placement_unclosed_block(to_string(block))
						: parser_errors.invalid_else_placement_outside_if
				);
			}
			parser.allow_whitespace();
			parser.eat('}', true);
			block.else = {
				start: parser.index,
				end: null,
				type: 'ElseBlock',
				children: []
			};
			parser.stack.push(block.else);
		}
	} else if (parser.match(':then') || parser.match(':catch')) {
		const block = parser.current();
		const is_then = parser.eat(':then') || !parser.eat(':catch');
		if (is_then) {
			if (block.type !== 'PendingBlock') {
				parser.error(
					parser.stack.some((block) => block.type === 'PendingBlock')
						? parser_errors.invalid_then_placement_unclosed_block(to_string(block))
						: parser_errors.invalid_then_placement_without_await
				);
			}
		} else {
			if (block.type !== 'ThenBlock' && block.type !== 'PendingBlock') {
				parser.error(
					parser.stack.some((block) => block.type === 'ThenBlock' || block.type === 'PendingBlock')
						? parser_errors.invalid_catch_placement_unclosed_block(to_string(block))
						: parser_errors.invalid_catch_placement_without_await
				);
			}
		}
		block.end = start;
		parser.stack.pop();
		const await_block = parser.current();
		if (!parser.eat('}')) {
			parser.require_whitespace();
			await_block[is_then ? 'value' : 'error'] = read_context(parser);
			parser.allow_whitespace();
			parser.eat('}', true);
		}
		const new_block = {
			start,
			end: null,
			type: is_then ? 'ThenBlock' : 'CatchBlock',
			children: [],
			skip: false
		};
		await_block[is_then ? 'then' : 'catch'] = new_block;
		parser.stack.push(new_block);
	} else if (parser.eat('#')) {
		// {#if foo}, {#each foo} or {#await foo}
		let type;
		if (parser.eat('if')) {
			type = 'IfBlock';
		} else if (parser.eat('each')) {
			type = 'EachBlock';
		} else if (parser.eat('await')) {
			type = 'AwaitBlock';
		} else if (parser.eat('key')) {
			type = 'KeyBlock';
		} else {
			parser.error(parser_errors.expected_block_type);
		}
		parser.require_whitespace();
		const expression = read_expression(parser);
		const block =
			type === 'AwaitBlock'
				? {
						start,
						end: null,
						type,
						expression,
						value: null,
						error: null,
						pending: {
							start: null,
							end: null,
							type: 'PendingBlock',
							children: [],
							skip: true
						},
						then: {
							start: null,
							end: null,
							type: 'ThenBlock',
							children: [],
							skip: true
						},
						catch: {
							start: null,
							end: null,
							type: 'CatchBlock',
							children: [],
							skip: true
						}
				  }
				: {
						start,
						end: null,
						type,
						expression,
						children: []
				  };
		parser.allow_whitespace();
		// {#each} blocks must declare a context – {#each list as item}
		if (type === 'EachBlock') {
			parser.eat('as', true);
			parser.require_whitespace();
			block.context = read_context(parser);
			parser.allow_whitespace();
			if (parser.eat(',')) {
				parser.allow_whitespace();
				block.index = parser.read_identifier();
				if (!block.index) parser.error(parser_errors.expected_name);
				parser.allow_whitespace();
			}
			if (parser.eat('(')) {
				parser.allow_whitespace();
				block.key = read_expression(parser);
				parser.allow_whitespace();
				parser.eat(')', true);
				parser.allow_whitespace();
			}
		}
		const await_block_shorthand = type === 'AwaitBlock' && parser.eat('then');
		if (await_block_shorthand) {
			if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
				parser.allow_whitespace();
			} else {
				parser.require_whitespace();
				block.value = read_context(parser);
				parser.allow_whitespace();
			}
		}
		const await_block_catch_shorthand =
			!await_block_shorthand && type === 'AwaitBlock' && parser.eat('catch');
		if (await_block_catch_shorthand) {
			if (parser.match_regex(regex_whitespace_with_closing_curly_brace)) {
				parser.allow_whitespace();
			} else {
				parser.require_whitespace();
				block.error = read_context(parser);
				parser.allow_whitespace();
			}
		}
		parser.eat('}', true);
		parser.current().children.push(block);
		parser.stack.push(block);
		if (type === 'AwaitBlock') {
			let child_block;
			if (await_block_shorthand) {
				block.then.skip = false;
				child_block = block.then;
			} else if (await_block_catch_shorthand) {
				block.catch.skip = false;
				child_block = block.catch;
			} else {
				block.pending.skip = false;
				child_block = block.pending;
			}
			child_block.start = parser.index;
			parser.stack.push(child_block);
		}
	} else if (parser.eat('@html')) {
		// {@html content} tag
		parser.require_whitespace();
		const expression = read_expression(parser);
		parser.allow_whitespace();
		parser.eat('}', true);
		parser.current().children.push({
			start,
			end: parser.index,
			type: 'RawMustacheTag',
			expression
		});
	} else if (parser.eat('@debug')) {
		let identifiers;
		// Implies {@debug} which indicates "debug all"
		if (parser.read(regex_whitespace_with_closing_curly_brace)) {
			identifiers = [];
		} else {
			const expression = read_expression(parser);
			identifiers =
				expression.type === 'SequenceExpression' ? expression.expressions : [expression];
			identifiers.forEach((node) => {
				if (node.type !== 'Identifier') {
					parser.error(parser_errors.invalid_debug_args, node.start);
				}
			});
			parser.allow_whitespace();
			parser.eat('}', true);
		}
		parser.current().children.push({
			start,
			end: parser.index,
			type: 'DebugTag',
			identifiers
		});
	} else if (parser.eat('@const')) {
		// {@const a = b}
		parser.require_whitespace();
		const expression = read_expression(parser);
		if (!(expression.type === 'AssignmentExpression' && expression.operator === '=')) {
			parser.error(
				{
					code: 'invalid-const-args',
					message: '{@const ...} must be an assignment.'
				},
				start
			);
		}
		parser.allow_whitespace();
		parser.eat('}', true);
		parser.current().children.push({
			start,
			end: parser.index,
			type: 'ConstTag',
			expression
		});
	} else {
		const expression = read_expression(parser);
		parser.allow_whitespace();
		parser.eat('}', true);
		parser.current().children.push({
			start,
			end: parser.index,
			type: 'MustacheTag',
			expression
		});
	}
}

/**
 * @param {import('../index.js').Parser} parser
 */
function text$4(parser) {
	const start = parser.index;

	let data = '';

	while (parser.index < parser.template.length && !parser.match('<') && !parser.match('{')) {
		data += parser.template[parser.index++];
	}

	const node = {
		start,
		end: parser.index,
		type: 'Text',
		raw: data,
		data: decode_character_references(data, false)
	};

	parser.current().children.push(node);
}

/**
 * @param {import('../index.js').Parser} parser
 */
function fragment(parser) {
	if (parser.match('<')) {
		return tag$3;
	}

	if (parser.match('{')) {
		return mustache;
	}

	return text$4;
}

const reserved = new Set([
	'arguments',
	'await',
	'break',
	'case',
	'catch',
	'class',
	'const',
	'continue',
	'debugger',
	'default',
	'delete',
	'do',
	'else',
	'enum',
	'eval',
	'export',
	'extends',
	'false',
	'finally',
	'for',
	'function',
	'if',
	'implements',
	'import',
	'in',
	'instanceof',
	'interface',
	'let',
	'new',
	'null',
	'package',
	'private',
	'protected',
	'public',
	'return',
	'static',
	'super',
	'switch',
	'this',
	'throw',
	'true',
	'try',
	'typeof',
	'var',
	'void',
	'while',
	'with',
	'yield'
]);

/** @typedef {import('./types').Location} Location */

/**
 * @param {import('./types').Range} range
 * @param {number} index
 */
function rangeContains(range, index) {
	return range.start <= index && index < range.end;
}

/**
 * @param {string} source
 * @param {import('./types').Options} [options]
 */
function getLocator(source, options = {}) {
	const { offsetLine = 0, offsetColumn = 0 } = options;

	let start = 0;
	const ranges = source.split('\n').map((line, i) => {
		const end = start + line.length + 1;

		/** @type {import('./types').Range} */
		const range = { start, end, line: i };

		start = end;
		return range;
	});

	let i = 0;

	/**
	 * @param {string | number} search
	 * @param {number} [index]
	 * @returns {Location | undefined}
	 */
	function locator(search, index) {
		if (typeof search === 'string') {
			search = source.indexOf(search, index ?? 0);
		}

		if (search === -1) return undefined;

		let range = ranges[i];

		const d = search >= range.end ? 1 : -1;

		while (range) {
			if (rangeContains(range, search)) {
				return {
					line: offsetLine + range.line,
					column: offsetColumn + search - range.start,
					character: search
				};
			}

			i += d;
			range = ranges[i];
		}
	}

	return locator;
}

/**
 * @param {string} source
 * @param {string | number} search
 * @param {import('./types').Options} [options]
 * @returns {Location | undefined}
 */
function locate$a(source, search, options) {
	return getLocator(source, options)(search, options && options.startIndex);
}

const regex_tabs = /^\t+/;

/**
 * @param {string} str
 */
function tabs_to_spaces(str) {
	return str.replace(regex_tabs, (match) => match.split('\t').join('  '));
}

/**
 * @param {string} source
 * @param {number} line
 * @param {number} column
 */
function get_code_frame(source, line, column) {
	const lines = source.split('\n');
	const frame_start = Math.max(0, line - 2);
	const frame_end = Math.min(line + 3, lines.length);
	const digits = String(frame_end + 1).length;
	return lines
		.slice(frame_start, frame_end)
		.map((str, i) => {
			const is_error_line = frame_start + i === line;
			const line_num = String(i + frame_start + 1).padStart(digits, ' ');
			if (is_error_line) {
				const indicator =
					' '.repeat(digits + 2 + tabs_to_spaces(str.slice(0, column)).length) + '^';
				return `${line_num}: ${tabs_to_spaces(str)}\n${indicator}`;
			}
			return `${line_num}: ${tabs_to_spaces(str)}`;
		})
		.join('\n');
}

/**
 * @extends Error
 */
class CompileError extends Error {
	/**
	 * @type {string}
	 */
	code = undefined;

	/**
	 * @type {{ line: number; column: number }}
	 */
	start = undefined;

	/**
	 * @type {{ line: number; column: number }}
	 */
	end = undefined;

	/**
	 * @type {number}
	 */
	pos = undefined;

	/**
	 * @type {string}
	 */
	filename = undefined;

	/**
	 * @type {string}
	 */
	frame = undefined;

	toString() {
		return `${this.message} (${this.start.line}:${this.start.column})\n${this.frame}`;
	}
}

/**
 * @param {string} message
 * @param {{
 * 		name: string;
 * 		code: string;
 * 		source: string;
 * 		filename: string;
 * 		start: number;
 * 		end?: number;
 * 	}} props
 * @returns {never}
 */
function error(message, props) {
	const error = new CompileError(message);
	error.name = props.name;
	const start = locate$a(props.source, props.start, { offsetLine: 1 });
	const end = locate$a(props.source, props.end || props.start, { offsetLine: 1 });
	error.code = props.code;
	error.start = start;
	error.end = end;
	error.pos = props.start;
	error.filename = props.filename;
	error.frame = get_code_frame(props.source, start.line - 1, start.column);
	throw error;
}

const regex_position_indicator = / \(\d+:\d+\)$/;

let Parser$1 = class Parser {
	/**
	 * @readonly
	 * @type {string}
	 */
	template = undefined;

	/**
	 * @readonly
	 * @type {string}
	 */
	filename = undefined;

	/**
	 * @readonly
	 * @type {boolean}
	 */
	customElement = undefined;

	/**
	 * @readonly
	 * @type {'injected' | 'external' | 'none' | boolean}
	 */
	css_mode = undefined;

	index = 0;

	/**
	 * @type {import('../interfaces.js').TemplateNode[]}
	 */
	stack = [];

	/**
	 * @type {import('../interfaces.js').Fragment}
	 */
	html = undefined;

	/**
	 * @type {import('../interfaces.js').Style[]}
	 */
	css = [];

	/**
	 * @type {import('../interfaces.js').Script[]}
	 */
	js = [];

	meta_tags = {};

	/**
	 * @type {{tag: string; reason: string; depth: number;}}
	 */
	last_auto_closed_tag = undefined;

	/**
	 * @param {string} template
	 * @param {import('../interfaces.js').ParserOptions} options
	 */
	constructor(template, options) {
		if (typeof template !== 'string') {
			throw new TypeError('Template must be a string');
		}
		this.template = template.trimRight();
		this.filename = options.filename;
		this.customElement = options.customElement;
		this.css_mode = options.css;
		this.html = {
			start: null,
			end: null,
			type: 'Fragment',
			children: []
		};
		this.stack.push(this.html);

		/**
		 * @typedef {(parser: Parser) => ParserState | void} ParserState
		 */

		/** @type {ParserState} */
		let state = fragment;
		while (this.index < this.template.length) {
			state = state(this) || fragment;
		}
		if (this.stack.length > 1) {
			const current = this.current();
			const type = current.type === 'Element' ? `<${current.name}>` : 'Block';
			const slug = current.type === 'Element' ? 'element' : 'block';
			this.error(
				{
					code: `unclosed-${slug}`,
					message: `${type} was left open`
				},
				current.start
			);
		}
		if (state !== fragment) {
			this.error({
				code: 'unexpected-eof',
				message: 'Unexpected end of input'
			});
		}
		if (this.html.children.length) {
			let start = this.html.children[0].start;
			while (regex_whitespace.test(template[start])) start += 1;
			let end = this.html.children[this.html.children.length - 1].end;
			while (regex_whitespace.test(template[end - 1])) end -= 1;
			this.html.start = start;
			this.html.end = end;
		} else {
			this.html.start = this.html.end = null;
		}
	}
	current() {
		return this.stack[this.stack.length - 1];
	}

	/**
	 * @param {any} err
	 */
	acorn_error(err) {
		this.error(
			{
				code: 'parse-error',
				message: err.message.replace(regex_position_indicator, '')
			},
			err.pos
		);
	}

	/**
	 * @param {{ code: string; message: string }} err
	 */
	error({ code, message }, index = this.index) {
		error(message, {
			name: 'ParseError',
			code,
			source: this.template,
			start: index,
			filename: this.filename
		});
	}

	/**
	 * @param {string} str
	 * @param {boolean} [required]
	 * @param {{ code: string; message: string }} [error]
	 */
	eat(str, required, error) {
		if (this.match(str)) {
			this.index += str.length;
			return true;
		}
		if (required) {
			this.error(
				error ||
					(this.index === this.template.length
						? parser_errors.unexpected_eof_token(str)
						: parser_errors.unexpected_token(str))
			);
		}
		return false;
	}

	/**
	 * @param {string} str
	 */
	match(str) {
		return this.template.slice(this.index, this.index + str.length) === str;
	}
	/**
	 * Match a regex at the current index
	 * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
	 */
	match_regex(pattern) {
		const match = pattern.exec(this.template.slice(this.index));
		if (!match || match.index !== 0) return null;
		return match[0];
	}
	allow_whitespace() {
		while (this.index < this.template.length && regex_whitespace.test(this.template[this.index])) {
			this.index++;
		}
	}
	/**
	 * Search for a regex starting at the current index and return the result if it matches
	 * @param {RegExp} pattern  Should have a ^ anchor at the start so the regex doesn't search past the beginning, resulting in worse performance
	 */
	read(pattern) {
		const result = this.match_regex(pattern);
		if (result) this.index += result.length;
		return result;
	}
	read_identifier(allow_reserved = false) {
		const start = this.index;
		let i = this.index;
		const code = full_char_code_at(this.template, i);
		if (!isIdentifierStart$1(code, true)) return null;
		i += code <= 0xffff ? 1 : 2;
		while (i < this.template.length) {
			const code = full_char_code_at(this.template, i);
			if (!isIdentifierChar(code, true)) break;
			i += code <= 0xffff ? 1 : 2;
		}
		const identifier = this.template.slice(this.index, (this.index = i));
		if (!allow_reserved && reserved.has(identifier)) {
			this.error(
				{
					code: 'unexpected-reserved-word',
					message: `'${identifier}' is a reserved word in JavaScript and cannot be used here`
				},
				start
			);
		}
		return identifier;
	}

	/**
	 * @param {RegExp} pattern
	 * @param {Parameters<Parser['error']>[0]} [error_message]
	 */
	read_until(pattern, error_message) {
		if (this.index >= this.template.length) {
			this.error(
				error_message || {
					code: 'unexpected-eof',
					message: 'Unexpected end of input'
				}
			);
		}
		const start = this.index;
		const match = pattern.exec(this.template.slice(start));
		if (match) {
			this.index = start + match.index;
			return this.template.slice(start, this.index);
		}
		this.index = this.template.length;
		return this.template.slice(start);
	}
	require_whitespace() {
		if (!regex_whitespace.test(this.template[this.index])) {
			this.error({
				code: 'missing-whitespace',
				message: 'Expected whitespace'
			});
		}
		this.allow_whitespace();
	}
};

/**
 * The parse function parses a component, returning only its abstract syntax tree.
 *
 * https://svelte.dev/docs/svelte-compiler#svelte-parse
 * @param {string} template
 * @param {import('../interfaces.js').ParserOptions} options
 * @returns {import('../interfaces.js').Ast}
 */
function parse$8(template, options = {}) {
	const parser = new Parser$1(template, options);
	// TODO we may want to allow multiple <style> tags —
	// one scoped, one global. for now, only allow one
	if (parser.css.length > 1) {
		parser.error(parser_errors.duplicate_style, parser.css[1].start);
	}
	const instance_scripts = parser.js.filter((script) => script.context === 'default');
	const module_scripts = parser.js.filter((script) => script.context === 'module');
	if (instance_scripts.length > 1) {
		parser.error(parser_errors.invalid_script_instance, instance_scripts[1].start);
	}
	if (module_scripts.length > 1) {
		parser.error(parser_errors.invalid_script_module, module_scripts[1].start);
	}
	return {
		html: parser.html,
		css: parser.css[0],
		instance: instance_scripts[0],
		module: module_scripts[0]
	};
}

var lib$4 = {};

var ariaPropsMap = {};

var iterationDecorator$1 = {};

var iteratorProxy$1 = {};

var hasRequiredIteratorProxy$1;

function requireIteratorProxy$1 () {
	if (hasRequiredIteratorProxy$1) return iteratorProxy$1;
	hasRequiredIteratorProxy$1 = 1;

	Object.defineProperty(iteratorProxy$1, "__esModule", {
	  value: true
	});
	iteratorProxy$1.default = void 0;

	// eslint-disable-next-line no-unused-vars
	function iteratorProxy() {
	  var values = this;
	  var index = 0;
	  var iter = {
	    '@@iterator': function iterator() {
	      return iter;
	    },
	    next: function next() {
	      if (index < values.length) {
	        var value = values[index];
	        index = index + 1;
	        return {
	          done: false,
	          value: value
	        };
	      } else {
	        return {
	          done: true
	        };
	      }
	    }
	  };
	  return iter;
	}
	var _default = iteratorProxy;
	iteratorProxy$1.default = _default;
	return iteratorProxy$1;
}

var hasRequiredIterationDecorator$1;

function requireIterationDecorator$1 () {
	if (hasRequiredIterationDecorator$1) return iterationDecorator$1;
	hasRequiredIterationDecorator$1 = 1;

	Object.defineProperty(iterationDecorator$1, "__esModule", {
	  value: true
	});
	iterationDecorator$1.default = iterationDecorator;
	var _iteratorProxy = _interopRequireDefault(requireIteratorProxy$1());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
	function iterationDecorator(collection, entries) {
	  if (typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol') {
	    Object.defineProperty(collection, Symbol.iterator, {
	      value: _iteratorProxy.default.bind(entries)
	    });
	  }
	  return collection;
	}
	return iterationDecorator$1;
}

var hasRequiredAriaPropsMap;

function requireAriaPropsMap () {
	if (hasRequiredAriaPropsMap) return ariaPropsMap;
	hasRequiredAriaPropsMap = 1;

	Object.defineProperty(ariaPropsMap, "__esModule", {
	  value: true
	});
	ariaPropsMap.default = void 0;
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator$1());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var properties = [['aria-activedescendant', {
	  'type': 'id'
	}], ['aria-atomic', {
	  'type': 'boolean'
	}], ['aria-autocomplete', {
	  'type': 'token',
	  'values': ['inline', 'list', 'both', 'none']
	}], ['aria-braillelabel', {
	  'type': 'string'
	}], ['aria-brailleroledescription', {
	  'type': 'string'
	}], ['aria-busy', {
	  'type': 'boolean'
	}], ['aria-checked', {
	  'type': 'tristate'
	}], ['aria-colcount', {
	  type: 'integer'
	}], ['aria-colindex', {
	  type: 'integer'
	}], ['aria-colspan', {
	  type: 'integer'
	}], ['aria-controls', {
	  'type': 'idlist'
	}], ['aria-current', {
	  type: 'token',
	  values: ['page', 'step', 'location', 'date', 'time', true, false]
	}], ['aria-describedby', {
	  'type': 'idlist'
	}], ['aria-description', {
	  'type': 'string'
	}], ['aria-details', {
	  'type': 'id'
	}], ['aria-disabled', {
	  'type': 'boolean'
	}], ['aria-dropeffect', {
	  'type': 'tokenlist',
	  'values': ['copy', 'execute', 'link', 'move', 'none', 'popup']
	}], ['aria-errormessage', {
	  'type': 'id'
	}], ['aria-expanded', {
	  'type': 'boolean',
	  'allowundefined': true
	}], ['aria-flowto', {
	  'type': 'idlist'
	}], ['aria-grabbed', {
	  'type': 'boolean',
	  'allowundefined': true
	}], ['aria-haspopup', {
	  'type': 'token',
	  'values': [false, true, 'menu', 'listbox', 'tree', 'grid', 'dialog']
	}], ['aria-hidden', {
	  'type': 'boolean',
	  'allowundefined': true
	}], ['aria-invalid', {
	  'type': 'token',
	  'values': ['grammar', false, 'spelling', true]
	}], ['aria-keyshortcuts', {
	  type: 'string'
	}], ['aria-label', {
	  'type': 'string'
	}], ['aria-labelledby', {
	  'type': 'idlist'
	}], ['aria-level', {
	  'type': 'integer'
	}], ['aria-live', {
	  'type': 'token',
	  'values': ['assertive', 'off', 'polite']
	}], ['aria-modal', {
	  type: 'boolean'
	}], ['aria-multiline', {
	  'type': 'boolean'
	}], ['aria-multiselectable', {
	  'type': 'boolean'
	}], ['aria-orientation', {
	  'type': 'token',
	  'values': ['vertical', 'undefined', 'horizontal']
	}], ['aria-owns', {
	  'type': 'idlist'
	}], ['aria-placeholder', {
	  type: 'string'
	}], ['aria-posinset', {
	  'type': 'integer'
	}], ['aria-pressed', {
	  'type': 'tristate'
	}], ['aria-readonly', {
	  'type': 'boolean'
	}], ['aria-relevant', {
	  'type': 'tokenlist',
	  'values': ['additions', 'all', 'removals', 'text']
	}], ['aria-required', {
	  'type': 'boolean'
	}], ['aria-roledescription', {
	  type: 'string'
	}], ['aria-rowcount', {
	  type: 'integer'
	}], ['aria-rowindex', {
	  type: 'integer'
	}], ['aria-rowspan', {
	  type: 'integer'
	}], ['aria-selected', {
	  'type': 'boolean',
	  'allowundefined': true
	}], ['aria-setsize', {
	  'type': 'integer'
	}], ['aria-sort', {
	  'type': 'token',
	  'values': ['ascending', 'descending', 'none', 'other']
	}], ['aria-valuemax', {
	  'type': 'number'
	}], ['aria-valuemin', {
	  'type': 'number'
	}], ['aria-valuenow', {
	  'type': 'number'
	}], ['aria-valuetext', {
	  'type': 'string'
	}]];
	var ariaPropsMap$1 = {
	  entries: function entries() {
	    return properties;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    var _iterator = _createForOfIteratorHelper(properties),
	      _step;
	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        var _step$value = _slicedToArray(_step.value, 2),
	          key = _step$value[0],
	          values = _step$value[1];
	        fn.call(thisArg, values, key, properties);
	      }
	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }
	  },
	  get: function get(key) {
	    var item = properties.find(function (tuple) {
	      return tuple[0] === key ? true : false;
	    });
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!ariaPropsMap$1.get(key);
	  },
	  keys: function keys() {
	    return properties.map(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	        key = _ref2[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return properties.map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        values = _ref4[1];
	      return values;
	    });
	  }
	};
	var _default = (0, _iterationDecorator.default)(ariaPropsMap$1, ariaPropsMap$1.entries());
	ariaPropsMap.default = _default;
	return ariaPropsMap;
}

var domMap = {};

var hasRequiredDomMap;

function requireDomMap () {
	if (hasRequiredDomMap) return domMap;
	hasRequiredDomMap = 1;

	Object.defineProperty(domMap, "__esModule", {
	  value: true
	});
	domMap.default = void 0;
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator$1());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var dom = [['a', {
	  reserved: false
	}], ['abbr', {
	  reserved: false
	}], ['acronym', {
	  reserved: false
	}], ['address', {
	  reserved: false
	}], ['applet', {
	  reserved: false
	}], ['area', {
	  reserved: false
	}], ['article', {
	  reserved: false
	}], ['aside', {
	  reserved: false
	}], ['audio', {
	  reserved: false
	}], ['b', {
	  reserved: false
	}], ['base', {
	  reserved: true
	}], ['bdi', {
	  reserved: false
	}], ['bdo', {
	  reserved: false
	}], ['big', {
	  reserved: false
	}], ['blink', {
	  reserved: false
	}], ['blockquote', {
	  reserved: false
	}], ['body', {
	  reserved: false
	}], ['br', {
	  reserved: false
	}], ['button', {
	  reserved: false
	}], ['canvas', {
	  reserved: false
	}], ['caption', {
	  reserved: false
	}], ['center', {
	  reserved: false
	}], ['cite', {
	  reserved: false
	}], ['code', {
	  reserved: false
	}], ['col', {
	  reserved: true
	}], ['colgroup', {
	  reserved: true
	}], ['content', {
	  reserved: false
	}], ['data', {
	  reserved: false
	}], ['datalist', {
	  reserved: false
	}], ['dd', {
	  reserved: false
	}], ['del', {
	  reserved: false
	}], ['details', {
	  reserved: false
	}], ['dfn', {
	  reserved: false
	}], ['dialog', {
	  reserved: false
	}], ['dir', {
	  reserved: false
	}], ['div', {
	  reserved: false
	}], ['dl', {
	  reserved: false
	}], ['dt', {
	  reserved: false
	}], ['em', {
	  reserved: false
	}], ['embed', {
	  reserved: false
	}], ['fieldset', {
	  reserved: false
	}], ['figcaption', {
	  reserved: false
	}], ['figure', {
	  reserved: false
	}], ['font', {
	  reserved: false
	}], ['footer', {
	  reserved: false
	}], ['form', {
	  reserved: false
	}], ['frame', {
	  reserved: false
	}], ['frameset', {
	  reserved: false
	}], ['h1', {
	  reserved: false
	}], ['h2', {
	  reserved: false
	}], ['h3', {
	  reserved: false
	}], ['h4', {
	  reserved: false
	}], ['h5', {
	  reserved: false
	}], ['h6', {
	  reserved: false
	}], ['head', {
	  reserved: true
	}], ['header', {
	  reserved: false
	}], ['hgroup', {
	  reserved: false
	}], ['hr', {
	  reserved: false
	}], ['html', {
	  reserved: true
	}], ['i', {
	  reserved: false
	}], ['iframe', {
	  reserved: false
	}], ['img', {
	  reserved: false
	}], ['input', {
	  reserved: false
	}], ['ins', {
	  reserved: false
	}], ['kbd', {
	  reserved: false
	}], ['keygen', {
	  reserved: false
	}], ['label', {
	  reserved: false
	}], ['legend', {
	  reserved: false
	}], ['li', {
	  reserved: false
	}], ['link', {
	  reserved: true
	}], ['main', {
	  reserved: false
	}], ['map', {
	  reserved: false
	}], ['mark', {
	  reserved: false
	}], ['marquee', {
	  reserved: false
	}], ['menu', {
	  reserved: false
	}], ['menuitem', {
	  reserved: false
	}], ['meta', {
	  reserved: true
	}], ['meter', {
	  reserved: false
	}], ['nav', {
	  reserved: false
	}], ['noembed', {
	  reserved: true
	}], ['noscript', {
	  reserved: true
	}], ['object', {
	  reserved: false
	}], ['ol', {
	  reserved: false
	}], ['optgroup', {
	  reserved: false
	}], ['option', {
	  reserved: false
	}], ['output', {
	  reserved: false
	}], ['p', {
	  reserved: false
	}], ['param', {
	  reserved: true
	}], ['picture', {
	  reserved: true
	}], ['pre', {
	  reserved: false
	}], ['progress', {
	  reserved: false
	}], ['q', {
	  reserved: false
	}], ['rp', {
	  reserved: false
	}], ['rt', {
	  reserved: false
	}], ['rtc', {
	  reserved: false
	}], ['ruby', {
	  reserved: false
	}], ['s', {
	  reserved: false
	}], ['samp', {
	  reserved: false
	}], ['script', {
	  reserved: true
	}], ['section', {
	  reserved: false
	}], ['select', {
	  reserved: false
	}], ['small', {
	  reserved: false
	}], ['source', {
	  reserved: true
	}], ['spacer', {
	  reserved: false
	}], ['span', {
	  reserved: false
	}], ['strike', {
	  reserved: false
	}], ['strong', {
	  reserved: false
	}], ['style', {
	  reserved: true
	}], ['sub', {
	  reserved: false
	}], ['summary', {
	  reserved: false
	}], ['sup', {
	  reserved: false
	}], ['table', {
	  reserved: false
	}], ['tbody', {
	  reserved: false
	}], ['td', {
	  reserved: false
	}], ['textarea', {
	  reserved: false
	}], ['tfoot', {
	  reserved: false
	}], ['th', {
	  reserved: false
	}], ['thead', {
	  reserved: false
	}], ['time', {
	  reserved: false
	}], ['title', {
	  reserved: true
	}], ['tr', {
	  reserved: false
	}], ['track', {
	  reserved: true
	}], ['tt', {
	  reserved: false
	}], ['u', {
	  reserved: false
	}], ['ul', {
	  reserved: false
	}], ['var', {
	  reserved: false
	}], ['video', {
	  reserved: false
	}], ['wbr', {
	  reserved: false
	}], ['xmp', {
	  reserved: false
	}]];
	var domMap$1 = {
	  entries: function entries() {
	    return dom;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    var _iterator = _createForOfIteratorHelper(dom),
	      _step;
	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        var _step$value = _slicedToArray(_step.value, 2),
	          key = _step$value[0],
	          values = _step$value[1];
	        fn.call(thisArg, values, key, dom);
	      }
	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }
	  },
	  get: function get(key) {
	    var item = dom.find(function (tuple) {
	      return tuple[0] === key ? true : false;
	    });
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!domMap$1.get(key);
	  },
	  keys: function keys() {
	    return dom.map(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	        key = _ref2[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return dom.map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        values = _ref4[1];
	      return values;
	    });
	  }
	};
	var _default = (0, _iterationDecorator.default)(domMap$1, domMap$1.entries());
	domMap.default = _default;
	return domMap;
}

var rolesMap = {};

var ariaAbstractRoles = {};

var commandRole = {};

var hasRequiredCommandRole;

function requireCommandRole () {
	if (hasRequiredCommandRole) return commandRole;
	hasRequiredCommandRole = 1;

	Object.defineProperty(commandRole, "__esModule", {
	  value: true
	});
	commandRole.default = void 0;
	var commandRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget']]
	};
	var _default = commandRole$1;
	commandRole.default = _default;
	return commandRole;
}

var compositeRole = {};

var hasRequiredCompositeRole;

function requireCompositeRole () {
	if (hasRequiredCompositeRole) return compositeRole;
	hasRequiredCompositeRole = 1;

	Object.defineProperty(compositeRole, "__esModule", {
	  value: true
	});
	compositeRole.default = void 0;
	var compositeRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-activedescendant': null,
	    'aria-disabled': null
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget']]
	};
	var _default = compositeRole$1;
	compositeRole.default = _default;
	return compositeRole;
}

var inputRole = {};

var hasRequiredInputRole;

function requireInputRole () {
	if (hasRequiredInputRole) return inputRole;
	hasRequiredInputRole = 1;

	Object.defineProperty(inputRole, "__esModule", {
	  value: true
	});
	inputRole.default = void 0;
	var inputRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'input'
	    },
	    module: 'XForms'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget']]
	};
	var _default = inputRole$1;
	inputRole.default = _default;
	return inputRole;
}

var landmarkRole = {};

var hasRequiredLandmarkRole;

function requireLandmarkRole () {
	if (hasRequiredLandmarkRole) return landmarkRole;
	hasRequiredLandmarkRole = 1;

	Object.defineProperty(landmarkRole, "__esModule", {
	  value: true
	});
	landmarkRole.default = void 0;
	var landmarkRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = landmarkRole$1;
	landmarkRole.default = _default;
	return landmarkRole;
}

var rangeRole = {};

var hasRequiredRangeRole;

function requireRangeRole () {
	if (hasRequiredRangeRole) return rangeRole;
	hasRequiredRangeRole = 1;

	Object.defineProperty(rangeRole, "__esModule", {
	  value: true
	});
	rangeRole.default = void 0;
	var rangeRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-valuemax': null,
	    'aria-valuemin': null,
	    'aria-valuenow': null
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	var _default = rangeRole$1;
	rangeRole.default = _default;
	return rangeRole;
}

var roletypeRole = {};

var hasRequiredRoletypeRole;

function requireRoletypeRole () {
	if (hasRequiredRoletypeRole) return roletypeRole;
	hasRequiredRoletypeRole = 1;

	Object.defineProperty(roletypeRole, "__esModule", {
	  value: true
	});
	roletypeRole.default = void 0;
	var roletypeRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: [],
	  prohibitedProps: [],
	  props: {
	    'aria-atomic': null,
	    'aria-busy': null,
	    'aria-controls': null,
	    'aria-current': null,
	    'aria-describedby': null,
	    'aria-details': null,
	    'aria-dropeffect': null,
	    'aria-flowto': null,
	    'aria-grabbed': null,
	    'aria-hidden': null,
	    'aria-keyshortcuts': null,
	    'aria-label': null,
	    'aria-labelledby': null,
	    'aria-live': null,
	    'aria-owns': null,
	    'aria-relevant': null,
	    'aria-roledescription': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'role'
	    },
	    module: 'XHTML'
	  }, {
	    concept: {
	      name: 'type'
	    },
	    module: 'Dublin Core'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: []
	};
	var _default = roletypeRole$1;
	roletypeRole.default = _default;
	return roletypeRole;
}

var sectionRole = {};

var hasRequiredSectionRole;

function requireSectionRole () {
	if (hasRequiredSectionRole) return sectionRole;
	hasRequiredSectionRole = 1;

	Object.defineProperty(sectionRole, "__esModule", {
	  value: true
	});
	sectionRole.default = void 0;
	var sectionRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: [],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'frontmatter'
	    },
	    module: 'DTB'
	  }, {
	    concept: {
	      name: 'level'
	    },
	    module: 'DTB'
	  }, {
	    concept: {
	      name: 'level'
	    },
	    module: 'SMIL'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	var _default = sectionRole$1;
	sectionRole.default = _default;
	return sectionRole;
}

var sectionheadRole = {};

var hasRequiredSectionheadRole;

function requireSectionheadRole () {
	if (hasRequiredSectionheadRole) return sectionheadRole;
	hasRequiredSectionheadRole = 1;

	Object.defineProperty(sectionheadRole, "__esModule", {
	  value: true
	});
	sectionheadRole.default = void 0;
	var sectionheadRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	var _default = sectionheadRole$1;
	sectionheadRole.default = _default;
	return sectionheadRole;
}

var selectRole = {};

var hasRequiredSelectRole;

function requireSelectRole () {
	if (hasRequiredSelectRole) return selectRole;
	hasRequiredSelectRole = 1;

	Object.defineProperty(selectRole, "__esModule", {
	  value: true
	});
	selectRole.default = void 0;
	var selectRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-orientation': null
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite'], ['roletype', 'structure', 'section', 'group']]
	};
	var _default = selectRole$1;
	selectRole.default = _default;
	return selectRole;
}

var structureRole = {};

var hasRequiredStructureRole;

function requireStructureRole () {
	if (hasRequiredStructureRole) return structureRole;
	hasRequiredStructureRole = 1;

	Object.defineProperty(structureRole, "__esModule", {
	  value: true
	});
	structureRole.default = void 0;
	var structureRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: [],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype']]
	};
	var _default = structureRole$1;
	structureRole.default = _default;
	return structureRole;
}

var widgetRole = {};

var hasRequiredWidgetRole;

function requireWidgetRole () {
	if (hasRequiredWidgetRole) return widgetRole;
	hasRequiredWidgetRole = 1;

	Object.defineProperty(widgetRole, "__esModule", {
	  value: true
	});
	widgetRole.default = void 0;
	var widgetRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: [],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype']]
	};
	var _default = widgetRole$1;
	widgetRole.default = _default;
	return widgetRole;
}

var windowRole = {};

var hasRequiredWindowRole$1;

function requireWindowRole$1 () {
	if (hasRequiredWindowRole$1) return windowRole;
	hasRequiredWindowRole$1 = 1;

	Object.defineProperty(windowRole, "__esModule", {
	  value: true
	});
	windowRole.default = void 0;
	var windowRole$1 = {
	  abstract: true,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-modal': null
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype']]
	};
	var _default = windowRole$1;
	windowRole.default = _default;
	return windowRole;
}

var hasRequiredAriaAbstractRoles;

function requireAriaAbstractRoles () {
	if (hasRequiredAriaAbstractRoles) return ariaAbstractRoles;
	hasRequiredAriaAbstractRoles = 1;

	Object.defineProperty(ariaAbstractRoles, "__esModule", {
	  value: true
	});
	ariaAbstractRoles.default = void 0;
	var _commandRole = _interopRequireDefault(requireCommandRole());
	var _compositeRole = _interopRequireDefault(requireCompositeRole());
	var _inputRole = _interopRequireDefault(requireInputRole());
	var _landmarkRole = _interopRequireDefault(requireLandmarkRole());
	var _rangeRole = _interopRequireDefault(requireRangeRole());
	var _roletypeRole = _interopRequireDefault(requireRoletypeRole());
	var _sectionRole = _interopRequireDefault(requireSectionRole());
	var _sectionheadRole = _interopRequireDefault(requireSectionheadRole());
	var _selectRole = _interopRequireDefault(requireSelectRole());
	var _structureRole = _interopRequireDefault(requireStructureRole());
	var _widgetRole = _interopRequireDefault(requireWidgetRole());
	var _windowRole = _interopRequireDefault(requireWindowRole$1());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ariaAbstractRoles$1 = [['command', _commandRole.default], ['composite', _compositeRole.default], ['input', _inputRole.default], ['landmark', _landmarkRole.default], ['range', _rangeRole.default], ['roletype', _roletypeRole.default], ['section', _sectionRole.default], ['sectionhead', _sectionheadRole.default], ['select', _selectRole.default], ['structure', _structureRole.default], ['widget', _widgetRole.default], ['window', _windowRole.default]];
	var _default = ariaAbstractRoles$1;
	ariaAbstractRoles.default = _default;
	return ariaAbstractRoles;
}

var ariaLiteralRoles = {};

var alertRole = {};

var hasRequiredAlertRole$1;

function requireAlertRole$1 () {
	if (hasRequiredAlertRole$1) return alertRole;
	hasRequiredAlertRole$1 = 1;

	Object.defineProperty(alertRole, "__esModule", {
	  value: true
	});
	alertRole.default = void 0;
	var alertRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-atomic': 'true',
	    'aria-live': 'assertive'
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'alert'
	    },
	    module: 'XForms'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = alertRole$1;
	alertRole.default = _default;
	return alertRole;
}

var alertdialogRole = {};

var hasRequiredAlertdialogRole;

function requireAlertdialogRole () {
	if (hasRequiredAlertdialogRole) return alertdialogRole;
	hasRequiredAlertdialogRole = 1;

	Object.defineProperty(alertdialogRole, "__esModule", {
	  value: true
	});
	alertdialogRole.default = void 0;
	var alertdialogRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'alert'
	    },
	    module: 'XForms'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'alert'], ['roletype', 'window', 'dialog']]
	};
	var _default = alertdialogRole$1;
	alertdialogRole.default = _default;
	return alertdialogRole;
}

var applicationRole = {};

var hasRequiredApplicationRole$1;

function requireApplicationRole$1 () {
	if (hasRequiredApplicationRole$1) return applicationRole;
	hasRequiredApplicationRole$1 = 1;

	Object.defineProperty(applicationRole, "__esModule", {
	  value: true
	});
	applicationRole.default = void 0;
	var applicationRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-activedescendant': null,
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'Device Independence Delivery Unit'
	    }
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	var _default = applicationRole$1;
	applicationRole.default = _default;
	return applicationRole;
}

var articleRole = {};

var hasRequiredArticleRole$1;

function requireArticleRole$1 () {
	if (hasRequiredArticleRole$1) return articleRole;
	hasRequiredArticleRole$1 = 1;

	Object.defineProperty(articleRole, "__esModule", {
	  value: true
	});
	articleRole.default = void 0;
	var articleRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-posinset': null,
	    'aria-setsize': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'article'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'document']]
	};
	var _default = articleRole$1;
	articleRole.default = _default;
	return articleRole;
}

var bannerRole = {};

var hasRequiredBannerRole$1;

function requireBannerRole$1 () {
	if (hasRequiredBannerRole$1) return bannerRole;
	hasRequiredBannerRole$1 = 1;

	Object.defineProperty(bannerRole, "__esModule", {
	  value: true
	});
	bannerRole.default = void 0;
	var bannerRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      constraints: ['scoped to the body element'],
	      name: 'header'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = bannerRole$1;
	bannerRole.default = _default;
	return bannerRole;
}

var blockquoteRole = {};

var hasRequiredBlockquoteRole$1;

function requireBlockquoteRole$1 () {
	if (hasRequiredBlockquoteRole$1) return blockquoteRole;
	hasRequiredBlockquoteRole$1 = 1;

	Object.defineProperty(blockquoteRole, "__esModule", {
	  value: true
	});
	blockquoteRole.default = void 0;
	var blockquoteRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'blockquote'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = blockquoteRole$1;
	blockquoteRole.default = _default;
	return blockquoteRole;
}

var buttonRole = {};

var hasRequiredButtonRole$1;

function requireButtonRole$1 () {
	if (hasRequiredButtonRole$1) return buttonRole;
	hasRequiredButtonRole$1 = 1;

	Object.defineProperty(buttonRole, "__esModule", {
	  value: true
	});
	buttonRole.default = void 0;
	var buttonRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-pressed': null
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        name: 'type',
	        value: 'button'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        name: 'type',
	        value: 'image'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        name: 'type',
	        value: 'reset'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        name: 'type',
	        value: 'submit'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'button'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'trigger'
	    },
	    module: 'XForms'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'command']]
	};
	var _default = buttonRole$1;
	buttonRole.default = _default;
	return buttonRole;
}

var captionRole = {};

var hasRequiredCaptionRole$1;

function requireCaptionRole$1 () {
	if (hasRequiredCaptionRole$1) return captionRole;
	hasRequiredCaptionRole$1 = 1;

	Object.defineProperty(captionRole, "__esModule", {
	  value: true
	});
	captionRole.default = void 0;
	var captionRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'caption'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: ['figure', 'grid', 'table'],
	  requiredContextRole: ['figure', 'grid', 'table'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = captionRole$1;
	captionRole.default = _default;
	return captionRole;
}

var cellRole = {};

var hasRequiredCellRole$1;

function requireCellRole$1 () {
	if (hasRequiredCellRole$1) return cellRole;
	hasRequiredCellRole$1 = 1;

	Object.defineProperty(cellRole, "__esModule", {
	  value: true
	});
	cellRole.default = void 0;
	var cellRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-colindex': null,
	    'aria-colspan': null,
	    'aria-rowindex': null,
	    'aria-rowspan': null
	  },
	  relatedConcepts: [{
	    concept: {
	      constraints: ['ancestor table element has table role'],
	      name: 'td'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: ['row'],
	  requiredContextRole: ['row'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = cellRole$1;
	cellRole.default = _default;
	return cellRole;
}

var checkboxRole = {};

var hasRequiredCheckboxRole;

function requireCheckboxRole () {
	if (hasRequiredCheckboxRole) return checkboxRole;
	hasRequiredCheckboxRole = 1;

	Object.defineProperty(checkboxRole, "__esModule", {
	  value: true
	});
	checkboxRole.default = void 0;
	var checkboxRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-checked': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-invalid': null,
	    'aria-readonly': null,
	    'aria-required': null
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        name: 'type',
	        value: 'checkbox'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'option'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-checked': null
	  },
	  superClass: [['roletype', 'widget', 'input']]
	};
	var _default = checkboxRole$1;
	checkboxRole.default = _default;
	return checkboxRole;
}

var codeRole = {};

var hasRequiredCodeRole;

function requireCodeRole () {
	if (hasRequiredCodeRole) return codeRole;
	hasRequiredCodeRole = 1;

	Object.defineProperty(codeRole, "__esModule", {
	  value: true
	});
	codeRole.default = void 0;
	var codeRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'code'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = codeRole$1;
	codeRole.default = _default;
	return codeRole;
}

var columnheaderRole = {};

var hasRequiredColumnheaderRole;

function requireColumnheaderRole () {
	if (hasRequiredColumnheaderRole) return columnheaderRole;
	hasRequiredColumnheaderRole = 1;

	Object.defineProperty(columnheaderRole, "__esModule", {
	  value: true
	});
	columnheaderRole.default = void 0;
	var columnheaderRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-sort': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'th'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        name: 'scope',
	        value: 'col'
	      }],
	      name: 'th'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        name: 'scope',
	        value: 'colgroup'
	      }],
	      name: 'th'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: ['row'],
	  requiredContextRole: ['row'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'cell'], ['roletype', 'structure', 'section', 'cell', 'gridcell'], ['roletype', 'widget', 'gridcell'], ['roletype', 'structure', 'sectionhead']]
	};
	var _default = columnheaderRole$1;
	columnheaderRole.default = _default;
	return columnheaderRole;
}

var comboboxRole = {};

var hasRequiredComboboxRole;

function requireComboboxRole () {
	if (hasRequiredComboboxRole) return comboboxRole;
	hasRequiredComboboxRole = 1;

	Object.defineProperty(comboboxRole, "__esModule", {
	  value: true
	});
	comboboxRole.default = void 0;
	var comboboxRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-activedescendant': null,
	    'aria-autocomplete': null,
	    'aria-errormessage': null,
	    'aria-invalid': null,
	    'aria-readonly': null,
	    'aria-required': null,
	    'aria-expanded': 'false',
	    'aria-haspopup': 'listbox'
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'email'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'search'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'tel'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'text'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'url'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'url'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['undefined'],
	        name: 'multiple'
	      }, {
	        constraints: ['undefined'],
	        name: 'size'
	      }],
	      constraints: ['the multiple attribute is not set and the size attribute does not have a value greater than 1'],
	      name: 'select'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'select'
	    },
	    module: 'XForms'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-controls': null,
	    'aria-expanded': 'false'
	  },
	  superClass: [['roletype', 'widget', 'input']]
	};
	var _default = comboboxRole$1;
	comboboxRole.default = _default;
	return comboboxRole;
}

var complementaryRole = {};

var hasRequiredComplementaryRole$1;

function requireComplementaryRole$1 () {
	if (hasRequiredComplementaryRole$1) return complementaryRole;
	hasRequiredComplementaryRole$1 = 1;

	Object.defineProperty(complementaryRole, "__esModule", {
	  value: true
	});
	complementaryRole.default = void 0;
	var complementaryRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'aside'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'aria-label'
	      }],
	      constraints: ['scoped to a sectioning content element', 'scoped to a sectioning root element other than body'],
	      name: 'aside'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'aria-labelledby'
	      }],
	      constraints: ['scoped to a sectioning content element', 'scoped to a sectioning root element other than body'],
	      name: 'aside'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = complementaryRole$1;
	complementaryRole.default = _default;
	return complementaryRole;
}

var contentinfoRole = {};

var hasRequiredContentinfoRole;

function requireContentinfoRole () {
	if (hasRequiredContentinfoRole) return contentinfoRole;
	hasRequiredContentinfoRole = 1;

	Object.defineProperty(contentinfoRole, "__esModule", {
	  value: true
	});
	contentinfoRole.default = void 0;
	var contentinfoRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      constraints: ['scoped to the body element'],
	      name: 'footer'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = contentinfoRole$1;
	contentinfoRole.default = _default;
	return contentinfoRole;
}

var definitionRole = {};

var hasRequiredDefinitionRole$1;

function requireDefinitionRole$1 () {
	if (hasRequiredDefinitionRole$1) return definitionRole;
	hasRequiredDefinitionRole$1 = 1;

	Object.defineProperty(definitionRole, "__esModule", {
	  value: true
	});
	definitionRole.default = void 0;
	var definitionRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'dd'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = definitionRole$1;
	definitionRole.default = _default;
	return definitionRole;
}

var deletionRole = {};

var hasRequiredDeletionRole;

function requireDeletionRole () {
	if (hasRequiredDeletionRole) return deletionRole;
	hasRequiredDeletionRole = 1;

	Object.defineProperty(deletionRole, "__esModule", {
	  value: true
	});
	deletionRole.default = void 0;
	var deletionRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'del'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = deletionRole$1;
	deletionRole.default = _default;
	return deletionRole;
}

var dialogRole = {};

var hasRequiredDialogRole$1;

function requireDialogRole$1 () {
	if (hasRequiredDialogRole$1) return dialogRole;
	hasRequiredDialogRole$1 = 1;

	Object.defineProperty(dialogRole, "__esModule", {
	  value: true
	});
	dialogRole.default = void 0;
	var dialogRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'dialog'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'window']]
	};
	var _default = dialogRole$1;
	dialogRole.default = _default;
	return dialogRole;
}

var directoryRole = {};

var hasRequiredDirectoryRole$1;

function requireDirectoryRole$1 () {
	if (hasRequiredDirectoryRole$1) return directoryRole;
	hasRequiredDirectoryRole$1 = 1;

	Object.defineProperty(directoryRole, "__esModule", {
	  value: true
	});
	directoryRole.default = void 0;
	var directoryRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    module: 'DAISY Guide'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'list']]
	};
	var _default = directoryRole$1;
	directoryRole.default = _default;
	return directoryRole;
}

var documentRole = {};

var hasRequiredDocumentRole$1;

function requireDocumentRole$1 () {
	if (hasRequiredDocumentRole$1) return documentRole;
	hasRequiredDocumentRole$1 = 1;

	Object.defineProperty(documentRole, "__esModule", {
	  value: true
	});
	documentRole.default = void 0;
	var documentRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'Device Independence Delivery Unit'
	    }
	  }, {
	    concept: {
	      name: 'html'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	var _default = documentRole$1;
	documentRole.default = _default;
	return documentRole;
}

var emphasisRole = {};

var hasRequiredEmphasisRole;

function requireEmphasisRole () {
	if (hasRequiredEmphasisRole) return emphasisRole;
	hasRequiredEmphasisRole = 1;

	Object.defineProperty(emphasisRole, "__esModule", {
	  value: true
	});
	emphasisRole.default = void 0;
	var emphasisRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'em'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = emphasisRole$1;
	emphasisRole.default = _default;
	return emphasisRole;
}

var feedRole = {};

var hasRequiredFeedRole$1;

function requireFeedRole$1 () {
	if (hasRequiredFeedRole$1) return feedRole;
	hasRequiredFeedRole$1 = 1;

	Object.defineProperty(feedRole, "__esModule", {
	  value: true
	});
	feedRole.default = void 0;
	var feedRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['article']],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'list']]
	};
	var _default = feedRole$1;
	feedRole.default = _default;
	return feedRole;
}

var figureRole = {};

var hasRequiredFigureRole$1;

function requireFigureRole$1 () {
	if (hasRequiredFigureRole$1) return figureRole;
	hasRequiredFigureRole$1 = 1;

	Object.defineProperty(figureRole, "__esModule", {
	  value: true
	});
	figureRole.default = void 0;
	var figureRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'figure'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = figureRole$1;
	figureRole.default = _default;
	return figureRole;
}

var formRole = {};

var hasRequiredFormRole$1;

function requireFormRole$1 () {
	if (hasRequiredFormRole$1) return formRole;
	hasRequiredFormRole$1 = 1;

	Object.defineProperty(formRole, "__esModule", {
	  value: true
	});
	formRole.default = void 0;
	var formRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'aria-label'
	      }],
	      name: 'form'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'aria-labelledby'
	      }],
	      name: 'form'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'name'
	      }],
	      name: 'form'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = formRole$1;
	formRole.default = _default;
	return formRole;
}

var genericRole = {};

var hasRequiredGenericRole;

function requireGenericRole () {
	if (hasRequiredGenericRole) return genericRole;
	hasRequiredGenericRole = 1;

	Object.defineProperty(genericRole, "__esModule", {
	  value: true
	});
	genericRole.default = void 0;
	var genericRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'a'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'area'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'aside'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'b'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'bdo'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'body'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'data'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'div'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      constraints: ['scoped to the main element', 'scoped to a sectioning content element', 'scoped to a sectioning root element other than body'],
	      name: 'footer'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      constraints: ['scoped to the main element', 'scoped to a sectioning content element', 'scoped to a sectioning root element other than body'],
	      name: 'header'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'hgroup'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'i'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'pre'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'q'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'samp'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'section'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'small'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'span'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'u'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	var _default = genericRole$1;
	genericRole.default = _default;
	return genericRole;
}

var gridRole = {};

var hasRequiredGridRole$1;

function requireGridRole$1 () {
	if (hasRequiredGridRole$1) return gridRole;
	hasRequiredGridRole$1 = 1;

	Object.defineProperty(gridRole, "__esModule", {
	  value: true
	});
	gridRole.default = void 0;
	var gridRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-multiselectable': null,
	    'aria-readonly': null
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['row'], ['row', 'rowgroup']],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite'], ['roletype', 'structure', 'section', 'table']]
	};
	var _default = gridRole$1;
	gridRole.default = _default;
	return gridRole;
}

var gridcellRole = {};

var hasRequiredGridcellRole;

function requireGridcellRole () {
	if (hasRequiredGridcellRole) return gridcellRole;
	hasRequiredGridcellRole = 1;

	Object.defineProperty(gridcellRole, "__esModule", {
	  value: true
	});
	gridcellRole.default = void 0;
	var gridcellRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null,
	    'aria-readonly': null,
	    'aria-required': null,
	    'aria-selected': null
	  },
	  relatedConcepts: [{
	    concept: {
	      constraints: ['ancestor table element has grid role', 'ancestor table element has treegrid role'],
	      name: 'td'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: ['row'],
	  requiredContextRole: ['row'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'cell'], ['roletype', 'widget']]
	};
	var _default = gridcellRole$1;
	gridcellRole.default = _default;
	return gridcellRole;
}

var groupRole = {};

var hasRequiredGroupRole$1;

function requireGroupRole$1 () {
	if (hasRequiredGroupRole$1) return groupRole;
	hasRequiredGroupRole$1 = 1;

	Object.defineProperty(groupRole, "__esModule", {
	  value: true
	});
	groupRole.default = void 0;
	var groupRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-activedescendant': null,
	    'aria-disabled': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'details'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'fieldset'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'optgroup'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'address'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = groupRole$1;
	groupRole.default = _default;
	return groupRole;
}

var headingRole = {};

var hasRequiredHeadingRole$1;

function requireHeadingRole$1 () {
	if (hasRequiredHeadingRole$1) return headingRole;
	hasRequiredHeadingRole$1 = 1;

	Object.defineProperty(headingRole, "__esModule", {
	  value: true
	});
	headingRole.default = void 0;
	var headingRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-level': '2'
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'h1'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'h2'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'h3'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'h4'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'h5'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'h6'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-level': '2'
	  },
	  superClass: [['roletype', 'structure', 'sectionhead']]
	};
	var _default = headingRole$1;
	headingRole.default = _default;
	return headingRole;
}

var imgRole = {};

var hasRequiredImgRole;

function requireImgRole () {
	if (hasRequiredImgRole) return imgRole;
	hasRequiredImgRole = 1;

	Object.defineProperty(imgRole, "__esModule", {
	  value: true
	});
	imgRole.default = void 0;
	var imgRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'alt'
	      }],
	      name: 'img'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['undefined'],
	        name: 'alt'
	      }],
	      name: 'img'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'imggroup'
	    },
	    module: 'DTB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = imgRole$1;
	imgRole.default = _default;
	return imgRole;
}

var insertionRole = {};

var hasRequiredInsertionRole;

function requireInsertionRole () {
	if (hasRequiredInsertionRole) return insertionRole;
	hasRequiredInsertionRole = 1;

	Object.defineProperty(insertionRole, "__esModule", {
	  value: true
	});
	insertionRole.default = void 0;
	var insertionRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'ins'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = insertionRole$1;
	insertionRole.default = _default;
	return insertionRole;
}

var linkRole = {};

var hasRequiredLinkRole$1;

function requireLinkRole$1 () {
	if (hasRequiredLinkRole$1) return linkRole;
	hasRequiredLinkRole$1 = 1;

	Object.defineProperty(linkRole, "__esModule", {
	  value: true
	});
	linkRole.default = void 0;
	var linkRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-expanded': null,
	    'aria-haspopup': null
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'href'
	      }],
	      name: 'a'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'href'
	      }],
	      name: 'area'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'command']]
	};
	var _default = linkRole$1;
	linkRole.default = _default;
	return linkRole;
}

var listRole = {};

var hasRequiredListRole$1;

function requireListRole$1 () {
	if (hasRequiredListRole$1) return listRole;
	hasRequiredListRole$1 = 1;

	Object.defineProperty(listRole, "__esModule", {
	  value: true
	});
	listRole.default = void 0;
	var listRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'menu'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'ol'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'ul'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['listitem']],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = listRole$1;
	listRole.default = _default;
	return listRole;
}

var listboxRole = {};

var hasRequiredListboxRole;

function requireListboxRole () {
	if (hasRequiredListboxRole) return listboxRole;
	hasRequiredListboxRole = 1;

	Object.defineProperty(listboxRole, "__esModule", {
	  value: true
	});
	listboxRole.default = void 0;
	var listboxRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-invalid': null,
	    'aria-multiselectable': null,
	    'aria-readonly': null,
	    'aria-required': null,
	    'aria-orientation': 'vertical'
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        constraints: ['>1'],
	        name: 'size'
	      }],
	      constraints: ['the size attribute value is greater than 1'],
	      name: 'select'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        name: 'multiple'
	      }],
	      name: 'select'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'datalist'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'list'
	    },
	    module: 'ARIA'
	  }, {
	    concept: {
	      name: 'select'
	    },
	    module: 'XForms'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['option', 'group'], ['option']],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite', 'select'], ['roletype', 'structure', 'section', 'group', 'select']]
	};
	var _default = listboxRole$1;
	listboxRole.default = _default;
	return listboxRole;
}

var listitemRole = {};

var hasRequiredListitemRole;

function requireListitemRole () {
	if (hasRequiredListitemRole) return listitemRole;
	hasRequiredListitemRole = 1;

	Object.defineProperty(listitemRole, "__esModule", {
	  value: true
	});
	listitemRole.default = void 0;
	var listitemRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-level': null,
	    'aria-posinset': null,
	    'aria-setsize': null
	  },
	  relatedConcepts: [{
	    concept: {
	      constraints: ['direct descendant of ol', 'direct descendant of ul', 'direct descendant of menu'],
	      name: 'li'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'item'
	    },
	    module: 'XForms'
	  }],
	  requireContextRole: ['directory', 'list'],
	  requiredContextRole: ['directory', 'list'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = listitemRole$1;
	listitemRole.default = _default;
	return listitemRole;
}

var logRole = {};

var hasRequiredLogRole$1;

function requireLogRole$1 () {
	if (hasRequiredLogRole$1) return logRole;
	hasRequiredLogRole$1 = 1;

	Object.defineProperty(logRole, "__esModule", {
	  value: true
	});
	logRole.default = void 0;
	var logRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-live': 'polite'
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = logRole$1;
	logRole.default = _default;
	return logRole;
}

var mainRole = {};

var hasRequiredMainRole$1;

function requireMainRole$1 () {
	if (hasRequiredMainRole$1) return mainRole;
	hasRequiredMainRole$1 = 1;

	Object.defineProperty(mainRole, "__esModule", {
	  value: true
	});
	mainRole.default = void 0;
	var mainRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'main'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = mainRole$1;
	mainRole.default = _default;
	return mainRole;
}

var markRole = {};

var hasRequiredMarkRole$1;

function requireMarkRole$1 () {
	if (hasRequiredMarkRole$1) return markRole;
	hasRequiredMarkRole$1 = 1;

	Object.defineProperty(markRole, "__esModule", {
	  value: true
	});
	markRole.default = void 0;
	var markRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: [],
	  props: {
	    'aria-braillelabel': null,
	    'aria-brailleroledescription': null,
	    'aria-description': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'mark'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = markRole$1;
	markRole.default = _default;
	return markRole;
}

var marqueeRole = {};

var hasRequiredMarqueeRole$1;

function requireMarqueeRole$1 () {
	if (hasRequiredMarqueeRole$1) return marqueeRole;
	hasRequiredMarqueeRole$1 = 1;

	Object.defineProperty(marqueeRole, "__esModule", {
	  value: true
	});
	marqueeRole.default = void 0;
	var marqueeRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = marqueeRole$1;
	marqueeRole.default = _default;
	return marqueeRole;
}

var mathRole = {};

var hasRequiredMathRole$1;

function requireMathRole$1 () {
	if (hasRequiredMathRole$1) return mathRole;
	hasRequiredMathRole$1 = 1;

	Object.defineProperty(mathRole, "__esModule", {
	  value: true
	});
	mathRole.default = void 0;
	var mathRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'math'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = mathRole$1;
	mathRole.default = _default;
	return mathRole;
}

var menuRole = {};

var hasRequiredMenuRole$1;

function requireMenuRole$1 () {
	if (hasRequiredMenuRole$1) return menuRole;
	hasRequiredMenuRole$1 = 1;

	Object.defineProperty(menuRole, "__esModule", {
	  value: true
	});
	menuRole.default = void 0;
	var menuRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-orientation': 'vertical'
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'MENU'
	    },
	    module: 'JAPI'
	  }, {
	    concept: {
	      name: 'list'
	    },
	    module: 'ARIA'
	  }, {
	    concept: {
	      name: 'select'
	    },
	    module: 'XForms'
	  }, {
	    concept: {
	      name: 'sidebar'
	    },
	    module: 'DTB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['menuitem', 'group'], ['menuitemradio', 'group'], ['menuitemcheckbox', 'group'], ['menuitem'], ['menuitemcheckbox'], ['menuitemradio']],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite', 'select'], ['roletype', 'structure', 'section', 'group', 'select']]
	};
	var _default = menuRole$1;
	menuRole.default = _default;
	return menuRole;
}

var menubarRole = {};

var hasRequiredMenubarRole;

function requireMenubarRole () {
	if (hasRequiredMenubarRole) return menubarRole;
	hasRequiredMenubarRole = 1;

	Object.defineProperty(menubarRole, "__esModule", {
	  value: true
	});
	menubarRole.default = void 0;
	var menubarRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-orientation': 'horizontal'
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'toolbar'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['menuitem', 'group'], ['menuitemradio', 'group'], ['menuitemcheckbox', 'group'], ['menuitem'], ['menuitemcheckbox'], ['menuitemradio']],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite', 'select', 'menu'], ['roletype', 'structure', 'section', 'group', 'select', 'menu']]
	};
	var _default = menubarRole$1;
	menubarRole.default = _default;
	return menubarRole;
}

var menuitemRole = {};

var hasRequiredMenuitemRole;

function requireMenuitemRole () {
	if (hasRequiredMenuitemRole) return menuitemRole;
	hasRequiredMenuitemRole = 1;

	Object.defineProperty(menuitemRole, "__esModule", {
	  value: true
	});
	menuitemRole.default = void 0;
	var menuitemRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-posinset': null,
	    'aria-setsize': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'MENU_ITEM'
	    },
	    module: 'JAPI'
	  }, {
	    concept: {
	      name: 'listitem'
	    },
	    module: 'ARIA'
	  }, {
	    concept: {
	      name: 'option'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: ['group', 'menu', 'menubar'],
	  requiredContextRole: ['group', 'menu', 'menubar'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'command']]
	};
	var _default = menuitemRole$1;
	menuitemRole.default = _default;
	return menuitemRole;
}

var menuitemcheckboxRole = {};

var hasRequiredMenuitemcheckboxRole;

function requireMenuitemcheckboxRole () {
	if (hasRequiredMenuitemcheckboxRole) return menuitemcheckboxRole;
	hasRequiredMenuitemcheckboxRole = 1;

	Object.defineProperty(menuitemcheckboxRole, "__esModule", {
	  value: true
	});
	menuitemcheckboxRole.default = void 0;
	var menuitemcheckboxRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'menuitem'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: ['group', 'menu', 'menubar'],
	  requiredContextRole: ['group', 'menu', 'menubar'],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-checked': null
	  },
	  superClass: [['roletype', 'widget', 'input', 'checkbox'], ['roletype', 'widget', 'command', 'menuitem']]
	};
	var _default = menuitemcheckboxRole$1;
	menuitemcheckboxRole.default = _default;
	return menuitemcheckboxRole;
}

var menuitemradioRole = {};

var hasRequiredMenuitemradioRole;

function requireMenuitemradioRole () {
	if (hasRequiredMenuitemradioRole) return menuitemradioRole;
	hasRequiredMenuitemradioRole = 1;

	Object.defineProperty(menuitemradioRole, "__esModule", {
	  value: true
	});
	menuitemradioRole.default = void 0;
	var menuitemradioRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'menuitem'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: ['group', 'menu', 'menubar'],
	  requiredContextRole: ['group', 'menu', 'menubar'],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-checked': null
	  },
	  superClass: [['roletype', 'widget', 'input', 'checkbox', 'menuitemcheckbox'], ['roletype', 'widget', 'command', 'menuitem', 'menuitemcheckbox'], ['roletype', 'widget', 'input', 'radio']]
	};
	var _default = menuitemradioRole$1;
	menuitemradioRole.default = _default;
	return menuitemradioRole;
}

var meterRole = {};

var hasRequiredMeterRole$1;

function requireMeterRole$1 () {
	if (hasRequiredMeterRole$1) return meterRole;
	hasRequiredMeterRole$1 = 1;

	Object.defineProperty(meterRole, "__esModule", {
	  value: true
	});
	meterRole.default = void 0;
	var meterRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-valuetext': null,
	    'aria-valuemax': '100',
	    'aria-valuemin': '0'
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'meter'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-valuenow': null
	  },
	  superClass: [['roletype', 'structure', 'range']]
	};
	var _default = meterRole$1;
	meterRole.default = _default;
	return meterRole;
}

var navigationRole = {};

var hasRequiredNavigationRole$1;

function requireNavigationRole$1 () {
	if (hasRequiredNavigationRole$1) return navigationRole;
	hasRequiredNavigationRole$1 = 1;

	Object.defineProperty(navigationRole, "__esModule", {
	  value: true
	});
	navigationRole.default = void 0;
	var navigationRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'nav'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = navigationRole$1;
	navigationRole.default = _default;
	return navigationRole;
}

var noneRole = {};

var hasRequiredNoneRole$1;

function requireNoneRole$1 () {
	if (hasRequiredNoneRole$1) return noneRole;
	hasRequiredNoneRole$1 = 1;

	Object.defineProperty(noneRole, "__esModule", {
	  value: true
	});
	noneRole.default = void 0;
	var noneRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: [],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: []
	};
	var _default = noneRole$1;
	noneRole.default = _default;
	return noneRole;
}

var noteRole = {};

var hasRequiredNoteRole$1;

function requireNoteRole$1 () {
	if (hasRequiredNoteRole$1) return noteRole;
	hasRequiredNoteRole$1 = 1;

	Object.defineProperty(noteRole, "__esModule", {
	  value: true
	});
	noteRole.default = void 0;
	var noteRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = noteRole$1;
	noteRole.default = _default;
	return noteRole;
}

var optionRole = {};

var hasRequiredOptionRole;

function requireOptionRole () {
	if (hasRequiredOptionRole) return optionRole;
	hasRequiredOptionRole = 1;

	Object.defineProperty(optionRole, "__esModule", {
	  value: true
	});
	optionRole.default = void 0;
	var optionRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-checked': null,
	    'aria-posinset': null,
	    'aria-setsize': null,
	    'aria-selected': 'false'
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'item'
	    },
	    module: 'XForms'
	  }, {
	    concept: {
	      name: 'listitem'
	    },
	    module: 'ARIA'
	  }, {
	    concept: {
	      name: 'option'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-selected': 'false'
	  },
	  superClass: [['roletype', 'widget', 'input']]
	};
	var _default = optionRole$1;
	optionRole.default = _default;
	return optionRole;
}

var paragraphRole = {};

var hasRequiredParagraphRole$1;

function requireParagraphRole$1 () {
	if (hasRequiredParagraphRole$1) return paragraphRole;
	hasRequiredParagraphRole$1 = 1;

	Object.defineProperty(paragraphRole, "__esModule", {
	  value: true
	});
	paragraphRole.default = void 0;
	var paragraphRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'p'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = paragraphRole$1;
	paragraphRole.default = _default;
	return paragraphRole;
}

var presentationRole = {};

var hasRequiredPresentationRole;

function requirePresentationRole () {
	if (hasRequiredPresentationRole) return presentationRole;
	hasRequiredPresentationRole = 1;

	Object.defineProperty(presentationRole, "__esModule", {
	  value: true
	});
	presentationRole.default = void 0;
	var presentationRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        name: 'alt',
	        value: ''
	      }],
	      name: 'img'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	var _default = presentationRole$1;
	presentationRole.default = _default;
	return presentationRole;
}

var progressbarRole = {};

var hasRequiredProgressbarRole;

function requireProgressbarRole () {
	if (hasRequiredProgressbarRole) return progressbarRole;
	hasRequiredProgressbarRole = 1;

	Object.defineProperty(progressbarRole, "__esModule", {
	  value: true
	});
	progressbarRole.default = void 0;
	var progressbarRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-valuetext': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'progress'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'status'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'range'], ['roletype', 'widget']]
	};
	var _default = progressbarRole$1;
	progressbarRole.default = _default;
	return progressbarRole;
}

var radioRole = {};

var hasRequiredRadioRole;

function requireRadioRole () {
	if (hasRequiredRadioRole) return radioRole;
	hasRequiredRadioRole = 1;

	Object.defineProperty(radioRole, "__esModule", {
	  value: true
	});
	radioRole.default = void 0;
	var radioRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-checked': null,
	    'aria-posinset': null,
	    'aria-setsize': null
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        name: 'type',
	        value: 'radio'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-checked': null
	  },
	  superClass: [['roletype', 'widget', 'input']]
	};
	var _default = radioRole$1;
	radioRole.default = _default;
	return radioRole;
}

var radiogroupRole = {};

var hasRequiredRadiogroupRole;

function requireRadiogroupRole () {
	if (hasRequiredRadiogroupRole) return radiogroupRole;
	hasRequiredRadiogroupRole = 1;

	Object.defineProperty(radiogroupRole, "__esModule", {
	  value: true
	});
	radiogroupRole.default = void 0;
	var radiogroupRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-invalid': null,
	    'aria-readonly': null,
	    'aria-required': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'list'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['radio']],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite', 'select'], ['roletype', 'structure', 'section', 'group', 'select']]
	};
	var _default = radiogroupRole$1;
	radiogroupRole.default = _default;
	return radiogroupRole;
}

var regionRole = {};

var hasRequiredRegionRole$1;

function requireRegionRole$1 () {
	if (hasRequiredRegionRole$1) return regionRole;
	hasRequiredRegionRole$1 = 1;

	Object.defineProperty(regionRole, "__esModule", {
	  value: true
	});
	regionRole.default = void 0;
	var regionRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'aria-label'
	      }],
	      name: 'section'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['set'],
	        name: 'aria-labelledby'
	      }],
	      name: 'section'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'Device Independence Glossart perceivable unit'
	    }
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = regionRole$1;
	regionRole.default = _default;
	return regionRole;
}

var rowRole = {};

var hasRequiredRowRole$1;

function requireRowRole$1 () {
	if (hasRequiredRowRole$1) return rowRole;
	hasRequiredRowRole$1 = 1;

	Object.defineProperty(rowRole, "__esModule", {
	  value: true
	});
	rowRole.default = void 0;
	var rowRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-colindex': null,
	    'aria-expanded': null,
	    'aria-level': null,
	    'aria-posinset': null,
	    'aria-rowindex': null,
	    'aria-selected': null,
	    'aria-setsize': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'tr'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: ['grid', 'rowgroup', 'table', 'treegrid'],
	  requiredContextRole: ['grid', 'rowgroup', 'table', 'treegrid'],
	  requiredOwnedElements: [['cell'], ['columnheader'], ['gridcell'], ['rowheader']],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'group'], ['roletype', 'widget']]
	};
	var _default = rowRole$1;
	rowRole.default = _default;
	return rowRole;
}

var rowgroupRole = {};

var hasRequiredRowgroupRole;

function requireRowgroupRole () {
	if (hasRequiredRowgroupRole) return rowgroupRole;
	hasRequiredRowgroupRole = 1;

	Object.defineProperty(rowgroupRole, "__esModule", {
	  value: true
	});
	rowgroupRole.default = void 0;
	var rowgroupRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'tbody'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'tfoot'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'thead'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: ['grid', 'table', 'treegrid'],
	  requiredContextRole: ['grid', 'table', 'treegrid'],
	  requiredOwnedElements: [['row']],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	var _default = rowgroupRole$1;
	rowgroupRole.default = _default;
	return rowgroupRole;
}

var rowheaderRole = {};

var hasRequiredRowheaderRole;

function requireRowheaderRole () {
	if (hasRequiredRowheaderRole) return rowheaderRole;
	hasRequiredRowheaderRole = 1;

	Object.defineProperty(rowheaderRole, "__esModule", {
	  value: true
	});
	rowheaderRole.default = void 0;
	var rowheaderRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-sort': null
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        name: 'scope',
	        value: 'row'
	      }],
	      name: 'th'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        name: 'scope',
	        value: 'rowgroup'
	      }],
	      name: 'th'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: ['row', 'rowgroup'],
	  requiredContextRole: ['row', 'rowgroup'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'cell'], ['roletype', 'structure', 'section', 'cell', 'gridcell'], ['roletype', 'widget', 'gridcell'], ['roletype', 'structure', 'sectionhead']]
	};
	var _default = rowheaderRole$1;
	rowheaderRole.default = _default;
	return rowheaderRole;
}

var scrollbarRole = {};

var hasRequiredScrollbarRole;

function requireScrollbarRole () {
	if (hasRequiredScrollbarRole) return scrollbarRole;
	hasRequiredScrollbarRole = 1;

	Object.defineProperty(scrollbarRole, "__esModule", {
	  value: true
	});
	scrollbarRole.default = void 0;
	var scrollbarRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-valuetext': null,
	    'aria-orientation': 'vertical',
	    'aria-valuemax': '100',
	    'aria-valuemin': '0'
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-controls': null,
	    'aria-valuenow': null
	  },
	  superClass: [['roletype', 'structure', 'range'], ['roletype', 'widget']]
	};
	var _default = scrollbarRole$1;
	scrollbarRole.default = _default;
	return scrollbarRole;
}

var searchRole = {};

var hasRequiredSearchRole$1;

function requireSearchRole$1 () {
	if (hasRequiredSearchRole$1) return searchRole;
	hasRequiredSearchRole$1 = 1;

	Object.defineProperty(searchRole, "__esModule", {
	  value: true
	});
	searchRole.default = void 0;
	var searchRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = searchRole$1;
	searchRole.default = _default;
	return searchRole;
}

var searchboxRole = {};

var hasRequiredSearchboxRole;

function requireSearchboxRole () {
	if (hasRequiredSearchboxRole) return searchboxRole;
	hasRequiredSearchboxRole = 1;

	Object.defineProperty(searchboxRole, "__esModule", {
	  value: true
	});
	searchboxRole.default = void 0;
	var searchboxRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        constraints: ['undefined'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'search'
	      }],
	      constraints: ['the list attribute is not set'],
	      name: 'input'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'input', 'textbox']]
	};
	var _default = searchboxRole$1;
	searchboxRole.default = _default;
	return searchboxRole;
}

var separatorRole = {};

var hasRequiredSeparatorRole;

function requireSeparatorRole () {
	if (hasRequiredSeparatorRole) return separatorRole;
	hasRequiredSeparatorRole = 1;

	Object.defineProperty(separatorRole, "__esModule", {
	  value: true
	});
	separatorRole.default = void 0;
	var separatorRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-orientation': 'horizontal',
	    'aria-valuemax': '100',
	    'aria-valuemin': '0',
	    'aria-valuenow': null,
	    'aria-valuetext': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'hr'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure']]
	};
	var _default = separatorRole$1;
	separatorRole.default = _default;
	return separatorRole;
}

var sliderRole = {};

var hasRequiredSliderRole$1;

function requireSliderRole$1 () {
	if (hasRequiredSliderRole$1) return sliderRole;
	hasRequiredSliderRole$1 = 1;

	Object.defineProperty(sliderRole, "__esModule", {
	  value: true
	});
	sliderRole.default = void 0;
	var sliderRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-haspopup': null,
	    'aria-invalid': null,
	    'aria-readonly': null,
	    'aria-valuetext': null,
	    'aria-orientation': 'horizontal',
	    'aria-valuemax': '100',
	    'aria-valuemin': '0'
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        name: 'type',
	        value: 'range'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-valuenow': null
	  },
	  superClass: [['roletype', 'widget', 'input'], ['roletype', 'structure', 'range']]
	};
	var _default = sliderRole$1;
	sliderRole.default = _default;
	return sliderRole;
}

var spinbuttonRole = {};

var hasRequiredSpinbuttonRole;

function requireSpinbuttonRole () {
	if (hasRequiredSpinbuttonRole) return spinbuttonRole;
	hasRequiredSpinbuttonRole = 1;

	Object.defineProperty(spinbuttonRole, "__esModule", {
	  value: true
	});
	spinbuttonRole.default = void 0;
	var spinbuttonRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-invalid': null,
	    'aria-readonly': null,
	    'aria-required': null,
	    'aria-valuetext': null,
	    'aria-valuenow': '0'
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        name: 'type',
	        value: 'number'
	      }],
	      name: 'input'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite'], ['roletype', 'widget', 'input'], ['roletype', 'structure', 'range']]
	};
	var _default = spinbuttonRole$1;
	spinbuttonRole.default = _default;
	return spinbuttonRole;
}

var statusRole = {};

var hasRequiredStatusRole$1;

function requireStatusRole$1 () {
	if (hasRequiredStatusRole$1) return statusRole;
	hasRequiredStatusRole$1 = 1;

	Object.defineProperty(statusRole, "__esModule", {
	  value: true
	});
	statusRole.default = void 0;
	var statusRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-atomic': 'true',
	    'aria-live': 'polite'
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'output'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = statusRole$1;
	statusRole.default = _default;
	return statusRole;
}

var strongRole = {};

var hasRequiredStrongRole;

function requireStrongRole () {
	if (hasRequiredStrongRole) return strongRole;
	hasRequiredStrongRole = 1;

	Object.defineProperty(strongRole, "__esModule", {
	  value: true
	});
	strongRole.default = void 0;
	var strongRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'strong'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = strongRole$1;
	strongRole.default = _default;
	return strongRole;
}

var subscriptRole = {};

var hasRequiredSubscriptRole;

function requireSubscriptRole () {
	if (hasRequiredSubscriptRole) return subscriptRole;
	hasRequiredSubscriptRole = 1;

	Object.defineProperty(subscriptRole, "__esModule", {
	  value: true
	});
	subscriptRole.default = void 0;
	var subscriptRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'sub'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = subscriptRole$1;
	subscriptRole.default = _default;
	return subscriptRole;
}

var superscriptRole = {};

var hasRequiredSuperscriptRole;

function requireSuperscriptRole () {
	if (hasRequiredSuperscriptRole) return superscriptRole;
	hasRequiredSuperscriptRole = 1;

	Object.defineProperty(superscriptRole, "__esModule", {
	  value: true
	});
	superscriptRole.default = void 0;
	var superscriptRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['prohibited'],
	  prohibitedProps: ['aria-label', 'aria-labelledby'],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'sup'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = superscriptRole$1;
	superscriptRole.default = _default;
	return superscriptRole;
}

var switchRole = {};

var hasRequiredSwitchRole$1;

function requireSwitchRole$1 () {
	if (hasRequiredSwitchRole$1) return switchRole;
	hasRequiredSwitchRole$1 = 1;

	Object.defineProperty(switchRole, "__esModule", {
	  value: true
	});
	switchRole.default = void 0;
	var switchRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'button'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-checked': null
	  },
	  superClass: [['roletype', 'widget', 'input', 'checkbox']]
	};
	var _default = switchRole$1;
	switchRole.default = _default;
	return switchRole;
}

var tabRole = {};

var hasRequiredTabRole$1;

function requireTabRole$1 () {
	if (hasRequiredTabRole$1) return tabRole;
	hasRequiredTabRole$1 = 1;

	Object.defineProperty(tabRole, "__esModule", {
	  value: true
	});
	tabRole.default = void 0;
	var tabRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-posinset': null,
	    'aria-setsize': null,
	    'aria-selected': 'false'
	  },
	  relatedConcepts: [],
	  requireContextRole: ['tablist'],
	  requiredContextRole: ['tablist'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'sectionhead'], ['roletype', 'widget']]
	};
	var _default = tabRole$1;
	tabRole.default = _default;
	return tabRole;
}

var tableRole = {};

var hasRequiredTableRole$1;

function requireTableRole$1 () {
	if (hasRequiredTableRole$1) return tableRole;
	hasRequiredTableRole$1 = 1;

	Object.defineProperty(tableRole, "__esModule", {
	  value: true
	});
	tableRole.default = void 0;
	var tableRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-colcount': null,
	    'aria-rowcount': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'table'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['row'], ['row', 'rowgroup']],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = tableRole$1;
	tableRole.default = _default;
	return tableRole;
}

var tablistRole = {};

var hasRequiredTablistRole;

function requireTablistRole () {
	if (hasRequiredTablistRole) return tablistRole;
	hasRequiredTablistRole = 1;

	Object.defineProperty(tablistRole, "__esModule", {
	  value: true
	});
	tablistRole.default = void 0;
	var tablistRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-level': null,
	    'aria-multiselectable': null,
	    'aria-orientation': 'horizontal'
	  },
	  relatedConcepts: [{
	    module: 'DAISY',
	    concept: {
	      name: 'guide'
	    }
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['tab']],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite']]
	};
	var _default = tablistRole$1;
	tablistRole.default = _default;
	return tablistRole;
}

var tabpanelRole = {};

var hasRequiredTabpanelRole;

function requireTabpanelRole () {
	if (hasRequiredTabpanelRole) return tabpanelRole;
	hasRequiredTabpanelRole = 1;

	Object.defineProperty(tabpanelRole, "__esModule", {
	  value: true
	});
	tabpanelRole.default = void 0;
	var tabpanelRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = tabpanelRole$1;
	tabpanelRole.default = _default;
	return tabpanelRole;
}

var termRole = {};

var hasRequiredTermRole$1;

function requireTermRole$1 () {
	if (hasRequiredTermRole$1) return termRole;
	hasRequiredTermRole$1 = 1;

	Object.defineProperty(termRole, "__esModule", {
	  value: true
	});
	termRole.default = void 0;
	var termRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'dfn'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'dt'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = termRole$1;
	termRole.default = _default;
	return termRole;
}

var textboxRole = {};

var hasRequiredTextboxRole;

function requireTextboxRole () {
	if (hasRequiredTextboxRole) return textboxRole;
	hasRequiredTextboxRole = 1;

	Object.defineProperty(textboxRole, "__esModule", {
	  value: true
	});
	textboxRole.default = void 0;
	var textboxRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-activedescendant': null,
	    'aria-autocomplete': null,
	    'aria-errormessage': null,
	    'aria-haspopup': null,
	    'aria-invalid': null,
	    'aria-multiline': null,
	    'aria-placeholder': null,
	    'aria-readonly': null,
	    'aria-required': null
	  },
	  relatedConcepts: [{
	    concept: {
	      attributes: [{
	        constraints: ['undefined'],
	        name: 'type'
	      }, {
	        constraints: ['undefined'],
	        name: 'list'
	      }],
	      constraints: ['the list attribute is not set'],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['undefined'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'email'
	      }],
	      constraints: ['the list attribute is not set'],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['undefined'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'tel'
	      }],
	      constraints: ['the list attribute is not set'],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['undefined'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'text'
	      }],
	      constraints: ['the list attribute is not set'],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      attributes: [{
	        constraints: ['undefined'],
	        name: 'list'
	      }, {
	        name: 'type',
	        value: 'url'
	      }],
	      constraints: ['the list attribute is not set'],
	      name: 'input'
	    },
	    module: 'HTML'
	  }, {
	    concept: {
	      name: 'input'
	    },
	    module: 'XForms'
	  }, {
	    concept: {
	      name: 'textarea'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'input']]
	};
	var _default = textboxRole$1;
	textboxRole.default = _default;
	return textboxRole;
}

var timeRole = {};

var hasRequiredTimeRole$1;

function requireTimeRole$1 () {
	if (hasRequiredTimeRole$1) return timeRole;
	hasRequiredTimeRole$1 = 1;

	Object.defineProperty(timeRole, "__esModule", {
	  value: true
	});
	timeRole.default = void 0;
	var timeRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'time'
	    },
	    module: 'HTML'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = timeRole$1;
	timeRole.default = _default;
	return timeRole;
}

var timerRole = {};

var hasRequiredTimerRole$1;

function requireTimerRole$1 () {
	if (hasRequiredTimerRole$1) return timerRole;
	hasRequiredTimerRole$1 = 1;

	Object.defineProperty(timerRole, "__esModule", {
	  value: true
	});
	timerRole.default = void 0;
	var timerRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'status']]
	};
	var _default = timerRole$1;
	timerRole.default = _default;
	return timerRole;
}

var toolbarRole = {};

var hasRequiredToolbarRole$1;

function requireToolbarRole$1 () {
	if (hasRequiredToolbarRole$1) return toolbarRole;
	hasRequiredToolbarRole$1 = 1;

	Object.defineProperty(toolbarRole, "__esModule", {
	  value: true
	});
	toolbarRole.default = void 0;
	var toolbarRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-orientation': 'horizontal'
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'menubar'
	    },
	    module: 'ARIA'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'group']]
	};
	var _default = toolbarRole$1;
	toolbarRole.default = _default;
	return toolbarRole;
}

var tooltipRole = {};

var hasRequiredTooltipRole;

function requireTooltipRole () {
	if (hasRequiredTooltipRole) return tooltipRole;
	hasRequiredTooltipRole = 1;

	Object.defineProperty(tooltipRole, "__esModule", {
	  value: true
	});
	tooltipRole.default = void 0;
	var tooltipRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = tooltipRole$1;
	tooltipRole.default = _default;
	return tooltipRole;
}

var treeRole = {};

var hasRequiredTreeRole$1;

function requireTreeRole$1 () {
	if (hasRequiredTreeRole$1) return treeRole;
	hasRequiredTreeRole$1 = 1;

	Object.defineProperty(treeRole, "__esModule", {
	  value: true
	});
	treeRole.default = void 0;
	var treeRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-invalid': null,
	    'aria-multiselectable': null,
	    'aria-required': null,
	    'aria-orientation': 'vertical'
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['treeitem', 'group'], ['treeitem']],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite', 'select'], ['roletype', 'structure', 'section', 'group', 'select']]
	};
	var _default = treeRole$1;
	treeRole.default = _default;
	return treeRole;
}

var treegridRole = {};

var hasRequiredTreegridRole;

function requireTreegridRole () {
	if (hasRequiredTreegridRole) return treegridRole;
	hasRequiredTreegridRole = 1;

	Object.defineProperty(treegridRole, "__esModule", {
	  value: true
	});
	treegridRole.default = void 0;
	var treegridRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['row'], ['row', 'rowgroup']],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'composite', 'grid'], ['roletype', 'structure', 'section', 'table', 'grid'], ['roletype', 'widget', 'composite', 'select', 'tree'], ['roletype', 'structure', 'section', 'group', 'select', 'tree']]
	};
	var _default = treegridRole$1;
	treegridRole.default = _default;
	return treegridRole;
}

var treeitemRole = {};

var hasRequiredTreeitemRole;

function requireTreeitemRole () {
	if (hasRequiredTreeitemRole) return treeitemRole;
	hasRequiredTreeitemRole = 1;

	Object.defineProperty(treeitemRole, "__esModule", {
	  value: true
	});
	treeitemRole.default = void 0;
	var treeitemRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-expanded': null,
	    'aria-haspopup': null
	  },
	  relatedConcepts: [],
	  requireContextRole: ['group', 'tree'],
	  requiredContextRole: ['group', 'tree'],
	  requiredOwnedElements: [],
	  requiredProps: {
	    'aria-selected': null
	  },
	  superClass: [['roletype', 'structure', 'section', 'listitem'], ['roletype', 'widget', 'input', 'option']]
	};
	var _default = treeitemRole$1;
	treeitemRole.default = _default;
	return treeitemRole;
}

var hasRequiredAriaLiteralRoles;

function requireAriaLiteralRoles () {
	if (hasRequiredAriaLiteralRoles) return ariaLiteralRoles;
	hasRequiredAriaLiteralRoles = 1;

	Object.defineProperty(ariaLiteralRoles, "__esModule", {
	  value: true
	});
	ariaLiteralRoles.default = void 0;
	var _alertRole = _interopRequireDefault(requireAlertRole$1());
	var _alertdialogRole = _interopRequireDefault(requireAlertdialogRole());
	var _applicationRole = _interopRequireDefault(requireApplicationRole$1());
	var _articleRole = _interopRequireDefault(requireArticleRole$1());
	var _bannerRole = _interopRequireDefault(requireBannerRole$1());
	var _blockquoteRole = _interopRequireDefault(requireBlockquoteRole$1());
	var _buttonRole = _interopRequireDefault(requireButtonRole$1());
	var _captionRole = _interopRequireDefault(requireCaptionRole$1());
	var _cellRole = _interopRequireDefault(requireCellRole$1());
	var _checkboxRole = _interopRequireDefault(requireCheckboxRole());
	var _codeRole = _interopRequireDefault(requireCodeRole());
	var _columnheaderRole = _interopRequireDefault(requireColumnheaderRole());
	var _comboboxRole = _interopRequireDefault(requireComboboxRole());
	var _complementaryRole = _interopRequireDefault(requireComplementaryRole$1());
	var _contentinfoRole = _interopRequireDefault(requireContentinfoRole());
	var _definitionRole = _interopRequireDefault(requireDefinitionRole$1());
	var _deletionRole = _interopRequireDefault(requireDeletionRole());
	var _dialogRole = _interopRequireDefault(requireDialogRole$1());
	var _directoryRole = _interopRequireDefault(requireDirectoryRole$1());
	var _documentRole = _interopRequireDefault(requireDocumentRole$1());
	var _emphasisRole = _interopRequireDefault(requireEmphasisRole());
	var _feedRole = _interopRequireDefault(requireFeedRole$1());
	var _figureRole = _interopRequireDefault(requireFigureRole$1());
	var _formRole = _interopRequireDefault(requireFormRole$1());
	var _genericRole = _interopRequireDefault(requireGenericRole());
	var _gridRole = _interopRequireDefault(requireGridRole$1());
	var _gridcellRole = _interopRequireDefault(requireGridcellRole());
	var _groupRole = _interopRequireDefault(requireGroupRole$1());
	var _headingRole = _interopRequireDefault(requireHeadingRole$1());
	var _imgRole = _interopRequireDefault(requireImgRole());
	var _insertionRole = _interopRequireDefault(requireInsertionRole());
	var _linkRole = _interopRequireDefault(requireLinkRole$1());
	var _listRole = _interopRequireDefault(requireListRole$1());
	var _listboxRole = _interopRequireDefault(requireListboxRole());
	var _listitemRole = _interopRequireDefault(requireListitemRole());
	var _logRole = _interopRequireDefault(requireLogRole$1());
	var _mainRole = _interopRequireDefault(requireMainRole$1());
	var _markRole = _interopRequireDefault(requireMarkRole$1());
	var _marqueeRole = _interopRequireDefault(requireMarqueeRole$1());
	var _mathRole = _interopRequireDefault(requireMathRole$1());
	var _menuRole = _interopRequireDefault(requireMenuRole$1());
	var _menubarRole = _interopRequireDefault(requireMenubarRole());
	var _menuitemRole = _interopRequireDefault(requireMenuitemRole());
	var _menuitemcheckboxRole = _interopRequireDefault(requireMenuitemcheckboxRole());
	var _menuitemradioRole = _interopRequireDefault(requireMenuitemradioRole());
	var _meterRole = _interopRequireDefault(requireMeterRole$1());
	var _navigationRole = _interopRequireDefault(requireNavigationRole$1());
	var _noneRole = _interopRequireDefault(requireNoneRole$1());
	var _noteRole = _interopRequireDefault(requireNoteRole$1());
	var _optionRole = _interopRequireDefault(requireOptionRole());
	var _paragraphRole = _interopRequireDefault(requireParagraphRole$1());
	var _presentationRole = _interopRequireDefault(requirePresentationRole());
	var _progressbarRole = _interopRequireDefault(requireProgressbarRole());
	var _radioRole = _interopRequireDefault(requireRadioRole());
	var _radiogroupRole = _interopRequireDefault(requireRadiogroupRole());
	var _regionRole = _interopRequireDefault(requireRegionRole$1());
	var _rowRole = _interopRequireDefault(requireRowRole$1());
	var _rowgroupRole = _interopRequireDefault(requireRowgroupRole());
	var _rowheaderRole = _interopRequireDefault(requireRowheaderRole());
	var _scrollbarRole = _interopRequireDefault(requireScrollbarRole());
	var _searchRole = _interopRequireDefault(requireSearchRole$1());
	var _searchboxRole = _interopRequireDefault(requireSearchboxRole());
	var _separatorRole = _interopRequireDefault(requireSeparatorRole());
	var _sliderRole = _interopRequireDefault(requireSliderRole$1());
	var _spinbuttonRole = _interopRequireDefault(requireSpinbuttonRole());
	var _statusRole = _interopRequireDefault(requireStatusRole$1());
	var _strongRole = _interopRequireDefault(requireStrongRole());
	var _subscriptRole = _interopRequireDefault(requireSubscriptRole());
	var _superscriptRole = _interopRequireDefault(requireSuperscriptRole());
	var _switchRole = _interopRequireDefault(requireSwitchRole$1());
	var _tabRole = _interopRequireDefault(requireTabRole$1());
	var _tableRole = _interopRequireDefault(requireTableRole$1());
	var _tablistRole = _interopRequireDefault(requireTablistRole());
	var _tabpanelRole = _interopRequireDefault(requireTabpanelRole());
	var _termRole = _interopRequireDefault(requireTermRole$1());
	var _textboxRole = _interopRequireDefault(requireTextboxRole());
	var _timeRole = _interopRequireDefault(requireTimeRole$1());
	var _timerRole = _interopRequireDefault(requireTimerRole$1());
	var _toolbarRole = _interopRequireDefault(requireToolbarRole$1());
	var _tooltipRole = _interopRequireDefault(requireTooltipRole());
	var _treeRole = _interopRequireDefault(requireTreeRole$1());
	var _treegridRole = _interopRequireDefault(requireTreegridRole());
	var _treeitemRole = _interopRequireDefault(requireTreeitemRole());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ariaLiteralRoles$1 = [['alert', _alertRole.default], ['alertdialog', _alertdialogRole.default], ['application', _applicationRole.default], ['article', _articleRole.default], ['banner', _bannerRole.default], ['blockquote', _blockquoteRole.default], ['button', _buttonRole.default], ['caption', _captionRole.default], ['cell', _cellRole.default], ['checkbox', _checkboxRole.default], ['code', _codeRole.default], ['columnheader', _columnheaderRole.default], ['combobox', _comboboxRole.default], ['complementary', _complementaryRole.default], ['contentinfo', _contentinfoRole.default], ['definition', _definitionRole.default], ['deletion', _deletionRole.default], ['dialog', _dialogRole.default], ['directory', _directoryRole.default], ['document', _documentRole.default], ['emphasis', _emphasisRole.default], ['feed', _feedRole.default], ['figure', _figureRole.default], ['form', _formRole.default], ['generic', _genericRole.default], ['grid', _gridRole.default], ['gridcell', _gridcellRole.default], ['group', _groupRole.default], ['heading', _headingRole.default], ['img', _imgRole.default], ['insertion', _insertionRole.default], ['link', _linkRole.default], ['list', _listRole.default], ['listbox', _listboxRole.default], ['listitem', _listitemRole.default], ['log', _logRole.default], ['main', _mainRole.default], ['mark', _markRole.default], ['marquee', _marqueeRole.default], ['math', _mathRole.default], ['menu', _menuRole.default], ['menubar', _menubarRole.default], ['menuitem', _menuitemRole.default], ['menuitemcheckbox', _menuitemcheckboxRole.default], ['menuitemradio', _menuitemradioRole.default], ['meter', _meterRole.default], ['navigation', _navigationRole.default], ['none', _noneRole.default], ['note', _noteRole.default], ['option', _optionRole.default], ['paragraph', _paragraphRole.default], ['presentation', _presentationRole.default], ['progressbar', _progressbarRole.default], ['radio', _radioRole.default], ['radiogroup', _radiogroupRole.default], ['region', _regionRole.default], ['row', _rowRole.default], ['rowgroup', _rowgroupRole.default], ['rowheader', _rowheaderRole.default], ['scrollbar', _scrollbarRole.default], ['search', _searchRole.default], ['searchbox', _searchboxRole.default], ['separator', _separatorRole.default], ['slider', _sliderRole.default], ['spinbutton', _spinbuttonRole.default], ['status', _statusRole.default], ['strong', _strongRole.default], ['subscript', _subscriptRole.default], ['superscript', _superscriptRole.default], ['switch', _switchRole.default], ['tab', _tabRole.default], ['table', _tableRole.default], ['tablist', _tablistRole.default], ['tabpanel', _tabpanelRole.default], ['term', _termRole.default], ['textbox', _textboxRole.default], ['time', _timeRole.default], ['timer', _timerRole.default], ['toolbar', _toolbarRole.default], ['tooltip', _tooltipRole.default], ['tree', _treeRole.default], ['treegrid', _treegridRole.default], ['treeitem', _treeitemRole.default]];
	var _default = ariaLiteralRoles$1;
	ariaLiteralRoles.default = _default;
	return ariaLiteralRoles;
}

var ariaDpubRoles = {};

var docAbstractRole = {};

var hasRequiredDocAbstractRole;

function requireDocAbstractRole () {
	if (hasRequiredDocAbstractRole) return docAbstractRole;
	hasRequiredDocAbstractRole = 1;

	Object.defineProperty(docAbstractRole, "__esModule", {
	  value: true
	});
	docAbstractRole.default = void 0;
	var docAbstractRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'abstract [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = docAbstractRole$1;
	docAbstractRole.default = _default;
	return docAbstractRole;
}

var docAcknowledgmentsRole = {};

var hasRequiredDocAcknowledgmentsRole;

function requireDocAcknowledgmentsRole () {
	if (hasRequiredDocAcknowledgmentsRole) return docAcknowledgmentsRole;
	hasRequiredDocAcknowledgmentsRole = 1;

	Object.defineProperty(docAcknowledgmentsRole, "__esModule", {
	  value: true
	});
	docAcknowledgmentsRole.default = void 0;
	var docAcknowledgmentsRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'acknowledgments [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = docAcknowledgmentsRole$1;
	docAcknowledgmentsRole.default = _default;
	return docAcknowledgmentsRole;
}

var docAfterwordRole = {};

var hasRequiredDocAfterwordRole;

function requireDocAfterwordRole () {
	if (hasRequiredDocAfterwordRole) return docAfterwordRole;
	hasRequiredDocAfterwordRole = 1;

	Object.defineProperty(docAfterwordRole, "__esModule", {
	  value: true
	});
	docAfterwordRole.default = void 0;
	var docAfterwordRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'afterword [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = docAfterwordRole$1;
	docAfterwordRole.default = _default;
	return docAfterwordRole;
}

var docAppendixRole = {};

var hasRequiredDocAppendixRole;

function requireDocAppendixRole () {
	if (hasRequiredDocAppendixRole) return docAppendixRole;
	hasRequiredDocAppendixRole = 1;

	Object.defineProperty(docAppendixRole, "__esModule", {
	  value: true
	});
	docAppendixRole.default = void 0;
	var docAppendixRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'appendix [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = docAppendixRole$1;
	docAppendixRole.default = _default;
	return docAppendixRole;
}

var docBacklinkRole = {};

var hasRequiredDocBacklinkRole;

function requireDocBacklinkRole () {
	if (hasRequiredDocBacklinkRole) return docBacklinkRole;
	hasRequiredDocBacklinkRole = 1;

	Object.defineProperty(docBacklinkRole, "__esModule", {
	  value: true
	});
	docBacklinkRole.default = void 0;
	var docBacklinkRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'referrer [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'command', 'link']]
	};
	var _default = docBacklinkRole$1;
	docBacklinkRole.default = _default;
	return docBacklinkRole;
}

var docBiblioentryRole = {};

var hasRequiredDocBiblioentryRole;

function requireDocBiblioentryRole () {
	if (hasRequiredDocBiblioentryRole) return docBiblioentryRole;
	hasRequiredDocBiblioentryRole = 1;

	Object.defineProperty(docBiblioentryRole, "__esModule", {
	  value: true
	});
	docBiblioentryRole.default = void 0;
	var docBiblioentryRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'EPUB biblioentry [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: ['doc-bibliography'],
	  requiredContextRole: ['doc-bibliography'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'listitem']]
	};
	var _default = docBiblioentryRole$1;
	docBiblioentryRole.default = _default;
	return docBiblioentryRole;
}

var docBibliographyRole = {};

var hasRequiredDocBibliographyRole;

function requireDocBibliographyRole () {
	if (hasRequiredDocBibliographyRole) return docBibliographyRole;
	hasRequiredDocBibliographyRole = 1;

	Object.defineProperty(docBibliographyRole, "__esModule", {
	  value: true
	});
	docBibliographyRole.default = void 0;
	var docBibliographyRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'bibliography [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['doc-biblioentry']],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = docBibliographyRole$1;
	docBibliographyRole.default = _default;
	return docBibliographyRole;
}

var docBibliorefRole = {};

var hasRequiredDocBibliorefRole;

function requireDocBibliorefRole () {
	if (hasRequiredDocBibliorefRole) return docBibliorefRole;
	hasRequiredDocBibliorefRole = 1;

	Object.defineProperty(docBibliorefRole, "__esModule", {
	  value: true
	});
	docBibliorefRole.default = void 0;
	var docBibliorefRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'biblioref [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'command', 'link']]
	};
	var _default = docBibliorefRole$1;
	docBibliorefRole.default = _default;
	return docBibliorefRole;
}

var docChapterRole = {};

var hasRequiredDocChapterRole;

function requireDocChapterRole () {
	if (hasRequiredDocChapterRole) return docChapterRole;
	hasRequiredDocChapterRole = 1;

	Object.defineProperty(docChapterRole, "__esModule", {
	  value: true
	});
	docChapterRole.default = void 0;
	var docChapterRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'chapter [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = docChapterRole$1;
	docChapterRole.default = _default;
	return docChapterRole;
}

var docColophonRole = {};

var hasRequiredDocColophonRole;

function requireDocColophonRole () {
	if (hasRequiredDocColophonRole) return docColophonRole;
	hasRequiredDocColophonRole = 1;

	Object.defineProperty(docColophonRole, "__esModule", {
	  value: true
	});
	docColophonRole.default = void 0;
	var docColophonRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'colophon [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = docColophonRole$1;
	docColophonRole.default = _default;
	return docColophonRole;
}

var docConclusionRole = {};

var hasRequiredDocConclusionRole;

function requireDocConclusionRole () {
	if (hasRequiredDocConclusionRole) return docConclusionRole;
	hasRequiredDocConclusionRole = 1;

	Object.defineProperty(docConclusionRole, "__esModule", {
	  value: true
	});
	docConclusionRole.default = void 0;
	var docConclusionRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'conclusion [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = docConclusionRole$1;
	docConclusionRole.default = _default;
	return docConclusionRole;
}

var docCoverRole = {};

var hasRequiredDocCoverRole;

function requireDocCoverRole () {
	if (hasRequiredDocCoverRole) return docCoverRole;
	hasRequiredDocCoverRole = 1;

	Object.defineProperty(docCoverRole, "__esModule", {
	  value: true
	});
	docCoverRole.default = void 0;
	var docCoverRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'cover [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'img']]
	};
	var _default = docCoverRole$1;
	docCoverRole.default = _default;
	return docCoverRole;
}

var docCreditRole = {};

var hasRequiredDocCreditRole;

function requireDocCreditRole () {
	if (hasRequiredDocCreditRole) return docCreditRole;
	hasRequiredDocCreditRole = 1;

	Object.defineProperty(docCreditRole, "__esModule", {
	  value: true
	});
	docCreditRole.default = void 0;
	var docCreditRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'credit [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = docCreditRole$1;
	docCreditRole.default = _default;
	return docCreditRole;
}

var docCreditsRole = {};

var hasRequiredDocCreditsRole;

function requireDocCreditsRole () {
	if (hasRequiredDocCreditsRole) return docCreditsRole;
	hasRequiredDocCreditsRole = 1;

	Object.defineProperty(docCreditsRole, "__esModule", {
	  value: true
	});
	docCreditsRole.default = void 0;
	var docCreditsRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'credits [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = docCreditsRole$1;
	docCreditsRole.default = _default;
	return docCreditsRole;
}

var docDedicationRole = {};

var hasRequiredDocDedicationRole;

function requireDocDedicationRole () {
	if (hasRequiredDocDedicationRole) return docDedicationRole;
	hasRequiredDocDedicationRole = 1;

	Object.defineProperty(docDedicationRole, "__esModule", {
	  value: true
	});
	docDedicationRole.default = void 0;
	var docDedicationRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'dedication [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = docDedicationRole$1;
	docDedicationRole.default = _default;
	return docDedicationRole;
}

var docEndnoteRole = {};

var hasRequiredDocEndnoteRole;

function requireDocEndnoteRole () {
	if (hasRequiredDocEndnoteRole) return docEndnoteRole;
	hasRequiredDocEndnoteRole = 1;

	Object.defineProperty(docEndnoteRole, "__esModule", {
	  value: true
	});
	docEndnoteRole.default = void 0;
	var docEndnoteRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'rearnote [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: ['doc-endnotes'],
	  requiredContextRole: ['doc-endnotes'],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'listitem']]
	};
	var _default = docEndnoteRole$1;
	docEndnoteRole.default = _default;
	return docEndnoteRole;
}

var docEndnotesRole = {};

var hasRequiredDocEndnotesRole;

function requireDocEndnotesRole () {
	if (hasRequiredDocEndnotesRole) return docEndnotesRole;
	hasRequiredDocEndnotesRole = 1;

	Object.defineProperty(docEndnotesRole, "__esModule", {
	  value: true
	});
	docEndnotesRole.default = void 0;
	var docEndnotesRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'rearnotes [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['doc-endnote']],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = docEndnotesRole$1;
	docEndnotesRole.default = _default;
	return docEndnotesRole;
}

var docEpigraphRole = {};

var hasRequiredDocEpigraphRole;

function requireDocEpigraphRole () {
	if (hasRequiredDocEpigraphRole) return docEpigraphRole;
	hasRequiredDocEpigraphRole = 1;

	Object.defineProperty(docEpigraphRole, "__esModule", {
	  value: true
	});
	docEpigraphRole.default = void 0;
	var docEpigraphRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'epigraph [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = docEpigraphRole$1;
	docEpigraphRole.default = _default;
	return docEpigraphRole;
}

var docEpilogueRole = {};

var hasRequiredDocEpilogueRole;

function requireDocEpilogueRole () {
	if (hasRequiredDocEpilogueRole) return docEpilogueRole;
	hasRequiredDocEpilogueRole = 1;

	Object.defineProperty(docEpilogueRole, "__esModule", {
	  value: true
	});
	docEpilogueRole.default = void 0;
	var docEpilogueRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'epilogue [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = docEpilogueRole$1;
	docEpilogueRole.default = _default;
	return docEpilogueRole;
}

var docErrataRole = {};

var hasRequiredDocErrataRole;

function requireDocErrataRole () {
	if (hasRequiredDocErrataRole) return docErrataRole;
	hasRequiredDocErrataRole = 1;

	Object.defineProperty(docErrataRole, "__esModule", {
	  value: true
	});
	docErrataRole.default = void 0;
	var docErrataRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'errata [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = docErrataRole$1;
	docErrataRole.default = _default;
	return docErrataRole;
}

var docExampleRole = {};

var hasRequiredDocExampleRole;

function requireDocExampleRole () {
	if (hasRequiredDocExampleRole) return docExampleRole;
	hasRequiredDocExampleRole = 1;

	Object.defineProperty(docExampleRole, "__esModule", {
	  value: true
	});
	docExampleRole.default = void 0;
	var docExampleRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = docExampleRole$1;
	docExampleRole.default = _default;
	return docExampleRole;
}

var docFootnoteRole = {};

var hasRequiredDocFootnoteRole;

function requireDocFootnoteRole () {
	if (hasRequiredDocFootnoteRole) return docFootnoteRole;
	hasRequiredDocFootnoteRole = 1;

	Object.defineProperty(docFootnoteRole, "__esModule", {
	  value: true
	});
	docFootnoteRole.default = void 0;
	var docFootnoteRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'footnote [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = docFootnoteRole$1;
	docFootnoteRole.default = _default;
	return docFootnoteRole;
}

var docForewordRole = {};

var hasRequiredDocForewordRole;

function requireDocForewordRole () {
	if (hasRequiredDocForewordRole) return docForewordRole;
	hasRequiredDocForewordRole = 1;

	Object.defineProperty(docForewordRole, "__esModule", {
	  value: true
	});
	docForewordRole.default = void 0;
	var docForewordRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'foreword [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = docForewordRole$1;
	docForewordRole.default = _default;
	return docForewordRole;
}

var docGlossaryRole = {};

var hasRequiredDocGlossaryRole;

function requireDocGlossaryRole () {
	if (hasRequiredDocGlossaryRole) return docGlossaryRole;
	hasRequiredDocGlossaryRole = 1;

	Object.defineProperty(docGlossaryRole, "__esModule", {
	  value: true
	});
	docGlossaryRole.default = void 0;
	var docGlossaryRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'glossary [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [['definition'], ['term']],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = docGlossaryRole$1;
	docGlossaryRole.default = _default;
	return docGlossaryRole;
}

var docGlossrefRole = {};

var hasRequiredDocGlossrefRole;

function requireDocGlossrefRole () {
	if (hasRequiredDocGlossrefRole) return docGlossrefRole;
	hasRequiredDocGlossrefRole = 1;

	Object.defineProperty(docGlossrefRole, "__esModule", {
	  value: true
	});
	docGlossrefRole.default = void 0;
	var docGlossrefRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'glossref [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'command', 'link']]
	};
	var _default = docGlossrefRole$1;
	docGlossrefRole.default = _default;
	return docGlossrefRole;
}

var docIndexRole = {};

var hasRequiredDocIndexRole;

function requireDocIndexRole () {
	if (hasRequiredDocIndexRole) return docIndexRole;
	hasRequiredDocIndexRole = 1;

	Object.defineProperty(docIndexRole, "__esModule", {
	  value: true
	});
	docIndexRole.default = void 0;
	var docIndexRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'index [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']]
	};
	var _default = docIndexRole$1;
	docIndexRole.default = _default;
	return docIndexRole;
}

var docIntroductionRole = {};

var hasRequiredDocIntroductionRole;

function requireDocIntroductionRole () {
	if (hasRequiredDocIntroductionRole) return docIntroductionRole;
	hasRequiredDocIntroductionRole = 1;

	Object.defineProperty(docIntroductionRole, "__esModule", {
	  value: true
	});
	docIntroductionRole.default = void 0;
	var docIntroductionRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'introduction [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = docIntroductionRole$1;
	docIntroductionRole.default = _default;
	return docIntroductionRole;
}

var docNoterefRole = {};

var hasRequiredDocNoterefRole;

function requireDocNoterefRole () {
	if (hasRequiredDocNoterefRole) return docNoterefRole;
	hasRequiredDocNoterefRole = 1;

	Object.defineProperty(docNoterefRole, "__esModule", {
	  value: true
	});
	docNoterefRole.default = void 0;
	var docNoterefRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'noteref [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'widget', 'command', 'link']]
	};
	var _default = docNoterefRole$1;
	docNoterefRole.default = _default;
	return docNoterefRole;
}

var docNoticeRole = {};

var hasRequiredDocNoticeRole;

function requireDocNoticeRole () {
	if (hasRequiredDocNoticeRole) return docNoticeRole;
	hasRequiredDocNoticeRole = 1;

	Object.defineProperty(docNoticeRole, "__esModule", {
	  value: true
	});
	docNoticeRole.default = void 0;
	var docNoticeRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'notice [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'note']]
	};
	var _default = docNoticeRole$1;
	docNoticeRole.default = _default;
	return docNoticeRole;
}

var docPagebreakRole = {};

var hasRequiredDocPagebreakRole;

function requireDocPagebreakRole () {
	if (hasRequiredDocPagebreakRole) return docPagebreakRole;
	hasRequiredDocPagebreakRole = 1;

	Object.defineProperty(docPagebreakRole, "__esModule", {
	  value: true
	});
	docPagebreakRole.default = void 0;
	var docPagebreakRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'pagebreak [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'separator']]
	};
	var _default = docPagebreakRole$1;
	docPagebreakRole.default = _default;
	return docPagebreakRole;
}

var docPagelistRole = {};

var hasRequiredDocPagelistRole;

function requireDocPagelistRole () {
	if (hasRequiredDocPagelistRole) return docPagelistRole;
	hasRequiredDocPagelistRole = 1;

	Object.defineProperty(docPagelistRole, "__esModule", {
	  value: true
	});
	docPagelistRole.default = void 0;
	var docPagelistRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'page-list [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']]
	};
	var _default = docPagelistRole$1;
	docPagelistRole.default = _default;
	return docPagelistRole;
}

var docPartRole = {};

var hasRequiredDocPartRole;

function requireDocPartRole () {
	if (hasRequiredDocPartRole) return docPartRole;
	hasRequiredDocPartRole = 1;

	Object.defineProperty(docPartRole, "__esModule", {
	  value: true
	});
	docPartRole.default = void 0;
	var docPartRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'part [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = docPartRole$1;
	docPartRole.default = _default;
	return docPartRole;
}

var docPrefaceRole = {};

var hasRequiredDocPrefaceRole;

function requireDocPrefaceRole () {
	if (hasRequiredDocPrefaceRole) return docPrefaceRole;
	hasRequiredDocPrefaceRole = 1;

	Object.defineProperty(docPrefaceRole, "__esModule", {
	  value: true
	});
	docPrefaceRole.default = void 0;
	var docPrefaceRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'preface [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = docPrefaceRole$1;
	docPrefaceRole.default = _default;
	return docPrefaceRole;
}

var docPrologueRole = {};

var hasRequiredDocPrologueRole;

function requireDocPrologueRole () {
	if (hasRequiredDocPrologueRole) return docPrologueRole;
	hasRequiredDocPrologueRole = 1;

	Object.defineProperty(docPrologueRole, "__esModule", {
	  value: true
	});
	docPrologueRole.default = void 0;
	var docPrologueRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'prologue [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark']]
	};
	var _default = docPrologueRole$1;
	docPrologueRole.default = _default;
	return docPrologueRole;
}

var docPullquoteRole = {};

var hasRequiredDocPullquoteRole;

function requireDocPullquoteRole () {
	if (hasRequiredDocPullquoteRole) return docPullquoteRole;
	hasRequiredDocPullquoteRole = 1;

	Object.defineProperty(docPullquoteRole, "__esModule", {
	  value: true
	});
	docPullquoteRole.default = void 0;
	var docPullquoteRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {},
	  relatedConcepts: [{
	    concept: {
	      name: 'pullquote [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['none']]
	};
	var _default = docPullquoteRole$1;
	docPullquoteRole.default = _default;
	return docPullquoteRole;
}

var docQnaRole = {};

var hasRequiredDocQnaRole;

function requireDocQnaRole () {
	if (hasRequiredDocQnaRole) return docQnaRole;
	hasRequiredDocQnaRole = 1;

	Object.defineProperty(docQnaRole, "__esModule", {
	  value: true
	});
	docQnaRole.default = void 0;
	var docQnaRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'qna [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section']]
	};
	var _default = docQnaRole$1;
	docQnaRole.default = _default;
	return docQnaRole;
}

var docSubtitleRole = {};

var hasRequiredDocSubtitleRole;

function requireDocSubtitleRole () {
	if (hasRequiredDocSubtitleRole) return docSubtitleRole;
	hasRequiredDocSubtitleRole = 1;

	Object.defineProperty(docSubtitleRole, "__esModule", {
	  value: true
	});
	docSubtitleRole.default = void 0;
	var docSubtitleRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'subtitle [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'sectionhead']]
	};
	var _default = docSubtitleRole$1;
	docSubtitleRole.default = _default;
	return docSubtitleRole;
}

var docTipRole = {};

var hasRequiredDocTipRole;

function requireDocTipRole () {
	if (hasRequiredDocTipRole) return docTipRole;
	hasRequiredDocTipRole = 1;

	Object.defineProperty(docTipRole, "__esModule", {
	  value: true
	});
	docTipRole.default = void 0;
	var docTipRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'help [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'note']]
	};
	var _default = docTipRole$1;
	docTipRole.default = _default;
	return docTipRole;
}

var docTocRole = {};

var hasRequiredDocTocRole;

function requireDocTocRole () {
	if (hasRequiredDocTocRole) return docTocRole;
	hasRequiredDocTocRole = 1;

	Object.defineProperty(docTocRole, "__esModule", {
	  value: true
	});
	docTocRole.default = void 0;
	var docTocRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    concept: {
	      name: 'toc [EPUB-SSV]'
	    },
	    module: 'EPUB'
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'landmark', 'navigation']]
	};
	var _default = docTocRole$1;
	docTocRole.default = _default;
	return docTocRole;
}

var hasRequiredAriaDpubRoles;

function requireAriaDpubRoles () {
	if (hasRequiredAriaDpubRoles) return ariaDpubRoles;
	hasRequiredAriaDpubRoles = 1;

	Object.defineProperty(ariaDpubRoles, "__esModule", {
	  value: true
	});
	ariaDpubRoles.default = void 0;
	var _docAbstractRole = _interopRequireDefault(requireDocAbstractRole());
	var _docAcknowledgmentsRole = _interopRequireDefault(requireDocAcknowledgmentsRole());
	var _docAfterwordRole = _interopRequireDefault(requireDocAfterwordRole());
	var _docAppendixRole = _interopRequireDefault(requireDocAppendixRole());
	var _docBacklinkRole = _interopRequireDefault(requireDocBacklinkRole());
	var _docBiblioentryRole = _interopRequireDefault(requireDocBiblioentryRole());
	var _docBibliographyRole = _interopRequireDefault(requireDocBibliographyRole());
	var _docBibliorefRole = _interopRequireDefault(requireDocBibliorefRole());
	var _docChapterRole = _interopRequireDefault(requireDocChapterRole());
	var _docColophonRole = _interopRequireDefault(requireDocColophonRole());
	var _docConclusionRole = _interopRequireDefault(requireDocConclusionRole());
	var _docCoverRole = _interopRequireDefault(requireDocCoverRole());
	var _docCreditRole = _interopRequireDefault(requireDocCreditRole());
	var _docCreditsRole = _interopRequireDefault(requireDocCreditsRole());
	var _docDedicationRole = _interopRequireDefault(requireDocDedicationRole());
	var _docEndnoteRole = _interopRequireDefault(requireDocEndnoteRole());
	var _docEndnotesRole = _interopRequireDefault(requireDocEndnotesRole());
	var _docEpigraphRole = _interopRequireDefault(requireDocEpigraphRole());
	var _docEpilogueRole = _interopRequireDefault(requireDocEpilogueRole());
	var _docErrataRole = _interopRequireDefault(requireDocErrataRole());
	var _docExampleRole = _interopRequireDefault(requireDocExampleRole());
	var _docFootnoteRole = _interopRequireDefault(requireDocFootnoteRole());
	var _docForewordRole = _interopRequireDefault(requireDocForewordRole());
	var _docGlossaryRole = _interopRequireDefault(requireDocGlossaryRole());
	var _docGlossrefRole = _interopRequireDefault(requireDocGlossrefRole());
	var _docIndexRole = _interopRequireDefault(requireDocIndexRole());
	var _docIntroductionRole = _interopRequireDefault(requireDocIntroductionRole());
	var _docNoterefRole = _interopRequireDefault(requireDocNoterefRole());
	var _docNoticeRole = _interopRequireDefault(requireDocNoticeRole());
	var _docPagebreakRole = _interopRequireDefault(requireDocPagebreakRole());
	var _docPagelistRole = _interopRequireDefault(requireDocPagelistRole());
	var _docPartRole = _interopRequireDefault(requireDocPartRole());
	var _docPrefaceRole = _interopRequireDefault(requireDocPrefaceRole());
	var _docPrologueRole = _interopRequireDefault(requireDocPrologueRole());
	var _docPullquoteRole = _interopRequireDefault(requireDocPullquoteRole());
	var _docQnaRole = _interopRequireDefault(requireDocQnaRole());
	var _docSubtitleRole = _interopRequireDefault(requireDocSubtitleRole());
	var _docTipRole = _interopRequireDefault(requireDocTipRole());
	var _docTocRole = _interopRequireDefault(requireDocTocRole());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ariaDpubRoles$1 = [['doc-abstract', _docAbstractRole.default], ['doc-acknowledgments', _docAcknowledgmentsRole.default], ['doc-afterword', _docAfterwordRole.default], ['doc-appendix', _docAppendixRole.default], ['doc-backlink', _docBacklinkRole.default], ['doc-biblioentry', _docBiblioentryRole.default], ['doc-bibliography', _docBibliographyRole.default], ['doc-biblioref', _docBibliorefRole.default], ['doc-chapter', _docChapterRole.default], ['doc-colophon', _docColophonRole.default], ['doc-conclusion', _docConclusionRole.default], ['doc-cover', _docCoverRole.default], ['doc-credit', _docCreditRole.default], ['doc-credits', _docCreditsRole.default], ['doc-dedication', _docDedicationRole.default], ['doc-endnote', _docEndnoteRole.default], ['doc-endnotes', _docEndnotesRole.default], ['doc-epigraph', _docEpigraphRole.default], ['doc-epilogue', _docEpilogueRole.default], ['doc-errata', _docErrataRole.default], ['doc-example', _docExampleRole.default], ['doc-footnote', _docFootnoteRole.default], ['doc-foreword', _docForewordRole.default], ['doc-glossary', _docGlossaryRole.default], ['doc-glossref', _docGlossrefRole.default], ['doc-index', _docIndexRole.default], ['doc-introduction', _docIntroductionRole.default], ['doc-noteref', _docNoterefRole.default], ['doc-notice', _docNoticeRole.default], ['doc-pagebreak', _docPagebreakRole.default], ['doc-pagelist', _docPagelistRole.default], ['doc-part', _docPartRole.default], ['doc-preface', _docPrefaceRole.default], ['doc-prologue', _docPrologueRole.default], ['doc-pullquote', _docPullquoteRole.default], ['doc-qna', _docQnaRole.default], ['doc-subtitle', _docSubtitleRole.default], ['doc-tip', _docTipRole.default], ['doc-toc', _docTocRole.default]];
	var _default = ariaDpubRoles$1;
	ariaDpubRoles.default = _default;
	return ariaDpubRoles;
}

var ariaGraphicsRoles = {};

var graphicsDocumentRole = {};

var hasRequiredGraphicsDocumentRole;

function requireGraphicsDocumentRole () {
	if (hasRequiredGraphicsDocumentRole) return graphicsDocumentRole;
	hasRequiredGraphicsDocumentRole = 1;

	Object.defineProperty(graphicsDocumentRole, "__esModule", {
	  value: true
	});
	graphicsDocumentRole.default = void 0;
	var graphicsDocumentRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    module: 'GRAPHICS',
	    concept: {
	      name: 'graphics-object'
	    }
	  }, {
	    module: 'ARIA',
	    concept: {
	      name: 'img'
	    }
	  }, {
	    module: 'ARIA',
	    concept: {
	      name: 'article'
	    }
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'document']]
	};
	var _default = graphicsDocumentRole$1;
	graphicsDocumentRole.default = _default;
	return graphicsDocumentRole;
}

var graphicsObjectRole = {};

var hasRequiredGraphicsObjectRole;

function requireGraphicsObjectRole () {
	if (hasRequiredGraphicsObjectRole) return graphicsObjectRole;
	hasRequiredGraphicsObjectRole = 1;

	Object.defineProperty(graphicsObjectRole, "__esModule", {
	  value: true
	});
	graphicsObjectRole.default = void 0;
	var graphicsObjectRole$1 = {
	  abstract: false,
	  accessibleNameRequired: false,
	  baseConcepts: [],
	  childrenPresentational: false,
	  nameFrom: ['author', 'contents'],
	  prohibitedProps: [],
	  props: {
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [{
	    module: 'GRAPHICS',
	    concept: {
	      name: 'graphics-document'
	    }
	  }, {
	    module: 'ARIA',
	    concept: {
	      name: 'group'
	    }
	  }, {
	    module: 'ARIA',
	    concept: {
	      name: 'img'
	    }
	  }, {
	    module: 'GRAPHICS',
	    concept: {
	      name: 'graphics-symbol'
	    }
	  }],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'group']]
	};
	var _default = graphicsObjectRole$1;
	graphicsObjectRole.default = _default;
	return graphicsObjectRole;
}

var graphicsSymbolRole = {};

var hasRequiredGraphicsSymbolRole;

function requireGraphicsSymbolRole () {
	if (hasRequiredGraphicsSymbolRole) return graphicsSymbolRole;
	hasRequiredGraphicsSymbolRole = 1;

	Object.defineProperty(graphicsSymbolRole, "__esModule", {
	  value: true
	});
	graphicsSymbolRole.default = void 0;
	var graphicsSymbolRole$1 = {
	  abstract: false,
	  accessibleNameRequired: true,
	  baseConcepts: [],
	  childrenPresentational: true,
	  nameFrom: ['author'],
	  prohibitedProps: [],
	  props: {
	    'aria-disabled': null,
	    'aria-errormessage': null,
	    'aria-expanded': null,
	    'aria-haspopup': null,
	    'aria-invalid': null
	  },
	  relatedConcepts: [],
	  requireContextRole: [],
	  requiredContextRole: [],
	  requiredOwnedElements: [],
	  requiredProps: {},
	  superClass: [['roletype', 'structure', 'section', 'img']]
	};
	var _default = graphicsSymbolRole$1;
	graphicsSymbolRole.default = _default;
	return graphicsSymbolRole;
}

var hasRequiredAriaGraphicsRoles;

function requireAriaGraphicsRoles () {
	if (hasRequiredAriaGraphicsRoles) return ariaGraphicsRoles;
	hasRequiredAriaGraphicsRoles = 1;

	Object.defineProperty(ariaGraphicsRoles, "__esModule", {
	  value: true
	});
	ariaGraphicsRoles.default = void 0;
	var _graphicsDocumentRole = _interopRequireDefault(requireGraphicsDocumentRole());
	var _graphicsObjectRole = _interopRequireDefault(requireGraphicsObjectRole());
	var _graphicsSymbolRole = _interopRequireDefault(requireGraphicsSymbolRole());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var ariaGraphicsRoles$1 = [['graphics-document', _graphicsDocumentRole.default], ['graphics-object', _graphicsObjectRole.default], ['graphics-symbol', _graphicsSymbolRole.default]];
	var _default = ariaGraphicsRoles$1;
	ariaGraphicsRoles.default = _default;
	return ariaGraphicsRoles;
}

var hasRequiredRolesMap;

function requireRolesMap () {
	if (hasRequiredRolesMap) return rolesMap;
	hasRequiredRolesMap = 1;

	Object.defineProperty(rolesMap, "__esModule", {
	  value: true
	});
	rolesMap.default = void 0;
	var _ariaAbstractRoles = _interopRequireDefault(requireAriaAbstractRoles());
	var _ariaLiteralRoles = _interopRequireDefault(requireAriaLiteralRoles());
	var _ariaDpubRoles = _interopRequireDefault(requireAriaDpubRoles());
	var _ariaGraphicsRoles = _interopRequireDefault(requireAriaGraphicsRoles());
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator$1());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
	var roles = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default, _ariaGraphicsRoles.default);
	roles.forEach(function (_ref) {
	  var _ref2 = _slicedToArray(_ref, 2),
	    roleDefinition = _ref2[1];
	  // Conglomerate the properties
	  var _iterator = _createForOfIteratorHelper(roleDefinition.superClass),
	    _step;
	  try {
	    for (_iterator.s(); !(_step = _iterator.n()).done;) {
	      var superClassIter = _step.value;
	      var _iterator2 = _createForOfIteratorHelper(superClassIter),
	        _step2;
	      try {
	        var _loop = function _loop() {
	          var superClassName = _step2.value;
	          var superClassRoleTuple = roles.find(function (_ref3) {
	            var _ref4 = _slicedToArray(_ref3, 1),
	              name = _ref4[0];
	            return name === superClassName;
	          });
	          if (superClassRoleTuple) {
	            var superClassDefinition = superClassRoleTuple[1];
	            for (var _i2 = 0, _Object$keys = Object.keys(superClassDefinition.props); _i2 < _Object$keys.length; _i2++) {
	              var prop = _Object$keys[_i2];
	              if (
	              // $FlowIssue Accessing the hasOwnProperty on the Object prototype is fine.
	              !Object.prototype.hasOwnProperty.call(roleDefinition.props, prop)) {
	                Object.assign(roleDefinition.props, _defineProperty({}, prop, superClassDefinition.props[prop]));
	              }
	            }
	          }
	        };
	        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	          _loop();
	        }
	      } catch (err) {
	        _iterator2.e(err);
	      } finally {
	        _iterator2.f();
	      }
	    }
	  } catch (err) {
	    _iterator.e(err);
	  } finally {
	    _iterator.f();
	  }
	});
	var rolesMap$1 = {
	  entries: function entries() {
	    return roles;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    var _iterator3 = _createForOfIteratorHelper(roles),
	      _step3;
	    try {
	      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
	        var _step3$value = _slicedToArray(_step3.value, 2),
	          key = _step3$value[0],
	          values = _step3$value[1];
	        fn.call(thisArg, values, key, roles);
	      }
	    } catch (err) {
	      _iterator3.e(err);
	    } finally {
	      _iterator3.f();
	    }
	  },
	  get: function get(key) {
	    var item = roles.find(function (tuple) {
	      return tuple[0] === key ? true : false;
	    });
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!rolesMap$1.get(key);
	  },
	  keys: function keys() {
	    return roles.map(function (_ref5) {
	      var _ref6 = _slicedToArray(_ref5, 1),
	        key = _ref6[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return roles.map(function (_ref7) {
	      var _ref8 = _slicedToArray(_ref7, 2),
	        values = _ref8[1];
	      return values;
	    });
	  }
	};
	var _default = (0, _iterationDecorator.default)(rolesMap$1, rolesMap$1.entries());
	rolesMap.default = _default;
	return rolesMap;
}

var elementRoleMap = {};

var lite = {};

var hasRequiredLite;

function requireLite () {
	if (hasRequiredLite) return lite;
	hasRequiredLite = 1;
	var has = Object.prototype.hasOwnProperty;

	function dequal(foo, bar) {
		var ctor, len;
		if (foo === bar) return true;

		if (foo && bar && (ctor=foo.constructor) === bar.constructor) {
			if (ctor === Date) return foo.getTime() === bar.getTime();
			if (ctor === RegExp) return foo.toString() === bar.toString();

			if (ctor === Array) {
				if ((len=foo.length) === bar.length) {
					while (len-- && dequal(foo[len], bar[len]));
				}
				return len === -1;
			}

			if (!ctor || typeof foo === 'object') {
				len = 0;
				for (ctor in foo) {
					if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
					if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
				}
				return Object.keys(bar).length === len;
			}
		}

		return foo !== foo && bar !== bar;
	}

	lite.dequal = dequal;
	return lite;
}

var hasRequiredElementRoleMap;

function requireElementRoleMap () {
	if (hasRequiredElementRoleMap) return elementRoleMap;
	hasRequiredElementRoleMap = 1;

	Object.defineProperty(elementRoleMap, "__esModule", {
	  value: true
	});
	elementRoleMap.default = void 0;
	var _lite = requireLite();
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator$1());
	var _rolesMap = _interopRequireDefault(requireRolesMap());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var elementRoles = [];
	var keys = _rolesMap.default.keys();
	for (var i = 0; i < keys.length; i++) {
	  var key = keys[i];
	  var role = _rolesMap.default.get(key);
	  if (role) {
	    var concepts = [].concat(role.baseConcepts, role.relatedConcepts);
	    for (var k = 0; k < concepts.length; k++) {
	      var relation = concepts[k];
	      if (relation.module === 'HTML') {
	        (function () {
	          var concept = relation.concept;
	          if (concept) {
	            var elementRoleRelation = elementRoles.find(function (relation) {
	              return (0, _lite.dequal)(relation, concept);
	            });
	            var roles;
	            if (elementRoleRelation) {
	              roles = elementRoleRelation[1];
	            } else {
	              roles = [];
	            }
	            var isUnique = true;
	            for (var _i = 0; _i < roles.length; _i++) {
	              if (roles[_i] === key) {
	                isUnique = false;
	                break;
	              }
	            }
	            if (isUnique) {
	              roles.push(key);
	            }
	            elementRoles.push([concept, roles]);
	          }
	        })();
	      }
	    }
	  }
	}
	var elementRoleMap$1 = {
	  entries: function entries() {
	    return elementRoles;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    var _iterator = _createForOfIteratorHelper(elementRoles),
	      _step;
	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        var _step$value = _slicedToArray(_step.value, 2),
	          _key = _step$value[0],
	          values = _step$value[1];
	        fn.call(thisArg, values, _key, elementRoles);
	      }
	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }
	  },
	  get: function get(key) {
	    var item = elementRoles.find(function (tuple) {
	      return key.name === tuple[0].name && (0, _lite.dequal)(key.attributes, tuple[0].attributes);
	    });
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!elementRoleMap$1.get(key);
	  },
	  keys: function keys() {
	    return elementRoles.map(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	        key = _ref2[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return elementRoles.map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        values = _ref4[1];
	      return values;
	    });
	  }
	};
	var _default = (0, _iterationDecorator.default)(elementRoleMap$1, elementRoleMap$1.entries());
	elementRoleMap.default = _default;
	return elementRoleMap;
}

var roleElementMap = {};

var hasRequiredRoleElementMap;

function requireRoleElementMap () {
	if (hasRequiredRoleElementMap) return roleElementMap;
	hasRequiredRoleElementMap = 1;

	Object.defineProperty(roleElementMap, "__esModule", {
	  value: true
	});
	roleElementMap.default = void 0;
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator$1());
	var _rolesMap = _interopRequireDefault(requireRolesMap());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var roleElement = [];
	var keys = _rolesMap.default.keys();
	for (var i = 0; i < keys.length; i++) {
	  var key = keys[i];
	  var role = _rolesMap.default.get(key);
	  var relationConcepts = [];
	  if (role) {
	    var concepts = [].concat(role.baseConcepts, role.relatedConcepts);
	    for (var k = 0; k < concepts.length; k++) {
	      var relation = concepts[k];
	      if (relation.module === 'HTML') {
	        var concept = relation.concept;
	        if (concept != null) {
	          relationConcepts.push(concept);
	        }
	      }
	    }
	    if (relationConcepts.length > 0) {
	      roleElement.push([key, relationConcepts]);
	    }
	  }
	}
	var roleElementMap$1 = {
	  entries: function entries() {
	    return roleElement;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    var _iterator = _createForOfIteratorHelper(roleElement),
	      _step;
	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        var _step$value = _slicedToArray(_step.value, 2),
	          _key = _step$value[0],
	          values = _step$value[1];
	        fn.call(thisArg, values, _key, roleElement);
	      }
	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }
	  },
	  get: function get(key) {
	    var item = roleElement.find(function (tuple) {
	      return tuple[0] === key ? true : false;
	    });
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!roleElementMap$1.get(key);
	  },
	  keys: function keys() {
	    return roleElement.map(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	        key = _ref2[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return roleElement.map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        values = _ref4[1];
	      return values;
	    });
	  }
	};
	var _default = (0, _iterationDecorator.default)(roleElementMap$1, roleElementMap$1.entries());
	roleElementMap.default = _default;
	return roleElementMap;
}

var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$4;
	hasRequiredLib$1 = 1;

	Object.defineProperty(lib$4, "__esModule", {
	  value: true
	});
	lib$4.roles = lib$4.roleElements = lib$4.elementRoles = lib$4.dom = lib$4.aria = void 0;
	var _ariaPropsMap = _interopRequireDefault(requireAriaPropsMap());
	var _domMap = _interopRequireDefault(requireDomMap());
	var _rolesMap = _interopRequireDefault(requireRolesMap());
	var _elementRoleMap = _interopRequireDefault(requireElementRoleMap());
	var _roleElementMap = _interopRequireDefault(requireRoleElementMap());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var aria = _ariaPropsMap.default;
	lib$4.aria = aria;
	var dom = _domMap.default;
	lib$4.dom = dom;
	var roles = _rolesMap.default;
	lib$4.roles = roles;
	var elementRoles = _elementRoleMap.default;
	lib$4.elementRoles = elementRoles;
	var roleElements = _roleElementMap.default;
	lib$4.roleElements = roleElements;
	return lib$4;
}

var libExports$1 = requireLib$1();

var lib$3 = {};

var AXObjectElementMap = {};

var iterationDecorator = {};

var iteratorProxy = {};

var hasRequiredIteratorProxy;

function requireIteratorProxy () {
	if (hasRequiredIteratorProxy) return iteratorProxy;
	hasRequiredIteratorProxy = 1;

	Object.defineProperty(iteratorProxy, "__esModule", {
	  value: true
	});
	iteratorProxy.default = void 0;

	// eslint-disable-next-line no-unused-vars
	function iteratorProxy$1() {
	  var values = this;
	  var index = 0;
	  var iter = {
	    '@@iterator': function iterator() {
	      return iter;
	    },
	    next: function next() {
	      if (index < values.length) {
	        var value = values[index];
	        index = index + 1;
	        return {
	          done: false,
	          value: value
	        };
	      } else {
	        return {
	          done: true
	        };
	      }
	    }
	  };
	  return iter;
	}
	var _default = iteratorProxy$1;
	iteratorProxy.default = _default;
	return iteratorProxy;
}

var hasRequiredIterationDecorator;

function requireIterationDecorator () {
	if (hasRequiredIterationDecorator) return iterationDecorator;
	hasRequiredIterationDecorator = 1;

	Object.defineProperty(iterationDecorator, "__esModule", {
	  value: true
	});
	iterationDecorator.default = iterationDecorator$1;
	var _iteratorProxy = _interopRequireDefault(requireIteratorProxy());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
	function iterationDecorator$1(collection, entries) {
	  if (typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol') {
	    Object.defineProperty(collection, Symbol.iterator, {
	      value: _iteratorProxy.default.bind(entries)
	    });
	  }
	  return collection;
	}
	return iterationDecorator;
}

var AXObjectsMap = {};

var AbbrRole = {};

var hasRequiredAbbrRole;

function requireAbbrRole () {
	if (hasRequiredAbbrRole) return AbbrRole;
	hasRequiredAbbrRole = 1;

	Object.defineProperty(AbbrRole, "__esModule", {
	  value: true
	});
	AbbrRole.default = void 0;
	var AbbrRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'abbr'
	    }
	  }],
	  type: 'structure'
	};
	var _default = AbbrRole$1;
	AbbrRole.default = _default;
	return AbbrRole;
}

var AlertDialogRole = {};

var hasRequiredAlertDialogRole;

function requireAlertDialogRole () {
	if (hasRequiredAlertDialogRole) return AlertDialogRole;
	hasRequiredAlertDialogRole = 1;

	Object.defineProperty(AlertDialogRole, "__esModule", {
	  value: true
	});
	AlertDialogRole.default = void 0;
	var AlertDialogRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'alertdialog'
	    }
	  }],
	  type: 'window'
	};
	var _default = AlertDialogRole$1;
	AlertDialogRole.default = _default;
	return AlertDialogRole;
}

var AlertRole = {};

var hasRequiredAlertRole;

function requireAlertRole () {
	if (hasRequiredAlertRole) return AlertRole;
	hasRequiredAlertRole = 1;

	Object.defineProperty(AlertRole, "__esModule", {
	  value: true
	});
	AlertRole.default = void 0;
	var AlertRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'alert'
	    }
	  }],
	  type: 'structure'
	};
	var _default = AlertRole$1;
	AlertRole.default = _default;
	return AlertRole;
}

var AnnotationRole = {};

var hasRequiredAnnotationRole;

function requireAnnotationRole () {
	if (hasRequiredAnnotationRole) return AnnotationRole;
	hasRequiredAnnotationRole = 1;

	Object.defineProperty(AnnotationRole, "__esModule", {
	  value: true
	});
	AnnotationRole.default = void 0;
	var AnnotationRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = AnnotationRole$1;
	AnnotationRole.default = _default;
	return AnnotationRole;
}

var ApplicationRole = {};

var hasRequiredApplicationRole;

function requireApplicationRole () {
	if (hasRequiredApplicationRole) return ApplicationRole;
	hasRequiredApplicationRole = 1;

	Object.defineProperty(ApplicationRole, "__esModule", {
	  value: true
	});
	ApplicationRole.default = void 0;
	var ApplicationRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'application'
	    }
	  }],
	  type: 'window'
	};
	var _default = ApplicationRole$1;
	ApplicationRole.default = _default;
	return ApplicationRole;
}

var ArticleRole = {};

var hasRequiredArticleRole;

function requireArticleRole () {
	if (hasRequiredArticleRole) return ArticleRole;
	hasRequiredArticleRole = 1;

	Object.defineProperty(ArticleRole, "__esModule", {
	  value: true
	});
	ArticleRole.default = void 0;
	var ArticleRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'article'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'article'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ArticleRole$1;
	ArticleRole.default = _default;
	return ArticleRole;
}

var AudioRole = {};

var hasRequiredAudioRole;

function requireAudioRole () {
	if (hasRequiredAudioRole) return AudioRole;
	hasRequiredAudioRole = 1;

	Object.defineProperty(AudioRole, "__esModule", {
	  value: true
	});
	AudioRole.default = void 0;
	var AudioRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'audio'
	    }
	  }],
	  type: 'widget'
	};
	var _default = AudioRole$1;
	AudioRole.default = _default;
	return AudioRole;
}

var BannerRole = {};

var hasRequiredBannerRole;

function requireBannerRole () {
	if (hasRequiredBannerRole) return BannerRole;
	hasRequiredBannerRole = 1;

	Object.defineProperty(BannerRole, "__esModule", {
	  value: true
	});
	BannerRole.default = void 0;
	var BannerRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'banner'
	    }
	  }],
	  type: 'structure'
	};
	var _default = BannerRole$1;
	BannerRole.default = _default;
	return BannerRole;
}

var BlockquoteRole = {};

var hasRequiredBlockquoteRole;

function requireBlockquoteRole () {
	if (hasRequiredBlockquoteRole) return BlockquoteRole;
	hasRequiredBlockquoteRole = 1;

	Object.defineProperty(BlockquoteRole, "__esModule", {
	  value: true
	});
	BlockquoteRole.default = void 0;
	var BlockquoteRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'blockquote'
	    }
	  }],
	  type: 'structure'
	};
	var _default = BlockquoteRole$1;
	BlockquoteRole.default = _default;
	return BlockquoteRole;
}

var BusyIndicatorRole = {};

var hasRequiredBusyIndicatorRole;

function requireBusyIndicatorRole () {
	if (hasRequiredBusyIndicatorRole) return BusyIndicatorRole;
	hasRequiredBusyIndicatorRole = 1;

	Object.defineProperty(BusyIndicatorRole, "__esModule", {
	  value: true
	});
	BusyIndicatorRole.default = void 0;
	var BusyIndicatorRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      attributes: [{
	        name: 'aria-busy',
	        value: 'true'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = BusyIndicatorRole$1;
	BusyIndicatorRole.default = _default;
	return BusyIndicatorRole;
}

var ButtonRole = {};

var hasRequiredButtonRole;

function requireButtonRole () {
	if (hasRequiredButtonRole) return ButtonRole;
	hasRequiredButtonRole = 1;

	Object.defineProperty(ButtonRole, "__esModule", {
	  value: true
	});
	ButtonRole.default = void 0;
	var ButtonRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'button'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'button'
	    }
	  }],
	  type: 'widget'
	};
	var _default = ButtonRole$1;
	ButtonRole.default = _default;
	return ButtonRole;
}

var CanvasRole = {};

var hasRequiredCanvasRole;

function requireCanvasRole () {
	if (hasRequiredCanvasRole) return CanvasRole;
	hasRequiredCanvasRole = 1;

	Object.defineProperty(CanvasRole, "__esModule", {
	  value: true
	});
	CanvasRole.default = void 0;
	var CanvasRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'canvas'
	    }
	  }],
	  type: 'widget'
	};
	var _default = CanvasRole$1;
	CanvasRole.default = _default;
	return CanvasRole;
}

var CaptionRole = {};

var hasRequiredCaptionRole;

function requireCaptionRole () {
	if (hasRequiredCaptionRole) return CaptionRole;
	hasRequiredCaptionRole = 1;

	Object.defineProperty(CaptionRole, "__esModule", {
	  value: true
	});
	CaptionRole.default = void 0;
	var CaptionRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'caption'
	    }
	  }],
	  type: 'structure'
	};
	var _default = CaptionRole$1;
	CaptionRole.default = _default;
	return CaptionRole;
}

var CellRole = {};

var hasRequiredCellRole;

function requireCellRole () {
	if (hasRequiredCellRole) return CellRole;
	hasRequiredCellRole = 1;

	Object.defineProperty(CellRole, "__esModule", {
	  value: true
	});
	CellRole.default = void 0;
	var CellRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'cell'
	    }
	  }, {
	    module: 'ARIA',
	    concept: {
	      name: 'gridcell'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'td'
	    }
	  }],
	  type: 'widget'
	};
	var _default = CellRole$1;
	CellRole.default = _default;
	return CellRole;
}

var CheckBoxRole = {};

var hasRequiredCheckBoxRole;

function requireCheckBoxRole () {
	if (hasRequiredCheckBoxRole) return CheckBoxRole;
	hasRequiredCheckBoxRole = 1;

	Object.defineProperty(CheckBoxRole, "__esModule", {
	  value: true
	});
	CheckBoxRole.default = void 0;
	var CheckBoxRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'checkbox'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'checkbox'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = CheckBoxRole$1;
	CheckBoxRole.default = _default;
	return CheckBoxRole;
}

var ColorWellRole = {};

var hasRequiredColorWellRole;

function requireColorWellRole () {
	if (hasRequiredColorWellRole) return ColorWellRole;
	hasRequiredColorWellRole = 1;

	Object.defineProperty(ColorWellRole, "__esModule", {
	  value: true
	});
	ColorWellRole.default = void 0;
	var ColorWellRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'color'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = ColorWellRole$1;
	ColorWellRole.default = _default;
	return ColorWellRole;
}

var ColumnHeaderRole = {};

var hasRequiredColumnHeaderRole;

function requireColumnHeaderRole () {
	if (hasRequiredColumnHeaderRole) return ColumnHeaderRole;
	hasRequiredColumnHeaderRole = 1;

	Object.defineProperty(ColumnHeaderRole, "__esModule", {
	  value: true
	});
	ColumnHeaderRole.default = void 0;
	var ColumnHeaderRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'columnheader'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'th'
	    }
	  }],
	  type: 'widget'
	};
	var _default = ColumnHeaderRole$1;
	ColumnHeaderRole.default = _default;
	return ColumnHeaderRole;
}

var ColumnRole = {};

var hasRequiredColumnRole;

function requireColumnRole () {
	if (hasRequiredColumnRole) return ColumnRole;
	hasRequiredColumnRole = 1;

	Object.defineProperty(ColumnRole, "__esModule", {
	  value: true
	});
	ColumnRole.default = void 0;
	var ColumnRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = ColumnRole$1;
	ColumnRole.default = _default;
	return ColumnRole;
}

var ComboBoxRole = {};

var hasRequiredComboBoxRole;

function requireComboBoxRole () {
	if (hasRequiredComboBoxRole) return ComboBoxRole;
	hasRequiredComboBoxRole = 1;

	Object.defineProperty(ComboBoxRole, "__esModule", {
	  value: true
	});
	ComboBoxRole.default = void 0;
	var ComboBoxRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'combobox'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'select'
	    }
	  }],
	  type: 'widget'
	};
	var _default = ComboBoxRole$1;
	ComboBoxRole.default = _default;
	return ComboBoxRole;
}

var ComplementaryRole = {};

var hasRequiredComplementaryRole;

function requireComplementaryRole () {
	if (hasRequiredComplementaryRole) return ComplementaryRole;
	hasRequiredComplementaryRole = 1;

	Object.defineProperty(ComplementaryRole, "__esModule", {
	  value: true
	});
	ComplementaryRole.default = void 0;
	var ComplementaryRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'complementary'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ComplementaryRole$1;
	ComplementaryRole.default = _default;
	return ComplementaryRole;
}

var ContentInfoRole = {};

var hasRequiredContentInfoRole;

function requireContentInfoRole () {
	if (hasRequiredContentInfoRole) return ContentInfoRole;
	hasRequiredContentInfoRole = 1;

	Object.defineProperty(ContentInfoRole, "__esModule", {
	  value: true
	});
	ContentInfoRole.default = void 0;
	var ContentInfoRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'structureinfo'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ContentInfoRole$1;
	ContentInfoRole.default = _default;
	return ContentInfoRole;
}

var DateRole = {};

var hasRequiredDateRole;

function requireDateRole () {
	if (hasRequiredDateRole) return DateRole;
	hasRequiredDateRole = 1;

	Object.defineProperty(DateRole, "__esModule", {
	  value: true
	});
	DateRole.default = void 0;
	var DateRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'date'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = DateRole$1;
	DateRole.default = _default;
	return DateRole;
}

var DateTimeRole = {};

var hasRequiredDateTimeRole;

function requireDateTimeRole () {
	if (hasRequiredDateTimeRole) return DateTimeRole;
	hasRequiredDateTimeRole = 1;

	Object.defineProperty(DateTimeRole, "__esModule", {
	  value: true
	});
	DateTimeRole.default = void 0;
	var DateTimeRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'datetime'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = DateTimeRole$1;
	DateTimeRole.default = _default;
	return DateTimeRole;
}

var DefinitionRole = {};

var hasRequiredDefinitionRole;

function requireDefinitionRole () {
	if (hasRequiredDefinitionRole) return DefinitionRole;
	hasRequiredDefinitionRole = 1;

	Object.defineProperty(DefinitionRole, "__esModule", {
	  value: true
	});
	DefinitionRole.default = void 0;
	var DefinitionRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'dfn'
	    }
	  }],
	  type: 'structure'
	};
	var _default = DefinitionRole$1;
	DefinitionRole.default = _default;
	return DefinitionRole;
}

var DescriptionListDetailRole = {};

var hasRequiredDescriptionListDetailRole;

function requireDescriptionListDetailRole () {
	if (hasRequiredDescriptionListDetailRole) return DescriptionListDetailRole;
	hasRequiredDescriptionListDetailRole = 1;

	Object.defineProperty(DescriptionListDetailRole, "__esModule", {
	  value: true
	});
	DescriptionListDetailRole.default = void 0;
	var DescriptionListDetailRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'dd'
	    }
	  }],
	  type: 'structure'
	};
	var _default = DescriptionListDetailRole$1;
	DescriptionListDetailRole.default = _default;
	return DescriptionListDetailRole;
}

var DescriptionListRole = {};

var hasRequiredDescriptionListRole;

function requireDescriptionListRole () {
	if (hasRequiredDescriptionListRole) return DescriptionListRole;
	hasRequiredDescriptionListRole = 1;

	Object.defineProperty(DescriptionListRole, "__esModule", {
	  value: true
	});
	DescriptionListRole.default = void 0;
	var DescriptionListRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'dl'
	    }
	  }],
	  type: 'structure'
	};
	var _default = DescriptionListRole$1;
	DescriptionListRole.default = _default;
	return DescriptionListRole;
}

var DescriptionListTermRole = {};

var hasRequiredDescriptionListTermRole;

function requireDescriptionListTermRole () {
	if (hasRequiredDescriptionListTermRole) return DescriptionListTermRole;
	hasRequiredDescriptionListTermRole = 1;

	Object.defineProperty(DescriptionListTermRole, "__esModule", {
	  value: true
	});
	DescriptionListTermRole.default = void 0;
	var DescriptionListTermRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'dt'
	    }
	  }],
	  type: 'structure'
	};
	var _default = DescriptionListTermRole$1;
	DescriptionListTermRole.default = _default;
	return DescriptionListTermRole;
}

var DetailsRole = {};

var hasRequiredDetailsRole;

function requireDetailsRole () {
	if (hasRequiredDetailsRole) return DetailsRole;
	hasRequiredDetailsRole = 1;

	Object.defineProperty(DetailsRole, "__esModule", {
	  value: true
	});
	DetailsRole.default = void 0;
	var DetailsRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'details'
	    }
	  }],
	  type: 'structure'
	};
	var _default = DetailsRole$1;
	DetailsRole.default = _default;
	return DetailsRole;
}

var DialogRole = {};

var hasRequiredDialogRole;

function requireDialogRole () {
	if (hasRequiredDialogRole) return DialogRole;
	hasRequiredDialogRole = 1;

	Object.defineProperty(DialogRole, "__esModule", {
	  value: true
	});
	DialogRole.default = void 0;
	var DialogRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'dialog'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'dialog'
	    }
	  }],
	  type: 'window'
	};
	var _default = DialogRole$1;
	DialogRole.default = _default;
	return DialogRole;
}

var DirectoryRole = {};

var hasRequiredDirectoryRole;

function requireDirectoryRole () {
	if (hasRequiredDirectoryRole) return DirectoryRole;
	hasRequiredDirectoryRole = 1;

	Object.defineProperty(DirectoryRole, "__esModule", {
	  value: true
	});
	DirectoryRole.default = void 0;
	var DirectoryRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'directory'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'dir'
	    }
	  }],
	  type: 'structure'
	};
	var _default = DirectoryRole$1;
	DirectoryRole.default = _default;
	return DirectoryRole;
}

var DisclosureTriangleRole = {};

var hasRequiredDisclosureTriangleRole;

function requireDisclosureTriangleRole () {
	if (hasRequiredDisclosureTriangleRole) return DisclosureTriangleRole;
	hasRequiredDisclosureTriangleRole = 1;

	Object.defineProperty(DisclosureTriangleRole, "__esModule", {
	  value: true
	});
	DisclosureTriangleRole.default = void 0;
	var DisclosureTriangleRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      attributes: [{
	        name: 'open',
	        value: 'open'
	      }],
	      constraints: ['scoped to a details element'],
	      name: 'summary'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      attributes: [{
	        name: 'aria-expanded'
	      }],
	      constraints: ['scoped to a details element'],
	      name: 'summary'
	    }
	  }],
	  type: 'widget'
	};
	var _default = DisclosureTriangleRole$1;
	DisclosureTriangleRole.default = _default;
	return DisclosureTriangleRole;
}

var DivRole = {};

var hasRequiredDivRole;

function requireDivRole () {
	if (hasRequiredDivRole) return DivRole;
	hasRequiredDivRole = 1;

	Object.defineProperty(DivRole, "__esModule", {
	  value: true
	});
	DivRole.default = void 0;
	var DivRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'div'
	    }
	  }],
	  type: 'generic'
	};
	var _default = DivRole$1;
	DivRole.default = _default;
	return DivRole;
}

var DocumentRole = {};

var hasRequiredDocumentRole;

function requireDocumentRole () {
	if (hasRequiredDocumentRole) return DocumentRole;
	hasRequiredDocumentRole = 1;

	Object.defineProperty(DocumentRole, "__esModule", {
	  value: true
	});
	DocumentRole.default = void 0;
	var DocumentRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'document'
	    }
	  }],
	  type: 'structure'
	};
	var _default = DocumentRole$1;
	DocumentRole.default = _default;
	return DocumentRole;
}

var EmbeddedObjectRole = {};

var hasRequiredEmbeddedObjectRole;

function requireEmbeddedObjectRole () {
	if (hasRequiredEmbeddedObjectRole) return EmbeddedObjectRole;
	hasRequiredEmbeddedObjectRole = 1;

	Object.defineProperty(EmbeddedObjectRole, "__esModule", {
	  value: true
	});
	EmbeddedObjectRole.default = void 0;
	var EmbeddedObjectRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'embed'
	    }
	  }],
	  type: 'widget'
	};
	var _default = EmbeddedObjectRole$1;
	EmbeddedObjectRole.default = _default;
	return EmbeddedObjectRole;
}

var FeedRole = {};

var hasRequiredFeedRole;

function requireFeedRole () {
	if (hasRequiredFeedRole) return FeedRole;
	hasRequiredFeedRole = 1;

	Object.defineProperty(FeedRole, "__esModule", {
	  value: true
	});
	FeedRole.default = void 0;
	var FeedRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'feed'
	    }
	  }],
	  type: 'structure'
	};
	var _default = FeedRole$1;
	FeedRole.default = _default;
	return FeedRole;
}

var FigcaptionRole = {};

var hasRequiredFigcaptionRole;

function requireFigcaptionRole () {
	if (hasRequiredFigcaptionRole) return FigcaptionRole;
	hasRequiredFigcaptionRole = 1;

	Object.defineProperty(FigcaptionRole, "__esModule", {
	  value: true
	});
	FigcaptionRole.default = void 0;
	var FigcaptionRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'figcaption'
	    }
	  }],
	  type: 'structure'
	};
	var _default = FigcaptionRole$1;
	FigcaptionRole.default = _default;
	return FigcaptionRole;
}

var FigureRole = {};

var hasRequiredFigureRole;

function requireFigureRole () {
	if (hasRequiredFigureRole) return FigureRole;
	hasRequiredFigureRole = 1;

	Object.defineProperty(FigureRole, "__esModule", {
	  value: true
	});
	FigureRole.default = void 0;
	var FigureRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'figure'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'figure'
	    }
	  }],
	  type: 'structure'
	};
	var _default = FigureRole$1;
	FigureRole.default = _default;
	return FigureRole;
}

var FooterRole = {};

var hasRequiredFooterRole;

function requireFooterRole () {
	if (hasRequiredFooterRole) return FooterRole;
	hasRequiredFooterRole = 1;

	Object.defineProperty(FooterRole, "__esModule", {
	  value: true
	});
	FooterRole.default = void 0;
	var FooterRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'footer'
	    }
	  }],
	  type: 'structure'
	};
	var _default = FooterRole$1;
	FooterRole.default = _default;
	return FooterRole;
}

var FormRole = {};

var hasRequiredFormRole;

function requireFormRole () {
	if (hasRequiredFormRole) return FormRole;
	hasRequiredFormRole = 1;

	Object.defineProperty(FormRole, "__esModule", {
	  value: true
	});
	FormRole.default = void 0;
	var FormRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'form'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'form'
	    }
	  }],
	  type: 'structure'
	};
	var _default = FormRole$1;
	FormRole.default = _default;
	return FormRole;
}

var GridRole = {};

var hasRequiredGridRole;

function requireGridRole () {
	if (hasRequiredGridRole) return GridRole;
	hasRequiredGridRole = 1;

	Object.defineProperty(GridRole, "__esModule", {
	  value: true
	});
	GridRole.default = void 0;
	var GridRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'grid'
	    }
	  }],
	  type: 'widget'
	};
	var _default = GridRole$1;
	GridRole.default = _default;
	return GridRole;
}

var GroupRole = {};

var hasRequiredGroupRole;

function requireGroupRole () {
	if (hasRequiredGroupRole) return GroupRole;
	hasRequiredGroupRole = 1;

	Object.defineProperty(GroupRole, "__esModule", {
	  value: true
	});
	GroupRole.default = void 0;
	var GroupRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'group'
	    }
	  }],
	  type: 'structure'
	};
	var _default = GroupRole$1;
	GroupRole.default = _default;
	return GroupRole;
}

var HeadingRole = {};

var hasRequiredHeadingRole;

function requireHeadingRole () {
	if (hasRequiredHeadingRole) return HeadingRole;
	hasRequiredHeadingRole = 1;

	Object.defineProperty(HeadingRole, "__esModule", {
	  value: true
	});
	HeadingRole.default = void 0;
	var HeadingRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'heading'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'h1'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'h2'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'h3'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'h4'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'h5'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'h6'
	    }
	  }],
	  type: 'structure'
	};
	var _default = HeadingRole$1;
	HeadingRole.default = _default;
	return HeadingRole;
}

var IframePresentationalRole = {};

var hasRequiredIframePresentationalRole;

function requireIframePresentationalRole () {
	if (hasRequiredIframePresentationalRole) return IframePresentationalRole;
	hasRequiredIframePresentationalRole = 1;

	Object.defineProperty(IframePresentationalRole, "__esModule", {
	  value: true
	});
	IframePresentationalRole.default = void 0;
	var IframePresentationalRole$1 = {
	  relatedConcepts: [],
	  type: 'window'
	};
	var _default = IframePresentationalRole$1;
	IframePresentationalRole.default = _default;
	return IframePresentationalRole;
}

var IframeRole = {};

var hasRequiredIframeRole;

function requireIframeRole () {
	if (hasRequiredIframeRole) return IframeRole;
	hasRequiredIframeRole = 1;

	Object.defineProperty(IframeRole, "__esModule", {
	  value: true
	});
	IframeRole.default = void 0;
	var IframeRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'iframe'
	    }
	  }],
	  type: 'window'
	};
	var _default = IframeRole$1;
	IframeRole.default = _default;
	return IframeRole;
}

var IgnoredRole = {};

var hasRequiredIgnoredRole;

function requireIgnoredRole () {
	if (hasRequiredIgnoredRole) return IgnoredRole;
	hasRequiredIgnoredRole = 1;

	Object.defineProperty(IgnoredRole, "__esModule", {
	  value: true
	});
	IgnoredRole.default = void 0;
	var IgnoredRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = IgnoredRole$1;
	IgnoredRole.default = _default;
	return IgnoredRole;
}

var ImageMapLinkRole = {};

var hasRequiredImageMapLinkRole;

function requireImageMapLinkRole () {
	if (hasRequiredImageMapLinkRole) return ImageMapLinkRole;
	hasRequiredImageMapLinkRole = 1;

	Object.defineProperty(ImageMapLinkRole, "__esModule", {
	  value: true
	});
	ImageMapLinkRole.default = void 0;
	var ImageMapLinkRole$1 = {
	  relatedConcepts: [],
	  type: 'widget'
	};
	var _default = ImageMapLinkRole$1;
	ImageMapLinkRole.default = _default;
	return ImageMapLinkRole;
}

var ImageMapRole = {};

var hasRequiredImageMapRole;

function requireImageMapRole () {
	if (hasRequiredImageMapRole) return ImageMapRole;
	hasRequiredImageMapRole = 1;

	Object.defineProperty(ImageMapRole, "__esModule", {
	  value: true
	});
	ImageMapRole.default = void 0;
	var ImageMapRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'img',
	      attributes: [{
	        name: 'usemap'
	      }]
	    }
	  }],
	  type: 'structure'
	};
	var _default = ImageMapRole$1;
	ImageMapRole.default = _default;
	return ImageMapRole;
}

var ImageRole = {};

var hasRequiredImageRole;

function requireImageRole () {
	if (hasRequiredImageRole) return ImageRole;
	hasRequiredImageRole = 1;

	Object.defineProperty(ImageRole, "__esModule", {
	  value: true
	});
	ImageRole.default = void 0;
	var ImageRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'img'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'img'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ImageRole$1;
	ImageRole.default = _default;
	return ImageRole;
}

var InlineTextBoxRole = {};

var hasRequiredInlineTextBoxRole;

function requireInlineTextBoxRole () {
	if (hasRequiredInlineTextBoxRole) return InlineTextBoxRole;
	hasRequiredInlineTextBoxRole = 1;

	Object.defineProperty(InlineTextBoxRole, "__esModule", {
	  value: true
	});
	InlineTextBoxRole.default = void 0;
	var InlineTextBoxRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'input'
	    }
	  }],
	  type: 'widget'
	};
	var _default = InlineTextBoxRole$1;
	InlineTextBoxRole.default = _default;
	return InlineTextBoxRole;
}

var InputTimeRole = {};

var hasRequiredInputTimeRole;

function requireInputTimeRole () {
	if (hasRequiredInputTimeRole) return InputTimeRole;
	hasRequiredInputTimeRole = 1;

	Object.defineProperty(InputTimeRole, "__esModule", {
	  value: true
	});
	InputTimeRole.default = void 0;
	var InputTimeRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'time'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = InputTimeRole$1;
	InputTimeRole.default = _default;
	return InputTimeRole;
}

var LabelRole = {};

var hasRequiredLabelRole;

function requireLabelRole () {
	if (hasRequiredLabelRole) return LabelRole;
	hasRequiredLabelRole = 1;

	Object.defineProperty(LabelRole, "__esModule", {
	  value: true
	});
	LabelRole.default = void 0;
	var LabelRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'label'
	    }
	  }],
	  type: 'structure'
	};
	var _default = LabelRole$1;
	LabelRole.default = _default;
	return LabelRole;
}

var LegendRole = {};

var hasRequiredLegendRole;

function requireLegendRole () {
	if (hasRequiredLegendRole) return LegendRole;
	hasRequiredLegendRole = 1;

	Object.defineProperty(LegendRole, "__esModule", {
	  value: true
	});
	LegendRole.default = void 0;
	var LegendRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'legend'
	    }
	  }],
	  type: 'structure'
	};
	var _default = LegendRole$1;
	LegendRole.default = _default;
	return LegendRole;
}

var LineBreakRole = {};

var hasRequiredLineBreakRole;

function requireLineBreakRole () {
	if (hasRequiredLineBreakRole) return LineBreakRole;
	hasRequiredLineBreakRole = 1;

	Object.defineProperty(LineBreakRole, "__esModule", {
	  value: true
	});
	LineBreakRole.default = void 0;
	var LineBreakRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'br'
	    }
	  }],
	  type: 'structure'
	};
	var _default = LineBreakRole$1;
	LineBreakRole.default = _default;
	return LineBreakRole;
}

var LinkRole = {};

var hasRequiredLinkRole;

function requireLinkRole () {
	if (hasRequiredLinkRole) return LinkRole;
	hasRequiredLinkRole = 1;

	Object.defineProperty(LinkRole, "__esModule", {
	  value: true
	});
	LinkRole.default = void 0;
	var LinkRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'link'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'a',
	      attributes: [{
	        name: 'href'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = LinkRole$1;
	LinkRole.default = _default;
	return LinkRole;
}

var ListBoxOptionRole = {};

var hasRequiredListBoxOptionRole;

function requireListBoxOptionRole () {
	if (hasRequiredListBoxOptionRole) return ListBoxOptionRole;
	hasRequiredListBoxOptionRole = 1;

	Object.defineProperty(ListBoxOptionRole, "__esModule", {
	  value: true
	});
	ListBoxOptionRole.default = void 0;
	var ListBoxOptionRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'option'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'option'
	    }
	  }],
	  type: 'widget'
	};
	var _default = ListBoxOptionRole$1;
	ListBoxOptionRole.default = _default;
	return ListBoxOptionRole;
}

var ListBoxRole = {};

var hasRequiredListBoxRole;

function requireListBoxRole () {
	if (hasRequiredListBoxRole) return ListBoxRole;
	hasRequiredListBoxRole = 1;

	Object.defineProperty(ListBoxRole, "__esModule", {
	  value: true
	});
	ListBoxRole.default = void 0;
	var ListBoxRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'listbox'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'datalist'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'select'
	    }
	  }],
	  type: 'widget'
	};
	var _default = ListBoxRole$1;
	ListBoxRole.default = _default;
	return ListBoxRole;
}

var ListItemRole = {};

var hasRequiredListItemRole;

function requireListItemRole () {
	if (hasRequiredListItemRole) return ListItemRole;
	hasRequiredListItemRole = 1;

	Object.defineProperty(ListItemRole, "__esModule", {
	  value: true
	});
	ListItemRole.default = void 0;
	var ListItemRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'listitem'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'li'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ListItemRole$1;
	ListItemRole.default = _default;
	return ListItemRole;
}

var ListMarkerRole = {};

var hasRequiredListMarkerRole;

function requireListMarkerRole () {
	if (hasRequiredListMarkerRole) return ListMarkerRole;
	hasRequiredListMarkerRole = 1;

	Object.defineProperty(ListMarkerRole, "__esModule", {
	  value: true
	});
	ListMarkerRole.default = void 0;
	var ListMarkerRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = ListMarkerRole$1;
	ListMarkerRole.default = _default;
	return ListMarkerRole;
}

var ListRole = {};

var hasRequiredListRole;

function requireListRole () {
	if (hasRequiredListRole) return ListRole;
	hasRequiredListRole = 1;

	Object.defineProperty(ListRole, "__esModule", {
	  value: true
	});
	ListRole.default = void 0;
	var ListRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'list'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'ul'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'ol'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ListRole$1;
	ListRole.default = _default;
	return ListRole;
}

var LogRole = {};

var hasRequiredLogRole;

function requireLogRole () {
	if (hasRequiredLogRole) return LogRole;
	hasRequiredLogRole = 1;

	Object.defineProperty(LogRole, "__esModule", {
	  value: true
	});
	LogRole.default = void 0;
	var LogRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'log'
	    }
	  }],
	  type: 'structure'
	};
	var _default = LogRole$1;
	LogRole.default = _default;
	return LogRole;
}

var MainRole = {};

var hasRequiredMainRole;

function requireMainRole () {
	if (hasRequiredMainRole) return MainRole;
	hasRequiredMainRole = 1;

	Object.defineProperty(MainRole, "__esModule", {
	  value: true
	});
	MainRole.default = void 0;
	var MainRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'main'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'main'
	    }
	  }],
	  type: 'structure'
	};
	var _default = MainRole$1;
	MainRole.default = _default;
	return MainRole;
}

var MarkRole = {};

var hasRequiredMarkRole;

function requireMarkRole () {
	if (hasRequiredMarkRole) return MarkRole;
	hasRequiredMarkRole = 1;

	Object.defineProperty(MarkRole, "__esModule", {
	  value: true
	});
	MarkRole.default = void 0;
	var MarkRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'mark'
	    }
	  }],
	  type: 'structure'
	};
	var _default = MarkRole$1;
	MarkRole.default = _default;
	return MarkRole;
}

var MarqueeRole = {};

var hasRequiredMarqueeRole;

function requireMarqueeRole () {
	if (hasRequiredMarqueeRole) return MarqueeRole;
	hasRequiredMarqueeRole = 1;

	Object.defineProperty(MarqueeRole, "__esModule", {
	  value: true
	});
	MarqueeRole.default = void 0;
	var MarqueeRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'marquee'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'marquee'
	    }
	  }],
	  type: 'structure'
	};
	var _default = MarqueeRole$1;
	MarqueeRole.default = _default;
	return MarqueeRole;
}

var MathRole = {};

var hasRequiredMathRole;

function requireMathRole () {
	if (hasRequiredMathRole) return MathRole;
	hasRequiredMathRole = 1;

	Object.defineProperty(MathRole, "__esModule", {
	  value: true
	});
	MathRole.default = void 0;
	var MathRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'math'
	    }
	  }],
	  type: 'structure'
	};
	var _default = MathRole$1;
	MathRole.default = _default;
	return MathRole;
}

var MenuBarRole = {};

var hasRequiredMenuBarRole;

function requireMenuBarRole () {
	if (hasRequiredMenuBarRole) return MenuBarRole;
	hasRequiredMenuBarRole = 1;

	Object.defineProperty(MenuBarRole, "__esModule", {
	  value: true
	});
	MenuBarRole.default = void 0;
	var MenuBarRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'menubar'
	    }
	  }],
	  type: 'structure'
	};
	var _default = MenuBarRole$1;
	MenuBarRole.default = _default;
	return MenuBarRole;
}

var MenuButtonRole = {};

var hasRequiredMenuButtonRole;

function requireMenuButtonRole () {
	if (hasRequiredMenuButtonRole) return MenuButtonRole;
	hasRequiredMenuButtonRole = 1;

	Object.defineProperty(MenuButtonRole, "__esModule", {
	  value: true
	});
	MenuButtonRole.default = void 0;
	var MenuButtonRole$1 = {
	  relatedConcepts: [],
	  type: 'widget'
	};
	var _default = MenuButtonRole$1;
	MenuButtonRole.default = _default;
	return MenuButtonRole;
}

var MenuItemRole = {};

var hasRequiredMenuItemRole;

function requireMenuItemRole () {
	if (hasRequiredMenuItemRole) return MenuItemRole;
	hasRequiredMenuItemRole = 1;

	Object.defineProperty(MenuItemRole, "__esModule", {
	  value: true
	});
	MenuItemRole.default = void 0;
	var MenuItemRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'menuitem'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'menuitem'
	    }
	  }],
	  type: 'widget'
	};
	var _default = MenuItemRole$1;
	MenuItemRole.default = _default;
	return MenuItemRole;
}

var MenuItemCheckBoxRole = {};

var hasRequiredMenuItemCheckBoxRole;

function requireMenuItemCheckBoxRole () {
	if (hasRequiredMenuItemCheckBoxRole) return MenuItemCheckBoxRole;
	hasRequiredMenuItemCheckBoxRole = 1;

	Object.defineProperty(MenuItemCheckBoxRole, "__esModule", {
	  value: true
	});
	MenuItemCheckBoxRole.default = void 0;
	var MenuItemCheckBoxRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'menuitemcheckbox'
	    }
	  }],
	  type: 'widget'
	};
	var _default = MenuItemCheckBoxRole$1;
	MenuItemCheckBoxRole.default = _default;
	return MenuItemCheckBoxRole;
}

var MenuItemRadioRole = {};

var hasRequiredMenuItemRadioRole;

function requireMenuItemRadioRole () {
	if (hasRequiredMenuItemRadioRole) return MenuItemRadioRole;
	hasRequiredMenuItemRadioRole = 1;

	Object.defineProperty(MenuItemRadioRole, "__esModule", {
	  value: true
	});
	MenuItemRadioRole.default = void 0;
	var MenuItemRadioRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'menuitemradio'
	    }
	  }],
	  type: 'widget'
	};
	var _default = MenuItemRadioRole$1;
	MenuItemRadioRole.default = _default;
	return MenuItemRadioRole;
}

var MenuListOptionRole = {};

var hasRequiredMenuListOptionRole;

function requireMenuListOptionRole () {
	if (hasRequiredMenuListOptionRole) return MenuListOptionRole;
	hasRequiredMenuListOptionRole = 1;

	Object.defineProperty(MenuListOptionRole, "__esModule", {
	  value: true
	});
	MenuListOptionRole.default = void 0;
	var MenuListOptionRole$1 = {
	  relatedConcepts: [],
	  type: 'widget'
	};
	var _default = MenuListOptionRole$1;
	MenuListOptionRole.default = _default;
	return MenuListOptionRole;
}

var MenuListPopupRole = {};

var hasRequiredMenuListPopupRole;

function requireMenuListPopupRole () {
	if (hasRequiredMenuListPopupRole) return MenuListPopupRole;
	hasRequiredMenuListPopupRole = 1;

	Object.defineProperty(MenuListPopupRole, "__esModule", {
	  value: true
	});
	MenuListPopupRole.default = void 0;
	var MenuListPopupRole$1 = {
	  relatedConcepts: [],
	  type: 'widget'
	};
	var _default = MenuListPopupRole$1;
	MenuListPopupRole.default = _default;
	return MenuListPopupRole;
}

var MenuRole = {};

var hasRequiredMenuRole;

function requireMenuRole () {
	if (hasRequiredMenuRole) return MenuRole;
	hasRequiredMenuRole = 1;

	Object.defineProperty(MenuRole, "__esModule", {
	  value: true
	});
	MenuRole.default = void 0;
	var MenuRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'menu'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'menu'
	    }
	  }],
	  type: 'structure'
	};
	var _default = MenuRole$1;
	MenuRole.default = _default;
	return MenuRole;
}

var MeterRole = {};

var hasRequiredMeterRole;

function requireMeterRole () {
	if (hasRequiredMeterRole) return MeterRole;
	hasRequiredMeterRole = 1;

	Object.defineProperty(MeterRole, "__esModule", {
	  value: true
	});
	MeterRole.default = void 0;
	var MeterRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'meter'
	    }
	  }],
	  type: 'structure'
	};
	var _default = MeterRole$1;
	MeterRole.default = _default;
	return MeterRole;
}

var NavigationRole = {};

var hasRequiredNavigationRole;

function requireNavigationRole () {
	if (hasRequiredNavigationRole) return NavigationRole;
	hasRequiredNavigationRole = 1;

	Object.defineProperty(NavigationRole, "__esModule", {
	  value: true
	});
	NavigationRole.default = void 0;
	var NavigationRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'navigation'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'nav'
	    }
	  }],
	  type: 'structure'
	};
	var _default = NavigationRole$1;
	NavigationRole.default = _default;
	return NavigationRole;
}

var NoneRole = {};

var hasRequiredNoneRole;

function requireNoneRole () {
	if (hasRequiredNoneRole) return NoneRole;
	hasRequiredNoneRole = 1;

	Object.defineProperty(NoneRole, "__esModule", {
	  value: true
	});
	NoneRole.default = void 0;
	var NoneRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'none'
	    }
	  }],
	  type: 'structure'
	};
	var _default = NoneRole$1;
	NoneRole.default = _default;
	return NoneRole;
}

var NoteRole = {};

var hasRequiredNoteRole;

function requireNoteRole () {
	if (hasRequiredNoteRole) return NoteRole;
	hasRequiredNoteRole = 1;

	Object.defineProperty(NoteRole, "__esModule", {
	  value: true
	});
	NoteRole.default = void 0;
	var NoteRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'note'
	    }
	  }],
	  type: 'structure'
	};
	var _default = NoteRole$1;
	NoteRole.default = _default;
	return NoteRole;
}

var OutlineRole = {};

var hasRequiredOutlineRole;

function requireOutlineRole () {
	if (hasRequiredOutlineRole) return OutlineRole;
	hasRequiredOutlineRole = 1;

	Object.defineProperty(OutlineRole, "__esModule", {
	  value: true
	});
	OutlineRole.default = void 0;
	var OutlineRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = OutlineRole$1;
	OutlineRole.default = _default;
	return OutlineRole;
}

var ParagraphRole = {};

var hasRequiredParagraphRole;

function requireParagraphRole () {
	if (hasRequiredParagraphRole) return ParagraphRole;
	hasRequiredParagraphRole = 1;

	Object.defineProperty(ParagraphRole, "__esModule", {
	  value: true
	});
	ParagraphRole.default = void 0;
	var ParagraphRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'p'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ParagraphRole$1;
	ParagraphRole.default = _default;
	return ParagraphRole;
}

var PopUpButtonRole = {};

var hasRequiredPopUpButtonRole;

function requirePopUpButtonRole () {
	if (hasRequiredPopUpButtonRole) return PopUpButtonRole;
	hasRequiredPopUpButtonRole = 1;

	Object.defineProperty(PopUpButtonRole, "__esModule", {
	  value: true
	});
	PopUpButtonRole.default = void 0;
	var PopUpButtonRole$1 = {
	  relatedConcepts: [],
	  type: 'widget'
	};
	var _default = PopUpButtonRole$1;
	PopUpButtonRole.default = _default;
	return PopUpButtonRole;
}

var PreRole = {};

var hasRequiredPreRole;

function requirePreRole () {
	if (hasRequiredPreRole) return PreRole;
	hasRequiredPreRole = 1;

	Object.defineProperty(PreRole, "__esModule", {
	  value: true
	});
	PreRole.default = void 0;
	var PreRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'pre'
	    }
	  }],
	  type: 'structure'
	};
	var _default = PreRole$1;
	PreRole.default = _default;
	return PreRole;
}

var PresentationalRole = {};

var hasRequiredPresentationalRole;

function requirePresentationalRole () {
	if (hasRequiredPresentationalRole) return PresentationalRole;
	hasRequiredPresentationalRole = 1;

	Object.defineProperty(PresentationalRole, "__esModule", {
	  value: true
	});
	PresentationalRole.default = void 0;
	var PresentationalRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'presentation'
	    }
	  }],
	  type: 'structure'
	};
	var _default = PresentationalRole$1;
	PresentationalRole.default = _default;
	return PresentationalRole;
}

var ProgressIndicatorRole = {};

var hasRequiredProgressIndicatorRole;

function requireProgressIndicatorRole () {
	if (hasRequiredProgressIndicatorRole) return ProgressIndicatorRole;
	hasRequiredProgressIndicatorRole = 1;

	Object.defineProperty(ProgressIndicatorRole, "__esModule", {
	  value: true
	});
	ProgressIndicatorRole.default = void 0;
	var ProgressIndicatorRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'progressbar'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'progress'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ProgressIndicatorRole$1;
	ProgressIndicatorRole.default = _default;
	return ProgressIndicatorRole;
}

var RadioButtonRole = {};

var hasRequiredRadioButtonRole;

function requireRadioButtonRole () {
	if (hasRequiredRadioButtonRole) return RadioButtonRole;
	hasRequiredRadioButtonRole = 1;

	Object.defineProperty(RadioButtonRole, "__esModule", {
	  value: true
	});
	RadioButtonRole.default = void 0;
	var RadioButtonRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'radio'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'radio'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = RadioButtonRole$1;
	RadioButtonRole.default = _default;
	return RadioButtonRole;
}

var RadioGroupRole = {};

var hasRequiredRadioGroupRole;

function requireRadioGroupRole () {
	if (hasRequiredRadioGroupRole) return RadioGroupRole;
	hasRequiredRadioGroupRole = 1;

	Object.defineProperty(RadioGroupRole, "__esModule", {
	  value: true
	});
	RadioGroupRole.default = void 0;
	var RadioGroupRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'radiogroup'
	    }
	  }],
	  type: 'structure'
	};
	var _default = RadioGroupRole$1;
	RadioGroupRole.default = _default;
	return RadioGroupRole;
}

var RegionRole = {};

var hasRequiredRegionRole;

function requireRegionRole () {
	if (hasRequiredRegionRole) return RegionRole;
	hasRequiredRegionRole = 1;

	Object.defineProperty(RegionRole, "__esModule", {
	  value: true
	});
	RegionRole.default = void 0;
	var RegionRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'region'
	    }
	  }],
	  type: 'structure'
	};
	var _default = RegionRole$1;
	RegionRole.default = _default;
	return RegionRole;
}

var RootWebAreaRole = {};

var hasRequiredRootWebAreaRole;

function requireRootWebAreaRole () {
	if (hasRequiredRootWebAreaRole) return RootWebAreaRole;
	hasRequiredRootWebAreaRole = 1;

	Object.defineProperty(RootWebAreaRole, "__esModule", {
	  value: true
	});
	RootWebAreaRole.default = void 0;
	var RootWebAreaRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = RootWebAreaRole$1;
	RootWebAreaRole.default = _default;
	return RootWebAreaRole;
}

var RowHeaderRole = {};

var hasRequiredRowHeaderRole;

function requireRowHeaderRole () {
	if (hasRequiredRowHeaderRole) return RowHeaderRole;
	hasRequiredRowHeaderRole = 1;

	Object.defineProperty(RowHeaderRole, "__esModule", {
	  value: true
	});
	RowHeaderRole.default = void 0;
	var RowHeaderRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'rowheader'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'th',
	      attributes: [{
	        name: 'scope',
	        value: 'row'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = RowHeaderRole$1;
	RowHeaderRole.default = _default;
	return RowHeaderRole;
}

var RowRole = {};

var hasRequiredRowRole;

function requireRowRole () {
	if (hasRequiredRowRole) return RowRole;
	hasRequiredRowRole = 1;

	Object.defineProperty(RowRole, "__esModule", {
	  value: true
	});
	RowRole.default = void 0;
	var RowRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'row'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'tr'
	    }
	  }],
	  type: 'structure'
	};
	var _default = RowRole$1;
	RowRole.default = _default;
	return RowRole;
}

var RubyRole = {};

var hasRequiredRubyRole;

function requireRubyRole () {
	if (hasRequiredRubyRole) return RubyRole;
	hasRequiredRubyRole = 1;

	Object.defineProperty(RubyRole, "__esModule", {
	  value: true
	});
	RubyRole.default = void 0;
	var RubyRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'ruby'
	    }
	  }],
	  type: 'structure'
	};
	var _default = RubyRole$1;
	RubyRole.default = _default;
	return RubyRole;
}

var RulerRole = {};

var hasRequiredRulerRole;

function requireRulerRole () {
	if (hasRequiredRulerRole) return RulerRole;
	hasRequiredRulerRole = 1;

	Object.defineProperty(RulerRole, "__esModule", {
	  value: true
	});
	RulerRole.default = void 0;
	var RulerRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = RulerRole$1;
	RulerRole.default = _default;
	return RulerRole;
}

var ScrollAreaRole = {};

var hasRequiredScrollAreaRole;

function requireScrollAreaRole () {
	if (hasRequiredScrollAreaRole) return ScrollAreaRole;
	hasRequiredScrollAreaRole = 1;

	Object.defineProperty(ScrollAreaRole, "__esModule", {
	  value: true
	});
	ScrollAreaRole.default = void 0;
	var ScrollAreaRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = ScrollAreaRole$1;
	ScrollAreaRole.default = _default;
	return ScrollAreaRole;
}

var ScrollBarRole = {};

var hasRequiredScrollBarRole;

function requireScrollBarRole () {
	if (hasRequiredScrollBarRole) return ScrollBarRole;
	hasRequiredScrollBarRole = 1;

	Object.defineProperty(ScrollBarRole, "__esModule", {
	  value: true
	});
	ScrollBarRole.default = void 0;
	var ScrollBarRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'scrollbar'
	    }
	  }],
	  type: 'widget'
	};
	var _default = ScrollBarRole$1;
	ScrollBarRole.default = _default;
	return ScrollBarRole;
}

var SeamlessWebAreaRole = {};

var hasRequiredSeamlessWebAreaRole;

function requireSeamlessWebAreaRole () {
	if (hasRequiredSeamlessWebAreaRole) return SeamlessWebAreaRole;
	hasRequiredSeamlessWebAreaRole = 1;

	Object.defineProperty(SeamlessWebAreaRole, "__esModule", {
	  value: true
	});
	SeamlessWebAreaRole.default = void 0;
	var SeamlessWebAreaRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = SeamlessWebAreaRole$1;
	SeamlessWebAreaRole.default = _default;
	return SeamlessWebAreaRole;
}

var SearchRole = {};

var hasRequiredSearchRole;

function requireSearchRole () {
	if (hasRequiredSearchRole) return SearchRole;
	hasRequiredSearchRole = 1;

	Object.defineProperty(SearchRole, "__esModule", {
	  value: true
	});
	SearchRole.default = void 0;
	var SearchRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'search'
	    }
	  }],
	  type: 'structure'
	};
	var _default = SearchRole$1;
	SearchRole.default = _default;
	return SearchRole;
}

var SearchBoxRole = {};

var hasRequiredSearchBoxRole;

function requireSearchBoxRole () {
	if (hasRequiredSearchBoxRole) return SearchBoxRole;
	hasRequiredSearchBoxRole = 1;

	Object.defineProperty(SearchBoxRole, "__esModule", {
	  value: true
	});
	SearchBoxRole.default = void 0;
	var SearchBoxRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'searchbox'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'search'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = SearchBoxRole$1;
	SearchBoxRole.default = _default;
	return SearchBoxRole;
}

var SliderRole = {};

var hasRequiredSliderRole;

function requireSliderRole () {
	if (hasRequiredSliderRole) return SliderRole;
	hasRequiredSliderRole = 1;

	Object.defineProperty(SliderRole, "__esModule", {
	  value: true
	});
	SliderRole.default = void 0;
	var SliderRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'slider'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'range'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = SliderRole$1;
	SliderRole.default = _default;
	return SliderRole;
}

var SliderThumbRole = {};

var hasRequiredSliderThumbRole;

function requireSliderThumbRole () {
	if (hasRequiredSliderThumbRole) return SliderThumbRole;
	hasRequiredSliderThumbRole = 1;

	Object.defineProperty(SliderThumbRole, "__esModule", {
	  value: true
	});
	SliderThumbRole.default = void 0;
	var SliderThumbRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = SliderThumbRole$1;
	SliderThumbRole.default = _default;
	return SliderThumbRole;
}

var SpinButtonRole = {};

var hasRequiredSpinButtonRole;

function requireSpinButtonRole () {
	if (hasRequiredSpinButtonRole) return SpinButtonRole;
	hasRequiredSpinButtonRole = 1;

	Object.defineProperty(SpinButtonRole, "__esModule", {
	  value: true
	});
	SpinButtonRole.default = void 0;
	var SpinButtonRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'spinbutton'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'number'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = SpinButtonRole$1;
	SpinButtonRole.default = _default;
	return SpinButtonRole;
}

var SpinButtonPartRole = {};

var hasRequiredSpinButtonPartRole;

function requireSpinButtonPartRole () {
	if (hasRequiredSpinButtonPartRole) return SpinButtonPartRole;
	hasRequiredSpinButtonPartRole = 1;

	Object.defineProperty(SpinButtonPartRole, "__esModule", {
	  value: true
	});
	SpinButtonPartRole.default = void 0;
	var SpinButtonPartRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = SpinButtonPartRole$1;
	SpinButtonPartRole.default = _default;
	return SpinButtonPartRole;
}

var SplitterRole = {};

var hasRequiredSplitterRole;

function requireSplitterRole () {
	if (hasRequiredSplitterRole) return SplitterRole;
	hasRequiredSplitterRole = 1;

	Object.defineProperty(SplitterRole, "__esModule", {
	  value: true
	});
	SplitterRole.default = void 0;
	var SplitterRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'separator'
	    }
	  }],
	  type: 'widget'
	};
	var _default = SplitterRole$1;
	SplitterRole.default = _default;
	return SplitterRole;
}

var StaticTextRole = {};

var hasRequiredStaticTextRole;

function requireStaticTextRole () {
	if (hasRequiredStaticTextRole) return StaticTextRole;
	hasRequiredStaticTextRole = 1;

	Object.defineProperty(StaticTextRole, "__esModule", {
	  value: true
	});
	StaticTextRole.default = void 0;
	var StaticTextRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = StaticTextRole$1;
	StaticTextRole.default = _default;
	return StaticTextRole;
}

var StatusRole = {};

var hasRequiredStatusRole;

function requireStatusRole () {
	if (hasRequiredStatusRole) return StatusRole;
	hasRequiredStatusRole = 1;

	Object.defineProperty(StatusRole, "__esModule", {
	  value: true
	});
	StatusRole.default = void 0;
	var StatusRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'status'
	    }
	  }],
	  type: 'structure'
	};
	var _default = StatusRole$1;
	StatusRole.default = _default;
	return StatusRole;
}

var SVGRootRole = {};

var hasRequiredSVGRootRole;

function requireSVGRootRole () {
	if (hasRequiredSVGRootRole) return SVGRootRole;
	hasRequiredSVGRootRole = 1;

	Object.defineProperty(SVGRootRole, "__esModule", {
	  value: true
	});
	SVGRootRole.default = void 0;
	var SVGRootRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = SVGRootRole$1;
	SVGRootRole.default = _default;
	return SVGRootRole;
}

var SwitchRole = {};

var hasRequiredSwitchRole;

function requireSwitchRole () {
	if (hasRequiredSwitchRole) return SwitchRole;
	hasRequiredSwitchRole = 1;

	Object.defineProperty(SwitchRole, "__esModule", {
	  value: true
	});
	SwitchRole.default = void 0;
	var SwitchRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'switch'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'checkbox'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = SwitchRole$1;
	SwitchRole.default = _default;
	return SwitchRole;
}

var TabGroupRole = {};

var hasRequiredTabGroupRole;

function requireTabGroupRole () {
	if (hasRequiredTabGroupRole) return TabGroupRole;
	hasRequiredTabGroupRole = 1;

	Object.defineProperty(TabGroupRole, "__esModule", {
	  value: true
	});
	TabGroupRole.default = void 0;
	var TabGroupRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'tablist'
	    }
	  }],
	  type: 'structure'
	};
	var _default = TabGroupRole$1;
	TabGroupRole.default = _default;
	return TabGroupRole;
}

var TabRole = {};

var hasRequiredTabRole;

function requireTabRole () {
	if (hasRequiredTabRole) return TabRole;
	hasRequiredTabRole = 1;

	Object.defineProperty(TabRole, "__esModule", {
	  value: true
	});
	TabRole.default = void 0;
	var TabRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'tab'
	    }
	  }],
	  type: 'widget'
	};
	var _default = TabRole$1;
	TabRole.default = _default;
	return TabRole;
}

var TableHeaderContainerRole = {};

var hasRequiredTableHeaderContainerRole;

function requireTableHeaderContainerRole () {
	if (hasRequiredTableHeaderContainerRole) return TableHeaderContainerRole;
	hasRequiredTableHeaderContainerRole = 1;

	Object.defineProperty(TableHeaderContainerRole, "__esModule", {
	  value: true
	});
	TableHeaderContainerRole.default = void 0;
	var TableHeaderContainerRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = TableHeaderContainerRole$1;
	TableHeaderContainerRole.default = _default;
	return TableHeaderContainerRole;
}

var TableRole = {};

var hasRequiredTableRole;

function requireTableRole () {
	if (hasRequiredTableRole) return TableRole;
	hasRequiredTableRole = 1;

	Object.defineProperty(TableRole, "__esModule", {
	  value: true
	});
	TableRole.default = void 0;
	var TableRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'table'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'table'
	    }
	  }],
	  type: 'structure'
	};
	var _default = TableRole$1;
	TableRole.default = _default;
	return TableRole;
}

var TabListRole = {};

var hasRequiredTabListRole;

function requireTabListRole () {
	if (hasRequiredTabListRole) return TabListRole;
	hasRequiredTabListRole = 1;

	Object.defineProperty(TabListRole, "__esModule", {
	  value: true
	});
	TabListRole.default = void 0;
	var TabListRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'tablist'
	    }
	  }],
	  type: 'structure'
	};
	var _default = TabListRole$1;
	TabListRole.default = _default;
	return TabListRole;
}

var TabPanelRole = {};

var hasRequiredTabPanelRole;

function requireTabPanelRole () {
	if (hasRequiredTabPanelRole) return TabPanelRole;
	hasRequiredTabPanelRole = 1;

	Object.defineProperty(TabPanelRole, "__esModule", {
	  value: true
	});
	TabPanelRole.default = void 0;
	var TabPanelRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'tabpanel'
	    }
	  }],
	  type: 'structure'
	};
	var _default = TabPanelRole$1;
	TabPanelRole.default = _default;
	return TabPanelRole;
}

var TermRole = {};

var hasRequiredTermRole;

function requireTermRole () {
	if (hasRequiredTermRole) return TermRole;
	hasRequiredTermRole = 1;

	Object.defineProperty(TermRole, "__esModule", {
	  value: true
	});
	TermRole.default = void 0;
	var TermRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'term'
	    }
	  }],
	  type: 'structure'
	};
	var _default = TermRole$1;
	TermRole.default = _default;
	return TermRole;
}

var TextAreaRole = {};

var hasRequiredTextAreaRole;

function requireTextAreaRole () {
	if (hasRequiredTextAreaRole) return TextAreaRole;
	hasRequiredTextAreaRole = 1;

	Object.defineProperty(TextAreaRole, "__esModule", {
	  value: true
	});
	TextAreaRole.default = void 0;
	var TextAreaRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      attributes: [{
	        name: 'aria-multiline',
	        value: 'true'
	      }],
	      name: 'textbox'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'textarea'
	    }
	  }],
	  type: 'widget'
	};
	var _default = TextAreaRole$1;
	TextAreaRole.default = _default;
	return TextAreaRole;
}

var TextFieldRole = {};

var hasRequiredTextFieldRole;

function requireTextFieldRole () {
	if (hasRequiredTextFieldRole) return TextFieldRole;
	hasRequiredTextFieldRole = 1;

	Object.defineProperty(TextFieldRole, "__esModule", {
	  value: true
	});
	TextFieldRole.default = void 0;
	var TextFieldRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'textbox'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'input'
	    }
	  }, {
	    module: 'HTML',
	    concept: {
	      name: 'input',
	      attributes: [{
	        name: 'type',
	        value: 'text'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = TextFieldRole$1;
	TextFieldRole.default = _default;
	return TextFieldRole;
}

var TimeRole = {};

var hasRequiredTimeRole;

function requireTimeRole () {
	if (hasRequiredTimeRole) return TimeRole;
	hasRequiredTimeRole = 1;

	Object.defineProperty(TimeRole, "__esModule", {
	  value: true
	});
	TimeRole.default = void 0;
	var TimeRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'time'
	    }
	  }],
	  type: 'structure'
	};
	var _default = TimeRole$1;
	TimeRole.default = _default;
	return TimeRole;
}

var TimerRole = {};

var hasRequiredTimerRole;

function requireTimerRole () {
	if (hasRequiredTimerRole) return TimerRole;
	hasRequiredTimerRole = 1;

	Object.defineProperty(TimerRole, "__esModule", {
	  value: true
	});
	TimerRole.default = void 0;
	var TimerRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'timer'
	    }
	  }],
	  type: 'structure'
	};
	var _default = TimerRole$1;
	TimerRole.default = _default;
	return TimerRole;
}

var ToggleButtonRole = {};

var hasRequiredToggleButtonRole;

function requireToggleButtonRole () {
	if (hasRequiredToggleButtonRole) return ToggleButtonRole;
	hasRequiredToggleButtonRole = 1;

	Object.defineProperty(ToggleButtonRole, "__esModule", {
	  value: true
	});
	ToggleButtonRole.default = void 0;
	var ToggleButtonRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      attributes: [{
	        name: 'aria-pressed'
	      }]
	    }
	  }],
	  type: 'widget'
	};
	var _default = ToggleButtonRole$1;
	ToggleButtonRole.default = _default;
	return ToggleButtonRole;
}

var ToolbarRole = {};

var hasRequiredToolbarRole;

function requireToolbarRole () {
	if (hasRequiredToolbarRole) return ToolbarRole;
	hasRequiredToolbarRole = 1;

	Object.defineProperty(ToolbarRole, "__esModule", {
	  value: true
	});
	ToolbarRole.default = void 0;
	var ToolbarRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'toolbar'
	    }
	  }],
	  type: 'structure'
	};
	var _default = ToolbarRole$1;
	ToolbarRole.default = _default;
	return ToolbarRole;
}

var TreeRole = {};

var hasRequiredTreeRole;

function requireTreeRole () {
	if (hasRequiredTreeRole) return TreeRole;
	hasRequiredTreeRole = 1;

	Object.defineProperty(TreeRole, "__esModule", {
	  value: true
	});
	TreeRole.default = void 0;
	var TreeRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'tree'
	    }
	  }],
	  type: 'widget'
	};
	var _default = TreeRole$1;
	TreeRole.default = _default;
	return TreeRole;
}

var TreeGridRole = {};

var hasRequiredTreeGridRole;

function requireTreeGridRole () {
	if (hasRequiredTreeGridRole) return TreeGridRole;
	hasRequiredTreeGridRole = 1;

	Object.defineProperty(TreeGridRole, "__esModule", {
	  value: true
	});
	TreeGridRole.default = void 0;
	var TreeGridRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'treegrid'
	    }
	  }],
	  type: 'widget'
	};
	var _default = TreeGridRole$1;
	TreeGridRole.default = _default;
	return TreeGridRole;
}

var TreeItemRole = {};

var hasRequiredTreeItemRole;

function requireTreeItemRole () {
	if (hasRequiredTreeItemRole) return TreeItemRole;
	hasRequiredTreeItemRole = 1;

	Object.defineProperty(TreeItemRole, "__esModule", {
	  value: true
	});
	TreeItemRole.default = void 0;
	var TreeItemRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'treeitem'
	    }
	  }],
	  type: 'widget'
	};
	var _default = TreeItemRole$1;
	TreeItemRole.default = _default;
	return TreeItemRole;
}

var UserInterfaceTooltipRole = {};

var hasRequiredUserInterfaceTooltipRole;

function requireUserInterfaceTooltipRole () {
	if (hasRequiredUserInterfaceTooltipRole) return UserInterfaceTooltipRole;
	hasRequiredUserInterfaceTooltipRole = 1;

	Object.defineProperty(UserInterfaceTooltipRole, "__esModule", {
	  value: true
	});
	UserInterfaceTooltipRole.default = void 0;
	var UserInterfaceTooltipRole$1 = {
	  relatedConcepts: [{
	    module: 'ARIA',
	    concept: {
	      name: 'tooltip'
	    }
	  }],
	  type: 'structure'
	};
	var _default = UserInterfaceTooltipRole$1;
	UserInterfaceTooltipRole.default = _default;
	return UserInterfaceTooltipRole;
}

var VideoRole = {};

var hasRequiredVideoRole;

function requireVideoRole () {
	if (hasRequiredVideoRole) return VideoRole;
	hasRequiredVideoRole = 1;

	Object.defineProperty(VideoRole, "__esModule", {
	  value: true
	});
	VideoRole.default = void 0;
	var VideoRole$1 = {
	  relatedConcepts: [{
	    module: 'HTML',
	    concept: {
	      name: 'video'
	    }
	  }],
	  type: 'widget'
	};
	var _default = VideoRole$1;
	VideoRole.default = _default;
	return VideoRole;
}

var WebAreaRole = {};

var hasRequiredWebAreaRole;

function requireWebAreaRole () {
	if (hasRequiredWebAreaRole) return WebAreaRole;
	hasRequiredWebAreaRole = 1;

	Object.defineProperty(WebAreaRole, "__esModule", {
	  value: true
	});
	WebAreaRole.default = void 0;
	var WebAreaRole$1 = {
	  relatedConcepts: [],
	  type: 'structure'
	};
	var _default = WebAreaRole$1;
	WebAreaRole.default = _default;
	return WebAreaRole;
}

var WindowRole = {};

var hasRequiredWindowRole;

function requireWindowRole () {
	if (hasRequiredWindowRole) return WindowRole;
	hasRequiredWindowRole = 1;

	Object.defineProperty(WindowRole, "__esModule", {
	  value: true
	});
	WindowRole.default = void 0;
	var WindowRole$1 = {
	  relatedConcepts: [],
	  type: 'window'
	};
	var _default = WindowRole$1;
	WindowRole.default = _default;
	return WindowRole;
}

var hasRequiredAXObjectsMap;

function requireAXObjectsMap () {
	if (hasRequiredAXObjectsMap) return AXObjectsMap;
	hasRequiredAXObjectsMap = 1;

	Object.defineProperty(AXObjectsMap, "__esModule", {
	  value: true
	});
	AXObjectsMap.default = void 0;
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator());
	var _AbbrRole = _interopRequireDefault(requireAbbrRole());
	var _AlertDialogRole = _interopRequireDefault(requireAlertDialogRole());
	var _AlertRole = _interopRequireDefault(requireAlertRole());
	var _AnnotationRole = _interopRequireDefault(requireAnnotationRole());
	var _ApplicationRole = _interopRequireDefault(requireApplicationRole());
	var _ArticleRole = _interopRequireDefault(requireArticleRole());
	var _AudioRole = _interopRequireDefault(requireAudioRole());
	var _BannerRole = _interopRequireDefault(requireBannerRole());
	var _BlockquoteRole = _interopRequireDefault(requireBlockquoteRole());
	var _BusyIndicatorRole = _interopRequireDefault(requireBusyIndicatorRole());
	var _ButtonRole = _interopRequireDefault(requireButtonRole());
	var _CanvasRole = _interopRequireDefault(requireCanvasRole());
	var _CaptionRole = _interopRequireDefault(requireCaptionRole());
	var _CellRole = _interopRequireDefault(requireCellRole());
	var _CheckBoxRole = _interopRequireDefault(requireCheckBoxRole());
	var _ColorWellRole = _interopRequireDefault(requireColorWellRole());
	var _ColumnHeaderRole = _interopRequireDefault(requireColumnHeaderRole());
	var _ColumnRole = _interopRequireDefault(requireColumnRole());
	var _ComboBoxRole = _interopRequireDefault(requireComboBoxRole());
	var _ComplementaryRole = _interopRequireDefault(requireComplementaryRole());
	var _ContentInfoRole = _interopRequireDefault(requireContentInfoRole());
	var _DateRole = _interopRequireDefault(requireDateRole());
	var _DateTimeRole = _interopRequireDefault(requireDateTimeRole());
	var _DefinitionRole = _interopRequireDefault(requireDefinitionRole());
	var _DescriptionListDetailRole = _interopRequireDefault(requireDescriptionListDetailRole());
	var _DescriptionListRole = _interopRequireDefault(requireDescriptionListRole());
	var _DescriptionListTermRole = _interopRequireDefault(requireDescriptionListTermRole());
	var _DetailsRole = _interopRequireDefault(requireDetailsRole());
	var _DialogRole = _interopRequireDefault(requireDialogRole());
	var _DirectoryRole = _interopRequireDefault(requireDirectoryRole());
	var _DisclosureTriangleRole = _interopRequireDefault(requireDisclosureTriangleRole());
	var _DivRole = _interopRequireDefault(requireDivRole());
	var _DocumentRole = _interopRequireDefault(requireDocumentRole());
	var _EmbeddedObjectRole = _interopRequireDefault(requireEmbeddedObjectRole());
	var _FeedRole = _interopRequireDefault(requireFeedRole());
	var _FigcaptionRole = _interopRequireDefault(requireFigcaptionRole());
	var _FigureRole = _interopRequireDefault(requireFigureRole());
	var _FooterRole = _interopRequireDefault(requireFooterRole());
	var _FormRole = _interopRequireDefault(requireFormRole());
	var _GridRole = _interopRequireDefault(requireGridRole());
	var _GroupRole = _interopRequireDefault(requireGroupRole());
	var _HeadingRole = _interopRequireDefault(requireHeadingRole());
	var _IframePresentationalRole = _interopRequireDefault(requireIframePresentationalRole());
	var _IframeRole = _interopRequireDefault(requireIframeRole());
	var _IgnoredRole = _interopRequireDefault(requireIgnoredRole());
	var _ImageMapLinkRole = _interopRequireDefault(requireImageMapLinkRole());
	var _ImageMapRole = _interopRequireDefault(requireImageMapRole());
	var _ImageRole = _interopRequireDefault(requireImageRole());
	var _InlineTextBoxRole = _interopRequireDefault(requireInlineTextBoxRole());
	var _InputTimeRole = _interopRequireDefault(requireInputTimeRole());
	var _LabelRole = _interopRequireDefault(requireLabelRole());
	var _LegendRole = _interopRequireDefault(requireLegendRole());
	var _LineBreakRole = _interopRequireDefault(requireLineBreakRole());
	var _LinkRole = _interopRequireDefault(requireLinkRole());
	var _ListBoxOptionRole = _interopRequireDefault(requireListBoxOptionRole());
	var _ListBoxRole = _interopRequireDefault(requireListBoxRole());
	var _ListItemRole = _interopRequireDefault(requireListItemRole());
	var _ListMarkerRole = _interopRequireDefault(requireListMarkerRole());
	var _ListRole = _interopRequireDefault(requireListRole());
	var _LogRole = _interopRequireDefault(requireLogRole());
	var _MainRole = _interopRequireDefault(requireMainRole());
	var _MarkRole = _interopRequireDefault(requireMarkRole());
	var _MarqueeRole = _interopRequireDefault(requireMarqueeRole());
	var _MathRole = _interopRequireDefault(requireMathRole());
	var _MenuBarRole = _interopRequireDefault(requireMenuBarRole());
	var _MenuButtonRole = _interopRequireDefault(requireMenuButtonRole());
	var _MenuItemRole = _interopRequireDefault(requireMenuItemRole());
	var _MenuItemCheckBoxRole = _interopRequireDefault(requireMenuItemCheckBoxRole());
	var _MenuItemRadioRole = _interopRequireDefault(requireMenuItemRadioRole());
	var _MenuListOptionRole = _interopRequireDefault(requireMenuListOptionRole());
	var _MenuListPopupRole = _interopRequireDefault(requireMenuListPopupRole());
	var _MenuRole = _interopRequireDefault(requireMenuRole());
	var _MeterRole = _interopRequireDefault(requireMeterRole());
	var _NavigationRole = _interopRequireDefault(requireNavigationRole());
	var _NoneRole = _interopRequireDefault(requireNoneRole());
	var _NoteRole = _interopRequireDefault(requireNoteRole());
	var _OutlineRole = _interopRequireDefault(requireOutlineRole());
	var _ParagraphRole = _interopRequireDefault(requireParagraphRole());
	var _PopUpButtonRole = _interopRequireDefault(requirePopUpButtonRole());
	var _PreRole = _interopRequireDefault(requirePreRole());
	var _PresentationalRole = _interopRequireDefault(requirePresentationalRole());
	var _ProgressIndicatorRole = _interopRequireDefault(requireProgressIndicatorRole());
	var _RadioButtonRole = _interopRequireDefault(requireRadioButtonRole());
	var _RadioGroupRole = _interopRequireDefault(requireRadioGroupRole());
	var _RegionRole = _interopRequireDefault(requireRegionRole());
	var _RootWebAreaRole = _interopRequireDefault(requireRootWebAreaRole());
	var _RowHeaderRole = _interopRequireDefault(requireRowHeaderRole());
	var _RowRole = _interopRequireDefault(requireRowRole());
	var _RubyRole = _interopRequireDefault(requireRubyRole());
	var _RulerRole = _interopRequireDefault(requireRulerRole());
	var _ScrollAreaRole = _interopRequireDefault(requireScrollAreaRole());
	var _ScrollBarRole = _interopRequireDefault(requireScrollBarRole());
	var _SeamlessWebAreaRole = _interopRequireDefault(requireSeamlessWebAreaRole());
	var _SearchRole = _interopRequireDefault(requireSearchRole());
	var _SearchBoxRole = _interopRequireDefault(requireSearchBoxRole());
	var _SliderRole = _interopRequireDefault(requireSliderRole());
	var _SliderThumbRole = _interopRequireDefault(requireSliderThumbRole());
	var _SpinButtonRole = _interopRequireDefault(requireSpinButtonRole());
	var _SpinButtonPartRole = _interopRequireDefault(requireSpinButtonPartRole());
	var _SplitterRole = _interopRequireDefault(requireSplitterRole());
	var _StaticTextRole = _interopRequireDefault(requireStaticTextRole());
	var _StatusRole = _interopRequireDefault(requireStatusRole());
	var _SVGRootRole = _interopRequireDefault(requireSVGRootRole());
	var _SwitchRole = _interopRequireDefault(requireSwitchRole());
	var _TabGroupRole = _interopRequireDefault(requireTabGroupRole());
	var _TabRole = _interopRequireDefault(requireTabRole());
	var _TableHeaderContainerRole = _interopRequireDefault(requireTableHeaderContainerRole());
	var _TableRole = _interopRequireDefault(requireTableRole());
	var _TabListRole = _interopRequireDefault(requireTabListRole());
	var _TabPanelRole = _interopRequireDefault(requireTabPanelRole());
	var _TermRole = _interopRequireDefault(requireTermRole());
	var _TextAreaRole = _interopRequireDefault(requireTextAreaRole());
	var _TextFieldRole = _interopRequireDefault(requireTextFieldRole());
	var _TimeRole = _interopRequireDefault(requireTimeRole());
	var _TimerRole = _interopRequireDefault(requireTimerRole());
	var _ToggleButtonRole = _interopRequireDefault(requireToggleButtonRole());
	var _ToolbarRole = _interopRequireDefault(requireToolbarRole());
	var _TreeRole = _interopRequireDefault(requireTreeRole());
	var _TreeGridRole = _interopRequireDefault(requireTreeGridRole());
	var _TreeItemRole = _interopRequireDefault(requireTreeItemRole());
	var _UserInterfaceTooltipRole = _interopRequireDefault(requireUserInterfaceTooltipRole());
	var _VideoRole = _interopRequireDefault(requireVideoRole());
	var _WebAreaRole = _interopRequireDefault(requireWebAreaRole());
	var _WindowRole = _interopRequireDefault(requireWindowRole());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var AXObjects = [['AbbrRole', _AbbrRole.default], ['AlertDialogRole', _AlertDialogRole.default], ['AlertRole', _AlertRole.default], ['AnnotationRole', _AnnotationRole.default], ['ApplicationRole', _ApplicationRole.default], ['ArticleRole', _ArticleRole.default], ['AudioRole', _AudioRole.default], ['BannerRole', _BannerRole.default], ['BlockquoteRole', _BlockquoteRole.default], ['BusyIndicatorRole', _BusyIndicatorRole.default], ['ButtonRole', _ButtonRole.default], ['CanvasRole', _CanvasRole.default], ['CaptionRole', _CaptionRole.default], ['CellRole', _CellRole.default], ['CheckBoxRole', _CheckBoxRole.default], ['ColorWellRole', _ColorWellRole.default], ['ColumnHeaderRole', _ColumnHeaderRole.default], ['ColumnRole', _ColumnRole.default], ['ComboBoxRole', _ComboBoxRole.default], ['ComplementaryRole', _ComplementaryRole.default], ['ContentInfoRole', _ContentInfoRole.default], ['DateRole', _DateRole.default], ['DateTimeRole', _DateTimeRole.default], ['DefinitionRole', _DefinitionRole.default], ['DescriptionListDetailRole', _DescriptionListDetailRole.default], ['DescriptionListRole', _DescriptionListRole.default], ['DescriptionListTermRole', _DescriptionListTermRole.default], ['DetailsRole', _DetailsRole.default], ['DialogRole', _DialogRole.default], ['DirectoryRole', _DirectoryRole.default], ['DisclosureTriangleRole', _DisclosureTriangleRole.default], ['DivRole', _DivRole.default], ['DocumentRole', _DocumentRole.default], ['EmbeddedObjectRole', _EmbeddedObjectRole.default], ['FeedRole', _FeedRole.default], ['FigcaptionRole', _FigcaptionRole.default], ['FigureRole', _FigureRole.default], ['FooterRole', _FooterRole.default], ['FormRole', _FormRole.default], ['GridRole', _GridRole.default], ['GroupRole', _GroupRole.default], ['HeadingRole', _HeadingRole.default], ['IframePresentationalRole', _IframePresentationalRole.default], ['IframeRole', _IframeRole.default], ['IgnoredRole', _IgnoredRole.default], ['ImageMapLinkRole', _ImageMapLinkRole.default], ['ImageMapRole', _ImageMapRole.default], ['ImageRole', _ImageRole.default], ['InlineTextBoxRole', _InlineTextBoxRole.default], ['InputTimeRole', _InputTimeRole.default], ['LabelRole', _LabelRole.default], ['LegendRole', _LegendRole.default], ['LineBreakRole', _LineBreakRole.default], ['LinkRole', _LinkRole.default], ['ListBoxOptionRole', _ListBoxOptionRole.default], ['ListBoxRole', _ListBoxRole.default], ['ListItemRole', _ListItemRole.default], ['ListMarkerRole', _ListMarkerRole.default], ['ListRole', _ListRole.default], ['LogRole', _LogRole.default], ['MainRole', _MainRole.default], ['MarkRole', _MarkRole.default], ['MarqueeRole', _MarqueeRole.default], ['MathRole', _MathRole.default], ['MenuBarRole', _MenuBarRole.default], ['MenuButtonRole', _MenuButtonRole.default], ['MenuItemRole', _MenuItemRole.default], ['MenuItemCheckBoxRole', _MenuItemCheckBoxRole.default], ['MenuItemRadioRole', _MenuItemRadioRole.default], ['MenuListOptionRole', _MenuListOptionRole.default], ['MenuListPopupRole', _MenuListPopupRole.default], ['MenuRole', _MenuRole.default], ['MeterRole', _MeterRole.default], ['NavigationRole', _NavigationRole.default], ['NoneRole', _NoneRole.default], ['NoteRole', _NoteRole.default], ['OutlineRole', _OutlineRole.default], ['ParagraphRole', _ParagraphRole.default], ['PopUpButtonRole', _PopUpButtonRole.default], ['PreRole', _PreRole.default], ['PresentationalRole', _PresentationalRole.default], ['ProgressIndicatorRole', _ProgressIndicatorRole.default], ['RadioButtonRole', _RadioButtonRole.default], ['RadioGroupRole', _RadioGroupRole.default], ['RegionRole', _RegionRole.default], ['RootWebAreaRole', _RootWebAreaRole.default], ['RowHeaderRole', _RowHeaderRole.default], ['RowRole', _RowRole.default], ['RubyRole', _RubyRole.default], ['RulerRole', _RulerRole.default], ['ScrollAreaRole', _ScrollAreaRole.default], ['ScrollBarRole', _ScrollBarRole.default], ['SeamlessWebAreaRole', _SeamlessWebAreaRole.default], ['SearchRole', _SearchRole.default], ['SearchBoxRole', _SearchBoxRole.default], ['SliderRole', _SliderRole.default], ['SliderThumbRole', _SliderThumbRole.default], ['SpinButtonRole', _SpinButtonRole.default], ['SpinButtonPartRole', _SpinButtonPartRole.default], ['SplitterRole', _SplitterRole.default], ['StaticTextRole', _StaticTextRole.default], ['StatusRole', _StatusRole.default], ['SVGRootRole', _SVGRootRole.default], ['SwitchRole', _SwitchRole.default], ['TabGroupRole', _TabGroupRole.default], ['TabRole', _TabRole.default], ['TableHeaderContainerRole', _TableHeaderContainerRole.default], ['TableRole', _TableRole.default], ['TabListRole', _TabListRole.default], ['TabPanelRole', _TabPanelRole.default], ['TermRole', _TermRole.default], ['TextAreaRole', _TextAreaRole.default], ['TextFieldRole', _TextFieldRole.default], ['TimeRole', _TimeRole.default], ['TimerRole', _TimerRole.default], ['ToggleButtonRole', _ToggleButtonRole.default], ['ToolbarRole', _ToolbarRole.default], ['TreeRole', _TreeRole.default], ['TreeGridRole', _TreeGridRole.default], ['TreeItemRole', _TreeItemRole.default], ['UserInterfaceTooltipRole', _UserInterfaceTooltipRole.default], ['VideoRole', _VideoRole.default], ['WebAreaRole', _WebAreaRole.default], ['WindowRole', _WindowRole.default]];
	var AXObjectsMap$1 = {
	  entries: function entries() {
	    return AXObjects;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    var _iterator = _createForOfIteratorHelper(AXObjects),
	      _step;
	    try {
	      for (_iterator.s(); !(_step = _iterator.n()).done;) {
	        var _step$value = _slicedToArray(_step.value, 2),
	          key = _step$value[0],
	          values = _step$value[1];
	        fn.call(thisArg, values, key, AXObjects);
	      }
	    } catch (err) {
	      _iterator.e(err);
	    } finally {
	      _iterator.f();
	    }
	  },
	  get: function get(key) {
	    var item = AXObjects.find(function (tuple) {
	      return tuple[0] === key ? true : false;
	    });
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!AXObjectsMap$1.get(key);
	  },
	  keys: function keys() {
	    return AXObjects.map(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	        key = _ref2[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return AXObjects.map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        values = _ref4[1];
	      return values;
	    });
	  }
	};
	var _default = (0, _iterationDecorator.default)(AXObjectsMap$1, AXObjectsMap$1.entries());
	AXObjectsMap.default = _default;
	return AXObjectsMap;
}

var hasRequiredAXObjectElementMap;

function requireAXObjectElementMap () {
	if (hasRequiredAXObjectElementMap) return AXObjectElementMap;
	hasRequiredAXObjectElementMap = 1;

	Object.defineProperty(AXObjectElementMap, "__esModule", {
	  value: true
	});
	AXObjectElementMap.default = void 0;
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator());
	var _AXObjectsMap = _interopRequireDefault(requireAXObjectsMap());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var AXObjectElements = [];
	var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()),
	  _step;
	try {
	  var _loop = function _loop() {
	    var _step$value = _slicedToArray(_step.value, 2),
	      name = _step$value[0],
	      def = _step$value[1];
	    var relatedConcepts = def.relatedConcepts;
	    if (Array.isArray(relatedConcepts)) {
	      relatedConcepts.forEach(function (relation) {
	        if (relation.module === 'HTML') {
	          var concept = relation.concept;
	          if (concept) {
	            var index = AXObjectElements.findIndex(function (_ref5) {
	              var _ref6 = _slicedToArray(_ref5, 1),
	                key = _ref6[0];
	              return key === name;
	            });
	            if (index === -1) {
	              AXObjectElements.push([name, []]);
	              index = AXObjectElements.length - 1;
	            }
	            AXObjectElements[index][1].push(concept);
	          }
	        }
	      });
	    }
	  };
	  for (_iterator.s(); !(_step = _iterator.n()).done;) {
	    _loop();
	  }
	} catch (err) {
	  _iterator.e(err);
	} finally {
	  _iterator.f();
	}
	var AXObjectElementMap$1 = {
	  entries: function entries() {
	    return AXObjectElements;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    var _iterator2 = _createForOfIteratorHelper(AXObjectElements),
	      _step2;
	    try {
	      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	        var _step2$value = _slicedToArray(_step2.value, 2),
	          key = _step2$value[0],
	          values = _step2$value[1];
	        fn.call(thisArg, values, key, AXObjectElements);
	      }
	    } catch (err) {
	      _iterator2.e(err);
	    } finally {
	      _iterator2.f();
	    }
	  },
	  get: function get(key) {
	    var item = AXObjectElements.find(function (tuple) {
	      return tuple[0] === key ? true : false;
	    });
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!AXObjectElementMap$1.get(key);
	  },
	  keys: function keys() {
	    return AXObjectElements.map(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	        key = _ref2[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return AXObjectElements.map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        values = _ref4[1];
	      return values;
	    });
	  }
	};
	var _default = (0, _iterationDecorator.default)(AXObjectElementMap$1, AXObjectElementMap$1.entries());
	AXObjectElementMap.default = _default;
	return AXObjectElementMap;
}

var AXObjectRoleMap = {};

var hasRequiredAXObjectRoleMap;

function requireAXObjectRoleMap () {
	if (hasRequiredAXObjectRoleMap) return AXObjectRoleMap;
	hasRequiredAXObjectRoleMap = 1;

	Object.defineProperty(AXObjectRoleMap, "__esModule", {
	  value: true
	});
	AXObjectRoleMap.default = void 0;
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator());
	var _AXObjectsMap = _interopRequireDefault(requireAXObjectsMap());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var AXObjectRoleElements = [];
	var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()),
	  _step;
	try {
	  var _loop = function _loop() {
	    var _step$value = _slicedToArray(_step.value, 2),
	      name = _step$value[0],
	      def = _step$value[1];
	    var relatedConcepts = def.relatedConcepts;
	    if (Array.isArray(relatedConcepts)) {
	      relatedConcepts.forEach(function (relation) {
	        if (relation.module === 'ARIA') {
	          var concept = relation.concept;
	          if (concept) {
	            var index = AXObjectRoleElements.findIndex(function (_ref5) {
	              var _ref6 = _slicedToArray(_ref5, 1),
	                key = _ref6[0];
	              return key === name;
	            });
	            if (index === -1) {
	              AXObjectRoleElements.push([name, []]);
	              index = AXObjectRoleElements.length - 1;
	            }
	            AXObjectRoleElements[index][1].push(concept);
	          }
	        }
	      });
	    }
	  };
	  for (_iterator.s(); !(_step = _iterator.n()).done;) {
	    _loop();
	  }
	} catch (err) {
	  _iterator.e(err);
	} finally {
	  _iterator.f();
	}
	var AXObjectRoleMap$1 = {
	  entries: function entries() {
	    return AXObjectRoleElements;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    var _iterator2 = _createForOfIteratorHelper(AXObjectRoleElements),
	      _step2;
	    try {
	      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	        var _step2$value = _slicedToArray(_step2.value, 2),
	          key = _step2$value[0],
	          values = _step2$value[1];
	        fn.call(thisArg, values, key, AXObjectRoleElements);
	      }
	    } catch (err) {
	      _iterator2.e(err);
	    } finally {
	      _iterator2.f();
	    }
	  },
	  get: function get(key) {
	    var item = AXObjectRoleElements.find(function (tuple) {
	      return tuple[0] === key ? true : false;
	    });
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!AXObjectRoleMap$1.get(key);
	  },
	  keys: function keys() {
	    return AXObjectRoleElements.map(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	        key = _ref2[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return AXObjectRoleElements.map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        values = _ref4[1];
	      return values;
	    });
	  }
	};
	var _default = (0, _iterationDecorator.default)(AXObjectRoleMap$1, AXObjectRoleMap$1.entries());
	AXObjectRoleMap.default = _default;
	return AXObjectRoleMap;
}

var elementAXObjectMap = {};

var hasRequiredElementAXObjectMap;

function requireElementAXObjectMap () {
	if (hasRequiredElementAXObjectMap) return elementAXObjectMap;
	hasRequiredElementAXObjectMap = 1;

	Object.defineProperty(elementAXObjectMap, "__esModule", {
	  value: true
	});
	elementAXObjectMap.default = void 0;
	var _lite = requireLite();
	var _AXObjectsMap = _interopRequireDefault(requireAXObjectsMap());
	var _iterationDecorator = _interopRequireDefault(requireIterationDecorator());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
	function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
	function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var elementAXObjects = [];
	var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()),
	  _step;
	try {
	  var _loop = function _loop() {
	    var _step$value = _slicedToArray(_step.value, 2),
	      name = _step$value[0],
	      def = _step$value[1];
	    var relatedConcepts = def.relatedConcepts;
	    if (Array.isArray(relatedConcepts)) {
	      relatedConcepts.forEach(function (relation) {
	        if (relation.module === 'HTML') {
	          var concept = relation.concept;
	          if (concept != null) {
	            var conceptStr = JSON.stringify(concept);
	            var axObjects;
	            var index = 0;
	            for (; index < elementAXObjects.length; index++) {
	              var key = elementAXObjects[index][0];
	              if (JSON.stringify(key) === conceptStr) {
	                axObjects = elementAXObjects[index][1];
	                break;
	              }
	            }
	            if (!Array.isArray(axObjects)) {
	              axObjects = [];
	            }
	            var loc = axObjects.findIndex(function (item) {
	              return item === name;
	            });
	            if (loc === -1) {
	              axObjects.push(name);
	            }
	            if (index < elementAXObjects.length) {
	              elementAXObjects.splice(index, 1, [concept, axObjects]);
	            } else {
	              elementAXObjects.push([concept, axObjects]);
	            }
	          }
	        }
	      });
	    }
	  };
	  for (_iterator.s(); !(_step = _iterator.n()).done;) {
	    _loop();
	  }
	} catch (err) {
	  _iterator.e(err);
	} finally {
	  _iterator.f();
	}
	var elementAXObjectMap$1 = {
	  entries: function entries() {
	    return elementAXObjects;
	  },
	  forEach: function forEach(fn) {
	    var thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    var _iterator2 = _createForOfIteratorHelper(elementAXObjects),
	      _step2;
	    try {
	      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
	        var _step2$value = _slicedToArray(_step2.value, 2),
	          key = _step2$value[0],
	          values = _step2$value[1];
	        fn.call(thisArg, values, key, elementAXObjects);
	      }
	    } catch (err) {
	      _iterator2.e(err);
	    } finally {
	      _iterator2.f();
	    }
	  },
	  get: function get(key) {
	    var item = elementAXObjects.find(function (tuple) {
	      return key.name === tuple[0].name && (0, _lite.dequal)(key.attributes, tuple[0].attributes);
	    });
	    return item && item[1];
	  },
	  has: function has(key) {
	    return !!elementAXObjectMap$1.get(key);
	  },
	  keys: function keys() {
	    return elementAXObjects.map(function (_ref) {
	      var _ref2 = _slicedToArray(_ref, 1),
	        key = _ref2[0];
	      return key;
	    });
	  },
	  values: function values() {
	    return elementAXObjects.map(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	        values = _ref4[1];
	      return values;
	    });
	  }
	};
	var _default = (0, _iterationDecorator.default)(elementAXObjectMap$1, elementAXObjectMap$1.entries());
	elementAXObjectMap.default = _default;
	return elementAXObjectMap;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib$3;
	hasRequiredLib = 1;

	Object.defineProperty(lib$3, "__esModule", {
	  value: true
	});
	lib$3.elementAXObjects = lib$3.AXObjects = lib$3.AXObjectRoles = lib$3.AXObjectElements = void 0;
	var _AXObjectElementMap = _interopRequireDefault(requireAXObjectElementMap());
	var _AXObjectRoleMap = _interopRequireDefault(requireAXObjectRoleMap());
	var _AXObjectsMap = _interopRequireDefault(requireAXObjectsMap());
	var _elementAXObjectMap = _interopRequireDefault(requireElementAXObjectMap());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	var AXObjectElements = _AXObjectElementMap.default;
	lib$3.AXObjectElements = AXObjectElements;
	var AXObjectRoles = _AXObjectRoleMap.default;
	lib$3.AXObjectRoles = AXObjectRoles;
	var AXObjects = _AXObjectsMap.default;
	lib$3.AXObjects = AXObjects;
	var elementAXObjects = _elementAXObjectMap.default;
	lib$3.elementAXObjects = elementAXObjects;
	return lib$3;
}

var libExports = requireLib();

const aria_roles$1 = libExports$1.roles.keys();
const abstract_roles = new Set(aria_roles$1.filter((role) => libExports$1.roles.get(role).abstract));
const non_abstract_roles = aria_roles$1.filter((name) => !abstract_roles.has(name));
const non_interactive_roles = new Set(
	non_abstract_roles
		.filter((name) => {
			const role = libExports$1.roles.get(name);
			return (
				// 'toolbar' does not descend from widget, but it does support
				// aria-activedescendant, thus in practice we treat it as a widget.
				// focusable tabpanel elements are recommended if any panels in a set contain content where the first element in the panel is not focusable.
				// 'generic' is meant to have no semantic meaning.
				// 'cell' is treated as CellRole by the AXObject which is interactive, so we treat 'cell' it as interactive as well.
				!['toolbar', 'tabpanel', 'generic', 'cell'].includes(name) &&
				!role.superClass.some((classes) => classes.includes('widget'))
			);
		})
		.concat(
			// The `progressbar` is descended from `widget`, but in practice, its
			// value is always `readonly`, so we treat it as a non-interactive role.
			'progressbar'
		)
);
const interactive_roles = new Set(
	non_abstract_roles.filter(
		(name) =>
			!non_interactive_roles.has(name) &&
			// 'generic' is meant to have no semantic meaning.
			name !== 'generic'
	)
);
libExports$1.elementRoles.entries().forEach(([schema, roles]) => {
	if ([...roles].every((role) => role !== 'generic' && non_interactive_roles.has(role))) ;
});
libExports$1.elementRoles.entries().forEach(([schema, roles]) => {
	if ([...roles].every((role) => interactive_roles.has(role))) ;
});
const interactive_ax_objects = new Set(
	[...libExports.AXObjects.keys()].filter((name) => libExports.AXObjects.get(name).type === 'widget')
);
const non_interactive_ax_objects = new Set(
	[...libExports.AXObjects.keys()].filter((name) =>
		['windows', 'structure'].includes(libExports.AXObjects.get(name).type)
	)
);
libExports.elementAXObjects.entries().forEach(([schema, ax_object]) => {
	if ([...ax_object].every((role) => interactive_ax_objects.has(role))) ;
});
libExports.elementAXObjects.entries().forEach(([schema, ax_object]) => {
	if ([...ax_object].every((role) => non_interactive_ax_objects.has(role))) ;
});

const aria_attributes =
	'activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext'.split(
		' '
	);
new Set(aria_attributes);
const aria_roles = libExports$1.roles.keys();
new Set(aria_roles);

x`true`;
x`false`;

const svg_attributes =
	'accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan'.split(
		' '
	);

const svg_attribute_lookup = new Map();

svg_attributes.forEach((name) => {
	svg_attribute_lookup.set(name.toLowerCase(), name);
});

/**
 * @type {{
 *  [key in import('../../../../../shared/boolean_attributes.js').BooleanAttributes]: { property_name?: string; applies_to?: string[] } } &
 *  { [key in string]: { property_name?: string; applies_to?: string[] }; }
 * }
 */
const attribute_lookup = {
	allowfullscreen: { property_name: 'allowFullscreen', applies_to: ['iframe'] },
	allowpaymentrequest: { property_name: 'allowPaymentRequest', applies_to: ['iframe'] },
	async: { applies_to: ['script'] },
	autofocus: { applies_to: ['button', 'input', 'keygen', 'select', 'textarea'] },
	autoplay: { applies_to: ['audio', 'video'] },
	checked: { applies_to: ['input'] },
	controls: { applies_to: ['audio', 'video'] },
	default: { applies_to: ['track'] },
	defer: { applies_to: ['script'] },
	disabled: {
		applies_to: [
			'button',
			'fieldset',
			'input',
			'keygen',
			'optgroup',
			'option',
			'select',
			'textarea'
		]
	},
	formnovalidate: { property_name: 'formNoValidate', applies_to: ['button', 'input'] },
	hidden: {},
	indeterminate: { applies_to: ['input'] },
	inert: {},
	ismap: { property_name: 'isMap', applies_to: ['img'] },
	loop: { applies_to: ['audio', 'bgsound', 'video'] },
	multiple: { applies_to: ['input', 'select'] },
	muted: { applies_to: ['audio', 'video'] },
	nomodule: { property_name: 'noModule', applies_to: ['script'] },
	novalidate: { property_name: 'noValidate', applies_to: ['form'] },
	open: { applies_to: ['details', 'dialog'] },
	playsinline: { property_name: 'playsInline', applies_to: ['video'] },
	readonly: { property_name: 'readOnly', applies_to: ['input', 'textarea'] },
	required: { applies_to: ['input', 'select', 'textarea'] },
	reversed: { applies_to: ['ol'] },
	selected: { applies_to: ['option'] },
	value: {
		applies_to: [
			'button',
			'option',
			'input',
			'li',
			'meter',
			'progress',
			'param',
			'select',
			'textarea'
		]
	}
};
Object.keys(attribute_lookup).forEach((name) => {
	const metadata = attribute_lookup[name];
	if (!metadata.property_name) metadata.property_name = name;
});

const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const intToChar = new Uint8Array(64); // 64 possible chars.
const charToInt = new Uint8Array(128); // z is 122 in ASCII
for (let i = 0; i < chars.length; i++) {
    const c = chars.charCodeAt(i);
    intToChar[i] = c;
    charToInt[c] = i;
}

// Matches the scheme of a URL, eg "http://"
var UrlType;
(function (UrlType) {
    UrlType[UrlType["Empty"] = 1] = "Empty";
    UrlType[UrlType["Hash"] = 2] = "Hash";
    UrlType[UrlType["Query"] = 3] = "Query";
    UrlType[UrlType["RelativePath"] = 4] = "RelativePath";
    UrlType[UrlType["AbsolutePath"] = 5] = "AbsolutePath";
    UrlType[UrlType["SchemeRelative"] = 6] = "SchemeRelative";
    UrlType[UrlType["Absolute"] = 7] = "Absolute";
})(UrlType || (UrlType = {}));

var bail_1 = bail;

function bail(err) {
  if (err) {
    throw err
  }
}

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

var isBuffer = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
};

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

var extend$2 = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};

var isPlainObj = value => {
	if (Object.prototype.toString.call(value) !== '[object Object]') {
		return false;
	}

	const prototype = Object.getPrototypeOf(value);
	return prototype === null || prototype === Object.prototype;
};

var slice$3 = [].slice;

var wrap_1$1 = wrap$2;

// Wrap `fn`.
// Can be sync or async; return a promise, receive a completion handler, return
// new values and errors.
function wrap$2(fn, callback) {
  var invoked;

  return wrapped

  function wrapped() {
    var params = slice$3.call(arguments, 0);
    var callback = fn.length > params.length;
    var result;

    if (callback) {
      params.push(done);
    }

    try {
      result = fn.apply(null, params);
    } catch (error) {
      // Well, this is quite the pickle.
      // `fn` received a callback and invoked it (thus continuing the pipeline),
      // but later also threw an error.
      // We’re not about to restart the pipeline again, so the only thing left
      // to do is to throw the thing instead.
      if (callback && invoked) {
        throw error
      }

      return done(error)
    }

    if (!callback) {
      if (result && typeof result.then === 'function') {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }

  // Invoke `next`, only once.
  function done() {
    if (!invoked) {
      invoked = true;

      callback.apply(null, arguments);
    }
  }

  // Invoke `done` with one value.
  // Tracks if an error is passed, too.
  function then(value) {
    done(null, value);
  }
}

var trough_1 = trough;

trough.wrap = wrap_1$1;

var slice$2 = [].slice;

// Create new middleware.
function trough() {
  var fns = [];
  var middleware = {};

  middleware.run = run;
  middleware.use = use;

  return middleware

  // Run `fns`.  Last argument must be a completion handler.
  function run() {
    var index = -1;
    var input = slice$2.call(arguments, 0, -1);
    var done = arguments[arguments.length - 1];

    if (typeof done !== 'function') {
      throw new Error('Expected function as last argument, not ' + done)
    }

    next.apply(null, [null].concat(input));

    // Run the next `fn`, if any.
    function next(err) {
      var fn = fns[++index];
      var params = slice$2.call(arguments, 0);
      var values = params.slice(1);
      var length = input.length;
      var pos = -1;

      if (err) {
        done(err);
        return
      }

      // Copy non-nully input into values.
      while (++pos < length) {
        if (values[pos] === null || values[pos] === undefined) {
          values[pos] = input[pos];
        }
      }

      input = values;

      // Next or done.
      if (fn) {
        wrap_1$1(fn, next).apply(null, input);
      } else {
        done.apply(null, [null].concat(input));
      }
    }
  }

  // Add `fn` to the list.
  function use(fn) {
    if (typeof fn !== 'function') {
      throw new Error('Expected `fn` to be a function, not ' + fn)
    }

    fns.push(fn);

    return middleware
  }
}

var own$f = {}.hasOwnProperty;

var unistUtilStringifyPosition = stringify$4;

function stringify$4(value) {
  // Nothing.
  if (!value || typeof value !== 'object') {
    return ''
  }

  // Node.
  if (own$f.call(value, 'position') || own$f.call(value, 'type')) {
    return position$1(value.position)
  }

  // Position.
  if (own$f.call(value, 'start') || own$f.call(value, 'end')) {
    return position$1(value)
  }

  // Point.
  if (own$f.call(value, 'line') || own$f.call(value, 'column')) {
    return point(value)
  }

  // ?
  return ''
}

function point(point) {
  if (!point || typeof point !== 'object') {
    point = {};
  }

  return index$6(point.line) + ':' + index$6(point.column)
}

function position$1(pos) {
  if (!pos || typeof pos !== 'object') {
    pos = {};
  }

  return point(pos.start) + '-' + point(pos.end)
}

function index$6(value) {
  return value && typeof value === 'number' ? value : 1
}

var vfileMessage = VMessage;

// Inherit from `Error#`.
function VMessagePrototype() {}
VMessagePrototype.prototype = Error.prototype;
VMessage.prototype = new VMessagePrototype();

// Message properties.
var proto$6 = VMessage.prototype;

proto$6.file = '';
proto$6.name = '';
proto$6.reason = '';
proto$6.message = '';
proto$6.stack = '';
proto$6.fatal = null;
proto$6.column = null;
proto$6.line = null;

// Construct a new VMessage.
//
// Note: We cannot invoke `Error` on the created context, as that adds readonly
// `line` and `column` attributes on Safari 9, thus throwing and failing the
// data.
function VMessage(reason, position, origin) {
  var parts;
  var range;
  var location;

  if (typeof position === 'string') {
    origin = position;
    position = null;
  }

  parts = parseOrigin(origin);
  range = unistUtilStringifyPosition(position) || '1:1';

  location = {
    start: {line: null, column: null},
    end: {line: null, column: null}
  };

  // Node.
  if (position && position.position) {
    position = position.position;
  }

  if (position) {
    // Position.
    if (position.start) {
      location = position;
      position = position.start;
    } else {
      // Point.
      location.start = position;
    }
  }

  if (reason.stack) {
    this.stack = reason.stack;
    reason = reason.message;
  }

  this.message = reason;
  this.name = range;
  this.reason = reason;
  this.line = position ? position.line : null;
  this.column = position ? position.column : null;
  this.location = location;
  this.source = parts[0];
  this.ruleId = parts[1];
}

function parseOrigin(origin) {
  var result = [null, null];
  var index;

  if (typeof origin === 'string') {
    index = origin.indexOf(':');

    if (index === -1) {
      result[1] = origin;
    } else {
      result[0] = origin.slice(0, index);
      result[1] = origin.slice(index + 1);
    }
  }

  return result
}

function replaceExt(npath, ext) {
  if (typeof npath !== 'string') {
    return npath;
  }

  if (npath.length === 0) {
    return npath;
  }

  var nFileName = path__default__default.basename(npath, path__default__default.extname(npath)) + ext;
  return path__default__default.join(path__default__default.dirname(npath), nFileName);
}

var replaceExt_1 = replaceExt;

var core$1 = VFile;

var own$e = {}.hasOwnProperty;
var proto$5 = VFile.prototype;

// Order of setting (least specific to most), we need this because otherwise
// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a
// stem can be set.
var order$1 = ['history', 'path', 'basename', 'stem', 'extname', 'dirname'];

proto$5.toString = toString;

// Access full path (`~/index.min.js`).
Object.defineProperty(proto$5, 'path', {get: getPath, set: setPath});

// Access parent path (`~`).
Object.defineProperty(proto$5, 'dirname', {get: getDirname, set: setDirname});

// Access basename (`index.min.js`).
Object.defineProperty(proto$5, 'basename', {get: getBasename, set: setBasename});

// Access extname (`.js`).
Object.defineProperty(proto$5, 'extname', {get: getExtname, set: setExtname});

// Access stem (`index.min`).
Object.defineProperty(proto$5, 'stem', {get: getStem, set: setStem});

// Construct a new file.
function VFile(options) {
  var prop;
  var index;
  var length;

  if (!options) {
    options = {};
  } else if (typeof options === 'string' || isBuffer(options)) {
    options = {contents: options};
  } else if ('message' in options && 'messages' in options) {
    return options
  }

  if (!(this instanceof VFile)) {
    return new VFile(options)
  }

  this.data = {};
  this.messages = [];
  this.history = [];
  this.cwd = process.cwd();

  // Set path related properties in the correct order.
  index = -1;
  length = order$1.length;

  while (++index < length) {
    prop = order$1[index];

    if (own$e.call(options, prop)) {
      this[prop] = options[prop];
    }
  }

  // Set non-path related properties.
  for (prop in options) {
    if (order$1.indexOf(prop) === -1) {
      this[prop] = options[prop];
    }
  }
}

function getPath() {
  return this.history[this.history.length - 1]
}

function setPath(path) {
  assertNonEmpty(path, 'path');

  if (path !== this.path) {
    this.history.push(path);
  }
}

function getDirname() {
  return typeof this.path === 'string' ? path__default__default.dirname(this.path) : undefined
}

function setDirname(dirname) {
  assertPath(this.path, 'dirname');
  this.path = path__default__default.join(dirname || '', this.basename);
}

function getBasename() {
  return typeof this.path === 'string' ? path__default__default.basename(this.path) : undefined
}

function setBasename(basename) {
  assertNonEmpty(basename, 'basename');
  assertPart(basename, 'basename');
  this.path = path__default__default.join(this.dirname || '', basename);
}

function getExtname() {
  return typeof this.path === 'string' ? path__default__default.extname(this.path) : undefined
}

function setExtname(extname) {
  var ext = extname || '';

  assertPart(ext, 'extname');
  assertPath(this.path, 'extname');

  if (ext) {
    if (ext.charAt(0) !== '.') {
      throw new Error('`extname` must start with `.`')
    }

    if (ext.indexOf('.', 1) !== -1) {
      throw new Error('`extname` cannot contain multiple dots')
    }
  }

  this.path = replaceExt_1(this.path, ext);
}

function getStem() {
  return typeof this.path === 'string'
    ? path__default__default.basename(this.path, this.extname)
    : undefined
}

function setStem(stem) {
  assertNonEmpty(stem, 'stem');
  assertPart(stem, 'stem');
  this.path = path__default__default.join(this.dirname || '', stem + (this.extname || ''));
}

// Get the value of the file.
function toString(encoding) {
  var value = this.contents || '';
  return isBuffer(value) ? value.toString(encoding) : String(value)
}

// Assert that `part` is not a path (i.e., does not contain `path.sep`).
function assertPart(part, name) {
  if (part.indexOf(path__default__default.sep) !== -1) {
    throw new Error(
      '`' + name + '` cannot be a path: did not expect `' + path__default__default.sep + '`'
    )
  }
}

// Assert that `part` is not empty.
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error('`' + name + '` cannot be empty')
  }
}

// Assert `path` exists.
function assertPath(path, name) {
  if (!path) {
    throw new Error('Setting `' + name + '` requires `path` to be set too')
  }
}

var vfile = core$1;

var proto$4 = core$1.prototype;

proto$4.message = message;
proto$4.info = info$1;
proto$4.fail = fail;

// Create a message with `reason` at `position`.
// When an error is passed in as `reason`, copies the stack.
function message(reason, position, origin) {
  var filePath = this.path;
  var message = new vfileMessage(reason, position, origin);

  if (filePath) {
    message.name = filePath + ':' + message.name;
    message.file = filePath;
  }

  message.fatal = false;

  this.messages.push(message);

  return message
}

// Fail: creates a vmessage, associates it with the file, and throws it.
function fail() {
  var message = this.message.apply(this, arguments);

  message.fatal = true;

  throw message
}

// Info: creates a vmessage, associates it with the file, and marks the fatality
// as null.
function info$1() {
  var message = this.message.apply(this, arguments);

  message.fatal = null;

  return message
}

// Expose a frozen processor.
var unified_1$1 = unified$1().freeze();

var slice$1 = [].slice;
var own$d = {}.hasOwnProperty;

// Process pipeline.
var pipeline$1 = trough_1()
  .use(pipelineParse$1)
  .use(pipelineRun$1)
  .use(pipelineStringify$1);

function pipelineParse$1(p, ctx) {
  ctx.tree = p.parse(ctx.file);
}

function pipelineRun$1(p, ctx, next) {
  p.run(ctx.tree, ctx.file, done);

  function done(err, tree, file) {
    if (err) {
      next(err);
    } else {
      ctx.tree = tree;
      ctx.file = file;
      next();
    }
  }
}

function pipelineStringify$1(p, ctx) {
  var result = p.stringify(ctx.tree, ctx.file);
  var file = ctx.file;

  if (result === undefined || result === null) ; else if (typeof result === 'string' || isBuffer(result)) {
    file.contents = result;
  } else {
    file.result = result;
  }
}

// Function to create the first processor.
function unified$1() {
  var attachers = [];
  var transformers = trough_1();
  var namespace = {};
  var frozen = false;
  var freezeIndex = -1;

  // Data management.
  processor.data = data;

  // Lock.
  processor.freeze = freeze;

  // Plugins.
  processor.attachers = attachers;
  processor.use = use;

  // API.
  processor.parse = parse;
  processor.stringify = stringify;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process;
  processor.processSync = processSync;

  // Expose.
  return processor

  // Create a new processor based on the processor in the current scope.
  function processor() {
    var destination = unified$1();
    var length = attachers.length;
    var index = -1;

    while (++index < length) {
      destination.use.apply(null, attachers[index]);
    }

    destination.data(extend$2(true, {}, namespace));

    return destination
  }

  // Freeze: used to signal a processor that has finished configuration.
  //
  // For example, take unified itself: it’s frozen.
  // Plugins should not be added to it.
  // Rather, it should be extended, by invoking it, before modifying it.
  //
  // In essence, always invoke this when exporting a processor.
  function freeze() {
    var values;
    var plugin;
    var options;
    var transformer;

    if (frozen) {
      return processor
    }

    while (++freezeIndex < attachers.length) {
      values = attachers[freezeIndex];
      plugin = values[0];
      options = values[1];
      transformer = null;

      if (options === false) {
        continue
      }

      if (options === true) {
        values[1] = undefined;
      }

      transformer = plugin.apply(processor, values.slice(1));

      if (typeof transformer === 'function') {
        transformers.use(transformer);
      }
    }

    frozen = true;
    freezeIndex = Infinity;

    return processor
  }

  // Data management.
  // Getter / setter for processor-specific informtion.
  function data(key, value) {
    if (typeof key === 'string') {
      // Set `key`.
      if (arguments.length === 2) {
        assertUnfrozen$1('data', frozen);

        namespace[key] = value;

        return processor
      }

      // Get `key`.
      return (own$d.call(namespace, key) && namespace[key]) || null
    }

    // Set space.
    if (key) {
      assertUnfrozen$1('data', frozen);
      namespace = key;
      return processor
    }

    // Get space.
    return namespace
  }

  // Plugin management.
  //
  // Pass it:
  // *   an attacher and options,
  // *   a preset,
  // *   a list of presets, attachers, and arguments (list of attachers and
  //     options).
  function use(value) {
    var settings;

    assertUnfrozen$1('use', frozen);

    if (value === null || value === undefined) ; else if (typeof value === 'function') {
      addPlugin.apply(null, arguments);
    } else if (typeof value === 'object') {
      if ('length' in value) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new Error('Expected usable value, not `' + value + '`')
    }

    if (settings) {
      namespace.settings = extend$2(namespace.settings || {}, settings);
    }

    return processor

    function addPreset(result) {
      addList(result.plugins);

      if (result.settings) {
        settings = extend$2(settings || {}, result.settings);
      }
    }

    function add(value) {
      if (typeof value === 'function') {
        addPlugin(value);
      } else if (typeof value === 'object') {
        if ('length' in value) {
          addPlugin.apply(null, value);
        } else {
          addPreset(value);
        }
      } else {
        throw new Error('Expected usable value, not `' + value + '`')
      }
    }

    function addList(plugins) {
      var length;
      var index;

      if (plugins === null || plugins === undefined) ; else if (typeof plugins === 'object' && 'length' in plugins) {
        length = plugins.length;
        index = -1;

        while (++index < length) {
          add(plugins[index]);
        }
      } else {
        throw new Error('Expected a list of plugins, not `' + plugins + '`')
      }
    }

    function addPlugin(plugin, value) {
      var entry = find(plugin);

      if (entry) {
        if (isPlainObj(entry[1]) && isPlainObj(value)) {
          value = extend$2(entry[1], value);
        }

        entry[1] = value;
      } else {
        attachers.push(slice$1.call(arguments));
      }
    }
  }

  function find(plugin) {
    var length = attachers.length;
    var index = -1;
    var entry;

    while (++index < length) {
      entry = attachers[index];

      if (entry[0] === plugin) {
        return entry
      }
    }
  }

  // Parse a file (in string or vfile representation) into a unist node using
  // the `Parser` on the processor.
  function parse(doc) {
    var file = vfile(doc);
    var Parser;

    freeze();
    Parser = processor.Parser;
    assertParser$1('parse', Parser);

    if (newable$1(Parser, 'parse')) {
      return new Parser(String(file), file).parse()
    }

    return Parser(String(file), file) // eslint-disable-line new-cap
  }

  // Run transforms on a unist node representation of a file (in string or
  // vfile representation), async.
  function run(node, file, cb) {
    assertNode$1(node);
    freeze();

    if (!cb && typeof file === 'function') {
      cb = file;
      file = null;
    }

    if (!cb) {
      return new Promise(executor)
    }

    executor(null, cb);

    function executor(resolve, reject) {
      transformers.run(node, vfile(file), done);

      function done(err, tree, file) {
        tree = tree || node;
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(tree);
        } else {
          cb(null, tree, file);
        }
      }
    }
  }

  // Run transforms on a unist node representation of a file (in string or
  // vfile representation), sync.
  function runSync(node, file) {
    var complete = false;
    var result;

    run(node, file, done);

    assertDone$1('runSync', 'run', complete);

    return result

    function done(err, tree) {
      complete = true;
      bail_1(err);
      result = tree;
    }
  }

  // Stringify a unist node representation of a file (in string or vfile
  // representation) into a string using the `Compiler` on the processor.
  function stringify(node, doc) {
    var file = vfile(doc);
    var Compiler;

    freeze();
    Compiler = processor.Compiler;
    assertCompiler$1('stringify', Compiler);
    assertNode$1(node);

    if (newable$1(Compiler, 'compile')) {
      return new Compiler(node, file).compile()
    }

    return Compiler(node, file) // eslint-disable-line new-cap
  }

  // Parse a file (in string or vfile representation) into a unist node using
  // the `Parser` on the processor, then run transforms on that node, and
  // compile the resulting node using the `Compiler` on the processor, and
  // store that result on the vfile.
  function process(doc, cb) {
    freeze();
    assertParser$1('process', processor.Parser);
    assertCompiler$1('process', processor.Compiler);

    if (!cb) {
      return new Promise(executor)
    }

    executor(null, cb);

    function executor(resolve, reject) {
      var file = vfile(doc);

      pipeline$1.run(processor, {file: file}, done);

      function done(err) {
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(file);
        } else {
          cb(null, file);
        }
      }
    }
  }

  // Process the given document (in string or vfile representation), sync.
  function processSync(doc) {
    var complete = false;
    var file;

    freeze();
    assertParser$1('processSync', processor.Parser);
    assertCompiler$1('processSync', processor.Compiler);
    file = vfile(doc);

    process(file, done);

    assertDone$1('processSync', 'process', complete);

    return file

    function done(err) {
      complete = true;
      bail_1(err);
    }
  }
}

// Check if `value` is a constructor.
function newable$1(value, name) {
  return (
    typeof value === 'function' &&
    value.prototype &&
    // A function with keys in its prototype is probably a constructor.
    // Classes’ prototype methods are not enumerable, so we check if some value
    // exists in the prototype.
    (keys$2(value.prototype) || name in value.prototype)
  )
}

// Check if `value` is an object with keys.
function keys$2(value) {
  var key;
  for (key in value) {
    return true
  }

  return false
}

// Assert a parser is available.
function assertParser$1(name, Parser) {
  if (typeof Parser !== 'function') {
    throw new Error('Cannot `' + name + '` without `Parser`')
  }
}

// Assert a compiler is available.
function assertCompiler$1(name, Compiler) {
  if (typeof Compiler !== 'function') {
    throw new Error('Cannot `' + name + '` without `Compiler`')
  }
}

// Assert the processor is not frozen.
function assertUnfrozen$1(name, frozen) {
  if (frozen) {
    throw new Error(
      'Cannot invoke `' +
        name +
        '` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.'
    )
  }
}

// Assert `node` is a unist node.
function assertNode$1(node) {
  if (!node || typeof node.type !== 'string') {
    throw new Error('Expected node, got `' + node + '`')
  }
}

// Assert that `complete` is `true`.
function assertDone$1(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      '`' + name + '` finished async. Use `' + asyncName + '` instead'
    )
  }
}

var immutable = extend$1;

var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

function extend$1() {
    var target = {};

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
            if (hasOwnProperty$1.call(source, key)) {
                target[key] = source[key];
            }
        }
    }

    return target
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

var inherits_browser = createCommonjsModule(function (module) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
});

var inherits = createCommonjsModule(function (module) {
try {
  var util$1 = require$$0;
  /* istanbul ignore next */
  if (typeof util$1.inherits !== 'function') throw '';
  module.exports = util$1.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = inherits_browser;
}
});

var unherit_1 = unherit;

// Create a custom constructor which can be modified without affecting the
// original class.
function unherit(Super) {
  var result;
  var key;
  var value;

  inherits(Of, Super);
  inherits(From, Of);

  // Clone values.
  result = Of.prototype;

  for (key in result) {
    value = result[key];

    if (value && typeof value === 'object') {
      result[key] = 'concat' in value ? value.concat() : immutable(value);
    }
  }

  return Of

  // Constructor accepting a single argument, which itself is an `arguments`
  // object.
  function From(parameters) {
    return Super.apply(this, parameters)
  }

  // Constructor accepting variadic arguments.
  function Of() {
    if (!(this instanceof Of)) {
      return new From(arguments)
    }

    return Super.apply(this, arguments)
  }
}

var stateToggle = factory$6;

// Construct a state `toggler`: a function which inverses `property` in context
// based on its current value.
// The by `toggler` returned function restores that value.
function factory$6(key, state, ctx) {
  return enter

  function enter() {
    var context = ctx || this;
    var current = context[key];

    context[key] = !state;

    return exit

    function exit() {
      context[key] = current;
    }
  }
}

var vfileLocation = factory$5;

function factory$5(file) {
  var contents = indices(String(file));

  return {
    toPosition: offsetToPositionFactory(contents),
    toOffset: positionToOffsetFactory(contents)
  }
}

// Factory to get the line and column-based `position` for `offset` in the bound
// indices.
function offsetToPositionFactory(indices) {
  return offsetToPosition

  // Get the line and column-based `position` for `offset` in the bound indices.
  function offsetToPosition(offset) {
    var index = -1;
    var length = indices.length;

    if (offset < 0) {
      return {}
    }

    while (++index < length) {
      if (indices[index] > offset) {
        return {
          line: index + 1,
          column: offset - (indices[index - 1] || 0) + 1,
          offset: offset
        }
      }
    }

    return {}
  }
}

// Factory to get the `offset` for a line and column-based `position` in the
// bound indices.
function positionToOffsetFactory(indices) {
  return positionToOffset

  // Get the `offset` for a line and column-based `position` in the bound
  // indices.
  function positionToOffset(position) {
    var line = position && position.line;
    var column = position && position.column;

    if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {
      return (indices[line - 2] || 0) + column - 1 || 0
    }

    return -1
  }
}

// Get indices of line-breaks in `value`.
function indices(value) {
  var result = [];
  var index = value.indexOf('\n');

  while (index !== -1) {
    result.push(index + 1);
    index = value.indexOf('\n', index + 1);
  }

  result.push(value.length + 1);

  return result
}

var _unescape = factory$4;

var backslash$7 = '\\';

// Factory to de-escape a value, based on a list at `key` in `ctx`.
function factory$4(ctx, key) {
  return unescape

  // De-escape a string using the expression at `key` in `ctx`.
  function unescape(value) {
    var previous = 0;
    var index = value.indexOf(backslash$7);
    var escape = ctx[key];
    var queue = [];
    var character;

    while (index !== -1) {
      queue.push(value.slice(previous, index));
      previous = index + 1;
      character = value.charAt(previous);

      // If the following character is not a valid escape, add the slash.
      if (!character || escape.indexOf(character) === -1) {
        queue.push(backslash$7);
      }

      index = value.indexOf(backslash$7, previous + 1);
    }

    queue.push(value.slice(previous));

    return queue.join('')
  }
}

var AElig$2 = "Æ";
var AMP$2 = "&";
var Aacute$2 = "Á";
var Acirc$2 = "Â";
var Agrave$2 = "À";
var Aring$2 = "Å";
var Atilde$2 = "Ã";
var Auml$2 = "Ä";
var COPY$1 = "©";
var Ccedil$2 = "Ç";
var ETH$2 = "Ð";
var Eacute$2 = "É";
var Ecirc$2 = "Ê";
var Egrave$2 = "È";
var Euml$2 = "Ë";
var GT$2 = ">";
var Iacute$2 = "Í";
var Icirc$2 = "Î";
var Igrave$2 = "Ì";
var Iuml$2 = "Ï";
var LT$2 = "<";
var Ntilde$2 = "Ñ";
var Oacute$2 = "Ó";
var Ocirc$2 = "Ô";
var Ograve$2 = "Ò";
var Oslash$2 = "Ø";
var Otilde$2 = "Õ";
var Ouml$2 = "Ö";
var QUOT$1 = "\"";
var REG$1 = "®";
var THORN$2 = "Þ";
var Uacute$2 = "Ú";
var Ucirc$2 = "Û";
var Ugrave$2 = "Ù";
var Uuml$2 = "Ü";
var Yacute$2 = "Ý";
var aacute$2 = "á";
var acirc$2 = "â";
var acute$2 = "´";
var aelig$2 = "æ";
var agrave$2 = "à";
var amp$2 = "&";
var aring$2 = "å";
var atilde$2 = "ã";
var auml$2 = "ä";
var brvbar$2 = "¦";
var ccedil$2 = "ç";
var cedil$2 = "¸";
var cent$2 = "¢";
var copy$2 = "©";
var curren$2 = "¤";
var deg$2 = "°";
var divide$2 = "÷";
var eacute$2 = "é";
var ecirc$2 = "ê";
var egrave$2 = "è";
var eth$2 = "ð";
var euml$2 = "ë";
var frac12$2 = "½";
var frac14$2 = "¼";
var frac34$2 = "¾";
var gt$2 = ">";
var iacute$2 = "í";
var icirc$2 = "î";
var iexcl$2 = "¡";
var igrave$2 = "ì";
var iquest$2 = "¿";
var iuml$2 = "ï";
var laquo$2 = "«";
var lt$2 = "<";
var macr$2 = "¯";
var micro$2 = "µ";
var middot$2 = "·";
var nbsp$2 = " ";
var not$2 = "¬";
var ntilde$2 = "ñ";
var oacute$2 = "ó";
var ocirc$2 = "ô";
var ograve$2 = "ò";
var ordf$2 = "ª";
var ordm$2 = "º";
var oslash$2 = "ø";
var otilde$2 = "õ";
var ouml$2 = "ö";
var para$2 = "¶";
var plusmn$2 = "±";
var pound$2 = "£";
var quot$2 = "\"";
var raquo$2 = "»";
var reg$2 = "®";
var sect$2 = "§";
var shy$2 = "­";
var sup1$2 = "¹";
var sup2$2 = "²";
var sup3$2 = "³";
var szlig$2 = "ß";
var thorn$2 = "þ";
var times$2 = "×";
var uacute$2 = "ú";
var ucirc$2 = "û";
var ugrave$2 = "ù";
var uml$2 = "¨";
var uuml$2 = "ü";
var yacute$2 = "ý";
var yen$2 = "¥";
var yuml$2 = "ÿ";
var index$5 = {
	AElig: AElig$2,
	AMP: AMP$2,
	Aacute: Aacute$2,
	Acirc: Acirc$2,
	Agrave: Agrave$2,
	Aring: Aring$2,
	Atilde: Atilde$2,
	Auml: Auml$2,
	COPY: COPY$1,
	Ccedil: Ccedil$2,
	ETH: ETH$2,
	Eacute: Eacute$2,
	Ecirc: Ecirc$2,
	Egrave: Egrave$2,
	Euml: Euml$2,
	GT: GT$2,
	Iacute: Iacute$2,
	Icirc: Icirc$2,
	Igrave: Igrave$2,
	Iuml: Iuml$2,
	LT: LT$2,
	Ntilde: Ntilde$2,
	Oacute: Oacute$2,
	Ocirc: Ocirc$2,
	Ograve: Ograve$2,
	Oslash: Oslash$2,
	Otilde: Otilde$2,
	Ouml: Ouml$2,
	QUOT: QUOT$1,
	REG: REG$1,
	THORN: THORN$2,
	Uacute: Uacute$2,
	Ucirc: Ucirc$2,
	Ugrave: Ugrave$2,
	Uuml: Uuml$2,
	Yacute: Yacute$2,
	aacute: aacute$2,
	acirc: acirc$2,
	acute: acute$2,
	aelig: aelig$2,
	agrave: agrave$2,
	amp: amp$2,
	aring: aring$2,
	atilde: atilde$2,
	auml: auml$2,
	brvbar: brvbar$2,
	ccedil: ccedil$2,
	cedil: cedil$2,
	cent: cent$2,
	copy: copy$2,
	curren: curren$2,
	deg: deg$2,
	divide: divide$2,
	eacute: eacute$2,
	ecirc: ecirc$2,
	egrave: egrave$2,
	eth: eth$2,
	euml: euml$2,
	frac12: frac12$2,
	frac14: frac14$2,
	frac34: frac34$2,
	gt: gt$2,
	iacute: iacute$2,
	icirc: icirc$2,
	iexcl: iexcl$2,
	igrave: igrave$2,
	iquest: iquest$2,
	iuml: iuml$2,
	laquo: laquo$2,
	lt: lt$2,
	macr: macr$2,
	micro: micro$2,
	middot: middot$2,
	nbsp: nbsp$2,
	not: not$2,
	ntilde: ntilde$2,
	oacute: oacute$2,
	ocirc: ocirc$2,
	ograve: ograve$2,
	ordf: ordf$2,
	ordm: ordm$2,
	oslash: oslash$2,
	otilde: otilde$2,
	ouml: ouml$2,
	para: para$2,
	plusmn: plusmn$2,
	pound: pound$2,
	quot: quot$2,
	raquo: raquo$2,
	reg: reg$2,
	sect: sect$2,
	shy: shy$2,
	sup1: sup1$2,
	sup2: sup2$2,
	sup3: sup3$2,
	szlig: szlig$2,
	thorn: thorn$2,
	times: times$2,
	uacute: uacute$2,
	ucirc: ucirc$2,
	ugrave: ugrave$2,
	uml: uml$2,
	uuml: uuml$2,
	yacute: yacute$2,
	yen: yen$2,
	yuml: yuml$2
};

var characterEntitiesLegacy = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AElig: AElig$2,
  AMP: AMP$2,
  Aacute: Aacute$2,
  Acirc: Acirc$2,
  Agrave: Agrave$2,
  Aring: Aring$2,
  Atilde: Atilde$2,
  Auml: Auml$2,
  COPY: COPY$1,
  Ccedil: Ccedil$2,
  ETH: ETH$2,
  Eacute: Eacute$2,
  Ecirc: Ecirc$2,
  Egrave: Egrave$2,
  Euml: Euml$2,
  GT: GT$2,
  Iacute: Iacute$2,
  Icirc: Icirc$2,
  Igrave: Igrave$2,
  Iuml: Iuml$2,
  LT: LT$2,
  Ntilde: Ntilde$2,
  Oacute: Oacute$2,
  Ocirc: Ocirc$2,
  Ograve: Ograve$2,
  Oslash: Oslash$2,
  Otilde: Otilde$2,
  Ouml: Ouml$2,
  QUOT: QUOT$1,
  REG: REG$1,
  THORN: THORN$2,
  Uacute: Uacute$2,
  Ucirc: Ucirc$2,
  Ugrave: Ugrave$2,
  Uuml: Uuml$2,
  Yacute: Yacute$2,
  aacute: aacute$2,
  acirc: acirc$2,
  acute: acute$2,
  aelig: aelig$2,
  agrave: agrave$2,
  amp: amp$2,
  aring: aring$2,
  atilde: atilde$2,
  auml: auml$2,
  brvbar: brvbar$2,
  ccedil: ccedil$2,
  cedil: cedil$2,
  cent: cent$2,
  copy: copy$2,
  curren: curren$2,
  deg: deg$2,
  divide: divide$2,
  eacute: eacute$2,
  ecirc: ecirc$2,
  egrave: egrave$2,
  eth: eth$2,
  euml: euml$2,
  frac12: frac12$2,
  frac14: frac14$2,
  frac34: frac34$2,
  gt: gt$2,
  iacute: iacute$2,
  icirc: icirc$2,
  iexcl: iexcl$2,
  igrave: igrave$2,
  iquest: iquest$2,
  iuml: iuml$2,
  laquo: laquo$2,
  lt: lt$2,
  macr: macr$2,
  micro: micro$2,
  middot: middot$2,
  nbsp: nbsp$2,
  not: not$2,
  ntilde: ntilde$2,
  oacute: oacute$2,
  ocirc: ocirc$2,
  ograve: ograve$2,
  ordf: ordf$2,
  ordm: ordm$2,
  oslash: oslash$2,
  otilde: otilde$2,
  ouml: ouml$2,
  para: para$2,
  plusmn: plusmn$2,
  pound: pound$2,
  quot: quot$2,
  raquo: raquo$2,
  reg: reg$2,
  sect: sect$2,
  shy: shy$2,
  sup1: sup1$2,
  sup2: sup2$2,
  sup3: sup3$2,
  szlig: szlig$2,
  thorn: thorn$2,
  times: times$2,
  uacute: uacute$2,
  ucirc: ucirc$2,
  ugrave: ugrave$2,
  uml: uml$2,
  uuml: uuml$2,
  yacute: yacute$2,
  yen: yen$2,
  yuml: yuml$2,
  'default': index$5
});

var index$4 = {
	"0": "�",
	"128": "€",
	"130": "‚",
	"131": "ƒ",
	"132": "„",
	"133": "…",
	"134": "†",
	"135": "‡",
	"136": "ˆ",
	"137": "‰",
	"138": "Š",
	"139": "‹",
	"140": "Œ",
	"142": "Ž",
	"145": "‘",
	"146": "’",
	"147": "“",
	"148": "”",
	"149": "•",
	"150": "–",
	"151": "—",
	"152": "˜",
	"153": "™",
	"154": "š",
	"155": "›",
	"156": "œ",
	"158": "ž",
	"159": "Ÿ"
};

var characterReferenceInvalid = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': index$4
});

var isDecimal = decimal$1;

// Check if the given character code, or the character code at the first
// character, is decimal.
function decimal$1(character) {
  var code = typeof character === 'string' ? character.charCodeAt(0) : character;

  return code >= 48 && code <= 57 /* 0-9 */
}

var isHexadecimal = hexadecimal;

// Check if the given character code, or the character code at the first
// character, is hexadecimal.
function hexadecimal(character) {
  var code = typeof character === 'string' ? character.charCodeAt(0) : character;

  return (
    (code >= 97 /* a */ && code <= 102) /* z */ ||
    (code >= 65 /* A */ && code <= 70) /* Z */ ||
    (code >= 48 /* A */ && code <= 57) /* Z */
  )
}

var isAlphabetical = alphabetical;

// Check if the given character code, or the character code at the first
// character, is alphabetical.
function alphabetical(character) {
  var code = typeof character === 'string' ? character.charCodeAt(0) : character;

  return (
    (code >= 97 && code <= 122) /* a-z */ ||
    (code >= 65 && code <= 90) /* A-Z */
  )
}

var isAlphanumerical = alphanumerical;

// Check if the given character code, or the character code at the first
// character, is alphanumerical.
function alphanumerical(character) {
  return isAlphabetical(character) || isDecimal(character)
}

var AEli = "Æ";
var AElig$1 = "Æ";
var AM = "&";
var AMP$1 = "&";
var Aacut = "Á";
var Aacute$1 = "Á";
var Abreve = "Ă";
var Acir = "Â";
var Acirc$1 = "Â";
var Acy = "А";
var Afr = "𝔄";
var Agrav = "À";
var Agrave$1 = "À";
var Alpha$1 = "Α";
var Amacr = "Ā";
var And = "⩓";
var Aogon = "Ą";
var Aopf = "𝔸";
var ApplyFunction = "⁡";
var Arin = "Å";
var Aring$1 = "Å";
var Ascr = "𝒜";
var Assign = "≔";
var Atild = "Ã";
var Atilde$1 = "Ã";
var Aum = "Ä";
var Auml$1 = "Ä";
var Backslash = "∖";
var Barv = "⫧";
var Barwed = "⌆";
var Bcy = "Б";
var Because = "∵";
var Bernoullis = "ℬ";
var Beta$1 = "Β";
var Bfr = "𝔅";
var Bopf = "𝔹";
var Breve = "˘";
var Bscr = "ℬ";
var Bumpeq = "≎";
var CHcy = "Ч";
var COP = "©";
var COPY = "©";
var Cacute = "Ć";
var Cap = "⋒";
var CapitalDifferentialD = "ⅅ";
var Cayleys = "ℭ";
var Ccaron = "Č";
var Ccedi = "Ç";
var Ccedil$1 = "Ç";
var Ccirc = "Ĉ";
var Cconint = "∰";
var Cdot = "Ċ";
var Cedilla = "¸";
var CenterDot = "·";
var Cfr = "ℭ";
var Chi$1 = "Χ";
var CircleDot = "⊙";
var CircleMinus = "⊖";
var CirclePlus = "⊕";
var CircleTimes = "⊗";
var ClockwiseContourIntegral = "∲";
var CloseCurlyDoubleQuote = "”";
var CloseCurlyQuote = "’";
var Colon = "∷";
var Colone = "⩴";
var Congruent = "≡";
var Conint = "∯";
var ContourIntegral = "∮";
var Copf = "ℂ";
var Coproduct = "∐";
var CounterClockwiseContourIntegral = "∳";
var Cross = "⨯";
var Cscr = "𝒞";
var Cup = "⋓";
var CupCap = "≍";
var DD = "ⅅ";
var DDotrahd = "⤑";
var DJcy = "Ђ";
var DScy = "Ѕ";
var DZcy = "Џ";
var Dagger$1 = "‡";
var Darr = "↡";
var Dashv = "⫤";
var Dcaron = "Ď";
var Dcy = "Д";
var Del = "∇";
var Delta$1 = "Δ";
var Dfr = "𝔇";
var DiacriticalAcute = "´";
var DiacriticalDot = "˙";
var DiacriticalDoubleAcute = "˝";
var DiacriticalGrave = "`";
var DiacriticalTilde = "˜";
var Diamond = "⋄";
var DifferentialD = "ⅆ";
var Dopf = "𝔻";
var Dot = "¨";
var DotDot = "⃜";
var DotEqual = "≐";
var DoubleContourIntegral = "∯";
var DoubleDot = "¨";
var DoubleDownArrow = "⇓";
var DoubleLeftArrow = "⇐";
var DoubleLeftRightArrow = "⇔";
var DoubleLeftTee = "⫤";
var DoubleLongLeftArrow = "⟸";
var DoubleLongLeftRightArrow = "⟺";
var DoubleLongRightArrow = "⟹";
var DoubleRightArrow = "⇒";
var DoubleRightTee = "⊨";
var DoubleUpArrow = "⇑";
var DoubleUpDownArrow = "⇕";
var DoubleVerticalBar = "∥";
var DownArrow = "↓";
var DownArrowBar = "⤓";
var DownArrowUpArrow = "⇵";
var DownBreve = "̑";
var DownLeftRightVector = "⥐";
var DownLeftTeeVector = "⥞";
var DownLeftVector = "↽";
var DownLeftVectorBar = "⥖";
var DownRightTeeVector = "⥟";
var DownRightVector = "⇁";
var DownRightVectorBar = "⥗";
var DownTee = "⊤";
var DownTeeArrow = "↧";
var Downarrow = "⇓";
var Dscr = "𝒟";
var Dstrok = "Đ";
var ENG = "Ŋ";
var ET = "Ð";
var ETH$1 = "Ð";
var Eacut = "É";
var Eacute$1 = "É";
var Ecaron = "Ě";
var Ecir = "Ê";
var Ecirc$1 = "Ê";
var Ecy = "Э";
var Edot = "Ė";
var Efr = "𝔈";
var Egrav = "È";
var Egrave$1 = "È";
var Element = "∈";
var Emacr = "Ē";
var EmptySmallSquare = "◻";
var EmptyVerySmallSquare = "▫";
var Eogon = "Ę";
var Eopf = "𝔼";
var Epsilon$1 = "Ε";
var Equal = "⩵";
var EqualTilde = "≂";
var Equilibrium = "⇌";
var Escr = "ℰ";
var Esim = "⩳";
var Eta$1 = "Η";
var Eum = "Ë";
var Euml$1 = "Ë";
var Exists = "∃";
var ExponentialE = "ⅇ";
var Fcy = "Ф";
var Ffr = "𝔉";
var FilledSmallSquare = "◼";
var FilledVerySmallSquare = "▪";
var Fopf = "𝔽";
var ForAll = "∀";
var Fouriertrf = "ℱ";
var Fscr = "ℱ";
var GJcy = "Ѓ";
var G = ">";
var GT$1 = ">";
var Gamma$1 = "Γ";
var Gammad = "Ϝ";
var Gbreve = "Ğ";
var Gcedil = "Ģ";
var Gcirc = "Ĝ";
var Gcy = "Г";
var Gdot = "Ġ";
var Gfr = "𝔊";
var Gg = "⋙";
var Gopf = "𝔾";
var GreaterEqual = "≥";
var GreaterEqualLess = "⋛";
var GreaterFullEqual = "≧";
var GreaterGreater = "⪢";
var GreaterLess = "≷";
var GreaterSlantEqual = "⩾";
var GreaterTilde = "≳";
var Gscr = "𝒢";
var Gt = "≫";
var HARDcy = "Ъ";
var Hacek = "ˇ";
var Hat = "^";
var Hcirc = "Ĥ";
var Hfr = "ℌ";
var HilbertSpace = "ℋ";
var Hopf = "ℍ";
var HorizontalLine = "─";
var Hscr = "ℋ";
var Hstrok = "Ħ";
var HumpDownHump = "≎";
var HumpEqual = "≏";
var IEcy = "Е";
var IJlig = "Ĳ";
var IOcy = "Ё";
var Iacut = "Í";
var Iacute$1 = "Í";
var Icir = "Î";
var Icirc$1 = "Î";
var Icy = "И";
var Idot = "İ";
var Ifr = "ℑ";
var Igrav = "Ì";
var Igrave$1 = "Ì";
var Im = "ℑ";
var Imacr = "Ī";
var ImaginaryI = "ⅈ";
var Implies = "⇒";
var Int = "∬";
var Integral = "∫";
var Intersection = "⋂";
var InvisibleComma = "⁣";
var InvisibleTimes = "⁢";
var Iogon = "Į";
var Iopf = "𝕀";
var Iota$1 = "Ι";
var Iscr = "ℐ";
var Itilde = "Ĩ";
var Iukcy = "І";
var Ium = "Ï";
var Iuml$1 = "Ï";
var Jcirc = "Ĵ";
var Jcy = "Й";
var Jfr = "𝔍";
var Jopf = "𝕁";
var Jscr = "𝒥";
var Jsercy = "Ј";
var Jukcy = "Є";
var KHcy = "Х";
var KJcy = "Ќ";
var Kappa$1 = "Κ";
var Kcedil = "Ķ";
var Kcy = "К";
var Kfr = "𝔎";
var Kopf = "𝕂";
var Kscr = "𝒦";
var LJcy = "Љ";
var L = "<";
var LT$1 = "<";
var Lacute = "Ĺ";
var Lambda$1 = "Λ";
var Lang = "⟪";
var Laplacetrf = "ℒ";
var Larr = "↞";
var Lcaron = "Ľ";
var Lcedil = "Ļ";
var Lcy = "Л";
var LeftAngleBracket = "⟨";
var LeftArrow = "←";
var LeftArrowBar = "⇤";
var LeftArrowRightArrow = "⇆";
var LeftCeiling = "⌈";
var LeftDoubleBracket = "⟦";
var LeftDownTeeVector = "⥡";
var LeftDownVector = "⇃";
var LeftDownVectorBar = "⥙";
var LeftFloor = "⌊";
var LeftRightArrow = "↔";
var LeftRightVector = "⥎";
var LeftTee = "⊣";
var LeftTeeArrow = "↤";
var LeftTeeVector = "⥚";
var LeftTriangle = "⊲";
var LeftTriangleBar = "⧏";
var LeftTriangleEqual = "⊴";
var LeftUpDownVector = "⥑";
var LeftUpTeeVector = "⥠";
var LeftUpVector = "↿";
var LeftUpVectorBar = "⥘";
var LeftVector = "↼";
var LeftVectorBar = "⥒";
var Leftarrow = "⇐";
var Leftrightarrow = "⇔";
var LessEqualGreater = "⋚";
var LessFullEqual = "≦";
var LessGreater = "≶";
var LessLess = "⪡";
var LessSlantEqual = "⩽";
var LessTilde = "≲";
var Lfr = "𝔏";
var Ll = "⋘";
var Lleftarrow = "⇚";
var Lmidot = "Ŀ";
var LongLeftArrow = "⟵";
var LongLeftRightArrow = "⟷";
var LongRightArrow = "⟶";
var Longleftarrow = "⟸";
var Longleftrightarrow = "⟺";
var Longrightarrow = "⟹";
var Lopf = "𝕃";
var LowerLeftArrow = "↙";
var LowerRightArrow = "↘";
var Lscr = "ℒ";
var Lsh = "↰";
var Lstrok = "Ł";
var Lt = "≪";
var Mcy = "М";
var MediumSpace = " ";
var Mellintrf = "ℳ";
var Mfr = "𝔐";
var MinusPlus = "∓";
var Mopf = "𝕄";
var Mscr = "ℳ";
var Mu$1 = "Μ";
var NJcy = "Њ";
var Nacute = "Ń";
var Ncaron = "Ň";
var Ncedil = "Ņ";
var Ncy = "Н";
var NegativeMediumSpace = "​";
var NegativeThickSpace = "​";
var NegativeThinSpace = "​";
var NegativeVeryThinSpace = "​";
var NestedGreaterGreater = "≫";
var NestedLessLess = "≪";
var NewLine = "\n";
var Nfr = "𝔑";
var NoBreak = "⁠";
var NonBreakingSpace = " ";
var Nopf = "ℕ";
var Not = "⫬";
var NotCongruent = "≢";
var NotCupCap = "≭";
var NotDoubleVerticalBar = "∦";
var NotElement = "∉";
var NotEqual = "≠";
var NotEqualTilde = "≂̸";
var NotExists = "∄";
var NotGreater = "≯";
var NotGreaterEqual = "≱";
var NotGreaterFullEqual = "≧̸";
var NotGreaterGreater = "≫̸";
var NotGreaterLess = "≹";
var NotGreaterSlantEqual = "⩾̸";
var NotGreaterTilde = "≵";
var NotHumpDownHump = "≎̸";
var NotHumpEqual = "≏̸";
var NotLeftTriangle = "⋪";
var NotLeftTriangleBar = "⧏̸";
var NotLeftTriangleEqual = "⋬";
var NotLess = "≮";
var NotLessEqual = "≰";
var NotLessGreater = "≸";
var NotLessLess = "≪̸";
var NotLessSlantEqual = "⩽̸";
var NotLessTilde = "≴";
var NotNestedGreaterGreater = "⪢̸";
var NotNestedLessLess = "⪡̸";
var NotPrecedes = "⊀";
var NotPrecedesEqual = "⪯̸";
var NotPrecedesSlantEqual = "⋠";
var NotReverseElement = "∌";
var NotRightTriangle = "⋫";
var NotRightTriangleBar = "⧐̸";
var NotRightTriangleEqual = "⋭";
var NotSquareSubset = "⊏̸";
var NotSquareSubsetEqual = "⋢";
var NotSquareSuperset = "⊐̸";
var NotSquareSupersetEqual = "⋣";
var NotSubset = "⊂⃒";
var NotSubsetEqual = "⊈";
var NotSucceeds = "⊁";
var NotSucceedsEqual = "⪰̸";
var NotSucceedsSlantEqual = "⋡";
var NotSucceedsTilde = "≿̸";
var NotSuperset = "⊃⃒";
var NotSupersetEqual = "⊉";
var NotTilde = "≁";
var NotTildeEqual = "≄";
var NotTildeFullEqual = "≇";
var NotTildeTilde = "≉";
var NotVerticalBar = "∤";
var Nscr = "𝒩";
var Ntild = "Ñ";
var Ntilde$1 = "Ñ";
var Nu$1 = "Ν";
var OElig$1 = "Œ";
var Oacut = "Ó";
var Oacute$1 = "Ó";
var Ocir = "Ô";
var Ocirc$1 = "Ô";
var Ocy = "О";
var Odblac = "Ő";
var Ofr = "𝔒";
var Ograv = "Ò";
var Ograve$1 = "Ò";
var Omacr = "Ō";
var Omega$1 = "Ω";
var Omicron$1 = "Ο";
var Oopf = "𝕆";
var OpenCurlyDoubleQuote = "“";
var OpenCurlyQuote = "‘";
var Or = "⩔";
var Oscr = "𝒪";
var Oslas = "Ø";
var Oslash$1 = "Ø";
var Otild = "Õ";
var Otilde$1 = "Õ";
var Otimes = "⨷";
var Oum = "Ö";
var Ouml$1 = "Ö";
var OverBar = "‾";
var OverBrace = "⏞";
var OverBracket = "⎴";
var OverParenthesis = "⏜";
var PartialD = "∂";
var Pcy = "П";
var Pfr = "𝔓";
var Phi$1 = "Φ";
var Pi$1 = "Π";
var PlusMinus = "±";
var Poincareplane = "ℌ";
var Popf = "ℙ";
var Pr = "⪻";
var Precedes = "≺";
var PrecedesEqual = "⪯";
var PrecedesSlantEqual = "≼";
var PrecedesTilde = "≾";
var Prime$1 = "″";
var Product = "∏";
var Proportion = "∷";
var Proportional = "∝";
var Pscr = "𝒫";
var Psi$1 = "Ψ";
var QUO = "\"";
var QUOT = "\"";
var Qfr = "𝔔";
var Qopf = "ℚ";
var Qscr = "𝒬";
var RBarr = "⤐";
var RE = "®";
var REG = "®";
var Racute = "Ŕ";
var Rang = "⟫";
var Rarr = "↠";
var Rarrtl = "⤖";
var Rcaron = "Ř";
var Rcedil = "Ŗ";
var Rcy = "Р";
var Re = "ℜ";
var ReverseElement = "∋";
var ReverseEquilibrium = "⇋";
var ReverseUpEquilibrium = "⥯";
var Rfr = "ℜ";
var Rho$1 = "Ρ";
var RightAngleBracket = "⟩";
var RightArrow = "→";
var RightArrowBar = "⇥";
var RightArrowLeftArrow = "⇄";
var RightCeiling = "⌉";
var RightDoubleBracket = "⟧";
var RightDownTeeVector = "⥝";
var RightDownVector = "⇂";
var RightDownVectorBar = "⥕";
var RightFloor = "⌋";
var RightTee = "⊢";
var RightTeeArrow = "↦";
var RightTeeVector = "⥛";
var RightTriangle = "⊳";
var RightTriangleBar = "⧐";
var RightTriangleEqual = "⊵";
var RightUpDownVector = "⥏";
var RightUpTeeVector = "⥜";
var RightUpVector = "↾";
var RightUpVectorBar = "⥔";
var RightVector = "⇀";
var RightVectorBar = "⥓";
var Rightarrow = "⇒";
var Ropf = "ℝ";
var RoundImplies = "⥰";
var Rrightarrow = "⇛";
var Rscr = "ℛ";
var Rsh = "↱";
var RuleDelayed = "⧴";
var SHCHcy = "Щ";
var SHcy = "Ш";
var SOFTcy = "Ь";
var Sacute = "Ś";
var Sc = "⪼";
var Scaron$1 = "Š";
var Scedil = "Ş";
var Scirc = "Ŝ";
var Scy = "С";
var Sfr = "𝔖";
var ShortDownArrow = "↓";
var ShortLeftArrow = "←";
var ShortRightArrow = "→";
var ShortUpArrow = "↑";
var Sigma$1 = "Σ";
var SmallCircle = "∘";
var Sopf = "𝕊";
var Sqrt = "√";
var Square = "□";
var SquareIntersection = "⊓";
var SquareSubset = "⊏";
var SquareSubsetEqual = "⊑";
var SquareSuperset = "⊐";
var SquareSupersetEqual = "⊒";
var SquareUnion = "⊔";
var Sscr = "𝒮";
var Star = "⋆";
var Sub = "⋐";
var Subset = "⋐";
var SubsetEqual = "⊆";
var Succeeds = "≻";
var SucceedsEqual = "⪰";
var SucceedsSlantEqual = "≽";
var SucceedsTilde = "≿";
var SuchThat = "∋";
var Sum = "∑";
var Sup = "⋑";
var Superset = "⊃";
var SupersetEqual = "⊇";
var Supset = "⋑";
var THOR = "Þ";
var THORN$1 = "Þ";
var TRADE = "™";
var TSHcy = "Ћ";
var TScy = "Ц";
var Tab = "\t";
var Tau$1 = "Τ";
var Tcaron = "Ť";
var Tcedil = "Ţ";
var Tcy = "Т";
var Tfr = "𝔗";
var Therefore = "∴";
var Theta$1 = "Θ";
var ThickSpace = "  ";
var ThinSpace = " ";
var Tilde = "∼";
var TildeEqual = "≃";
var TildeFullEqual = "≅";
var TildeTilde = "≈";
var Topf = "𝕋";
var TripleDot = "⃛";
var Tscr = "𝒯";
var Tstrok = "Ŧ";
var Uacut = "Ú";
var Uacute$1 = "Ú";
var Uarr = "↟";
var Uarrocir = "⥉";
var Ubrcy = "Ў";
var Ubreve = "Ŭ";
var Ucir = "Û";
var Ucirc$1 = "Û";
var Ucy = "У";
var Udblac = "Ű";
var Ufr = "𝔘";
var Ugrav = "Ù";
var Ugrave$1 = "Ù";
var Umacr = "Ū";
var UnderBar = "_";
var UnderBrace = "⏟";
var UnderBracket = "⎵";
var UnderParenthesis = "⏝";
var Union = "⋃";
var UnionPlus = "⊎";
var Uogon = "Ų";
var Uopf = "𝕌";
var UpArrow = "↑";
var UpArrowBar = "⤒";
var UpArrowDownArrow = "⇅";
var UpDownArrow = "↕";
var UpEquilibrium = "⥮";
var UpTee = "⊥";
var UpTeeArrow = "↥";
var Uparrow = "⇑";
var Updownarrow = "⇕";
var UpperLeftArrow = "↖";
var UpperRightArrow = "↗";
var Upsi = "ϒ";
var Upsilon$1 = "Υ";
var Uring = "Ů";
var Uscr = "𝒰";
var Utilde = "Ũ";
var Uum = "Ü";
var Uuml$1 = "Ü";
var VDash = "⊫";
var Vbar = "⫫";
var Vcy = "В";
var Vdash = "⊩";
var Vdashl = "⫦";
var Vee = "⋁";
var Verbar = "‖";
var Vert = "‖";
var VerticalBar = "∣";
var VerticalLine = "|";
var VerticalSeparator = "❘";
var VerticalTilde = "≀";
var VeryThinSpace = " ";
var Vfr = "𝔙";
var Vopf = "𝕍";
var Vscr = "𝒱";
var Vvdash = "⊪";
var Wcirc = "Ŵ";
var Wedge = "⋀";
var Wfr = "𝔚";
var Wopf = "𝕎";
var Wscr = "𝒲";
var Xfr = "𝔛";
var Xi$1 = "Ξ";
var Xopf = "𝕏";
var Xscr = "𝒳";
var YAcy = "Я";
var YIcy = "Ї";
var YUcy = "Ю";
var Yacut = "Ý";
var Yacute$1 = "Ý";
var Ycirc = "Ŷ";
var Ycy = "Ы";
var Yfr = "𝔜";
var Yopf = "𝕐";
var Yscr = "𝒴";
var Yuml$1 = "Ÿ";
var ZHcy = "Ж";
var Zacute = "Ź";
var Zcaron = "Ž";
var Zcy = "З";
var Zdot = "Ż";
var ZeroWidthSpace = "​";
var Zeta$1 = "Ζ";
var Zfr = "ℨ";
var Zopf = "ℤ";
var Zscr = "𝒵";
var aacut = "á";
var aacute$1 = "á";
var abreve = "ă";
var ac = "∾";
var acE = "∾̳";
var acd = "∿";
var acir = "â";
var acirc$1 = "â";
var acut = "´";
var acute$1 = "´";
var acy = "а";
var aeli = "æ";
var aelig$1 = "æ";
var af = "⁡";
var afr = "𝔞";
var agrav = "à";
var agrave$1 = "à";
var alefsym$1 = "ℵ";
var aleph = "ℵ";
var alpha$1 = "α";
var amacr = "ā";
var amalg = "⨿";
var am = "&";
var amp$1 = "&";
var and$1 = "∧";
var andand = "⩕";
var andd = "⩜";
var andslope = "⩘";
var andv = "⩚";
var ang$1 = "∠";
var ange = "⦤";
var angle = "∠";
var angmsd = "∡";
var angmsdaa = "⦨";
var angmsdab = "⦩";
var angmsdac = "⦪";
var angmsdad = "⦫";
var angmsdae = "⦬";
var angmsdaf = "⦭";
var angmsdag = "⦮";
var angmsdah = "⦯";
var angrt = "∟";
var angrtvb = "⊾";
var angrtvbd = "⦝";
var angsph = "∢";
var angst = "Å";
var angzarr = "⍼";
var aogon = "ą";
var aopf = "𝕒";
var ap = "≈";
var apE = "⩰";
var apacir = "⩯";
var ape = "≊";
var apid = "≋";
var apos = "'";
var approx = "≈";
var approxeq = "≊";
var arin = "å";
var aring$1 = "å";
var ascr = "𝒶";
var ast = "*";
var asymp$1 = "≈";
var asympeq = "≍";
var atild = "ã";
var atilde$1 = "ã";
var aum = "ä";
var auml$1 = "ä";
var awconint = "∳";
var awint = "⨑";
var bNot = "⫭";
var backcong = "≌";
var backepsilon = "϶";
var backprime = "‵";
var backsim = "∽";
var backsimeq = "⋍";
var barvee = "⊽";
var barwed = "⌅";
var barwedge = "⌅";
var bbrk = "⎵";
var bbrktbrk = "⎶";
var bcong = "≌";
var bcy = "б";
var bdquo$1 = "„";
var becaus = "∵";
var because = "∵";
var bemptyv = "⦰";
var bepsi = "϶";
var bernou = "ℬ";
var beta$1 = "β";
var beth = "ℶ";
var between = "≬";
var bfr = "𝔟";
var bigcap = "⋂";
var bigcirc = "◯";
var bigcup = "⋃";
var bigodot = "⨀";
var bigoplus = "⨁";
var bigotimes = "⨂";
var bigsqcup = "⨆";
var bigstar = "★";
var bigtriangledown = "▽";
var bigtriangleup = "△";
var biguplus = "⨄";
var bigvee = "⋁";
var bigwedge = "⋀";
var bkarow = "⤍";
var blacklozenge = "⧫";
var blacksquare = "▪";
var blacktriangle = "▴";
var blacktriangledown = "▾";
var blacktriangleleft = "◂";
var blacktriangleright = "▸";
var blank = "␣";
var blk12 = "▒";
var blk14 = "░";
var blk34 = "▓";
var block = "█";
var bne = "=⃥";
var bnequiv = "≡⃥";
var bnot = "⌐";
var bopf = "𝕓";
var bot = "⊥";
var bottom = "⊥";
var bowtie = "⋈";
var boxDL = "╗";
var boxDR = "╔";
var boxDl = "╖";
var boxDr = "╓";
var boxH = "═";
var boxHD = "╦";
var boxHU = "╩";
var boxHd = "╤";
var boxHu = "╧";
var boxUL = "╝";
var boxUR = "╚";
var boxUl = "╜";
var boxUr = "╙";
var boxV = "║";
var boxVH = "╬";
var boxVL = "╣";
var boxVR = "╠";
var boxVh = "╫";
var boxVl = "╢";
var boxVr = "╟";
var boxbox = "⧉";
var boxdL = "╕";
var boxdR = "╒";
var boxdl = "┐";
var boxdr = "┌";
var boxh = "─";
var boxhD = "╥";
var boxhU = "╨";
var boxhd = "┬";
var boxhu = "┴";
var boxminus = "⊟";
var boxplus = "⊞";
var boxtimes = "⊠";
var boxuL = "╛";
var boxuR = "╘";
var boxul = "┘";
var boxur = "└";
var boxv = "│";
var boxvH = "╪";
var boxvL = "╡";
var boxvR = "╞";
var boxvh = "┼";
var boxvl = "┤";
var boxvr = "├";
var bprime = "‵";
var breve = "˘";
var brvba = "¦";
var brvbar$1 = "¦";
var bscr = "𝒷";
var bsemi = "⁏";
var bsim = "∽";
var bsime = "⋍";
var bsol = "\\";
var bsolb = "⧅";
var bsolhsub = "⟈";
var bull$1 = "•";
var bullet = "•";
var bump = "≎";
var bumpE = "⪮";
var bumpe = "≏";
var bumpeq = "≏";
var cacute = "ć";
var cap$2 = "∩";
var capand = "⩄";
var capbrcup = "⩉";
var capcap = "⩋";
var capcup = "⩇";
var capdot = "⩀";
var caps = "∩︀";
var caret = "⁁";
var caron = "ˇ";
var ccaps = "⩍";
var ccaron = "č";
var ccedi = "ç";
var ccedil$1 = "ç";
var ccirc = "ĉ";
var ccups = "⩌";
var ccupssm = "⩐";
var cdot = "ċ";
var cedi = "¸";
var cedil$1 = "¸";
var cemptyv = "⦲";
var cen = "¢";
var cent$1 = "¢";
var centerdot = "·";
var cfr = "𝔠";
var chcy = "ч";
var check = "✓";
var checkmark = "✓";
var chi$1 = "χ";
var cir = "○";
var cirE = "⧃";
var circ$1 = "ˆ";
var circeq = "≗";
var circlearrowleft = "↺";
var circlearrowright = "↻";
var circledR = "®";
var circledS = "Ⓢ";
var circledast = "⊛";
var circledcirc = "⊚";
var circleddash = "⊝";
var cire = "≗";
var cirfnint = "⨐";
var cirmid = "⫯";
var cirscir = "⧂";
var clubs$1 = "♣";
var clubsuit = "♣";
var colon$3 = ":";
var colone = "≔";
var coloneq = "≔";
var comma$2 = ",";
var commat = "@";
var comp = "∁";
var compfn = "∘";
var complement = "∁";
var complexes = "ℂ";
var cong$1 = "≅";
var congdot = "⩭";
var conint = "∮";
var copf = "𝕔";
var coprod = "∐";
var cop = "©";
var copy$1 = "©";
var copysr = "℗";
var crarr$1 = "↵";
var cross = "✗";
var cscr = "𝒸";
var csub = "⫏";
var csube = "⫑";
var csup = "⫐";
var csupe = "⫒";
var ctdot = "⋯";
var cudarrl = "⤸";
var cudarrr = "⤵";
var cuepr = "⋞";
var cuesc = "⋟";
var cularr = "↶";
var cularrp = "⤽";
var cup$1 = "∪";
var cupbrcap = "⩈";
var cupcap = "⩆";
var cupcup = "⩊";
var cupdot = "⊍";
var cupor = "⩅";
var cups = "∪︀";
var curarr = "↷";
var curarrm = "⤼";
var curlyeqprec = "⋞";
var curlyeqsucc = "⋟";
var curlyvee = "⋎";
var curlywedge = "⋏";
var curre = "¤";
var curren$1 = "¤";
var curvearrowleft = "↶";
var curvearrowright = "↷";
var cuvee = "⋎";
var cuwed = "⋏";
var cwconint = "∲";
var cwint = "∱";
var cylcty = "⌭";
var dArr$1 = "⇓";
var dHar = "⥥";
var dagger$1 = "†";
var daleth = "ℸ";
var darr$1 = "↓";
var dash$8 = "‐";
var dashv = "⊣";
var dbkarow = "⤏";
var dblac = "˝";
var dcaron = "ď";
var dcy = "д";
var dd$1 = "ⅆ";
var ddagger = "‡";
var ddarr = "⇊";
var ddotseq = "⩷";
var de = "°";
var deg$1 = "°";
var delta$1 = "δ";
var demptyv = "⦱";
var dfisht = "⥿";
var dfr = "𝔡";
var dharl = "⇃";
var dharr = "⇂";
var diam = "⋄";
var diamond = "⋄";
var diamondsuit = "♦";
var diams$1 = "♦";
var die = "¨";
var digamma = "ϝ";
var disin = "⋲";
var div = "÷";
var divid = "÷";
var divide$1 = "÷";
var divideontimes = "⋇";
var divonx = "⋇";
var djcy = "ђ";
var dlcorn = "⌞";
var dlcrop = "⌍";
var dollar = "$";
var dopf = "𝕕";
var dot$4 = "˙";
var doteq = "≐";
var doteqdot = "≑";
var dotminus = "∸";
var dotplus = "∔";
var dotsquare = "⊡";
var doublebarwedge = "⌆";
var downarrow = "↓";
var downdownarrows = "⇊";
var downharpoonleft = "⇃";
var downharpoonright = "⇂";
var drbkarow = "⤐";
var drcorn = "⌟";
var drcrop = "⌌";
var dscr = "𝒹";
var dscy = "ѕ";
var dsol = "⧶";
var dstrok = "đ";
var dtdot = "⋱";
var dtri = "▿";
var dtrif = "▾";
var duarr = "⇵";
var duhar = "⥯";
var dwangle = "⦦";
var dzcy = "џ";
var dzigrarr = "⟿";
var eDDot = "⩷";
var eDot = "≑";
var eacut = "é";
var eacute$1 = "é";
var easter = "⩮";
var ecaron = "ě";
var ecir = "ê";
var ecirc$1 = "ê";
var ecolon = "≕";
var ecy = "э";
var edot = "ė";
var ee = "ⅇ";
var efDot = "≒";
var efr = "𝔢";
var eg = "⪚";
var egrav = "è";
var egrave$1 = "è";
var egs = "⪖";
var egsdot = "⪘";
var el = "⪙";
var elinters = "⏧";
var ell = "ℓ";
var els = "⪕";
var elsdot = "⪗";
var emacr = "ē";
var empty$3 = "∅";
var emptyset = "∅";
var emptyv = "∅";
var emsp13 = " ";
var emsp14 = " ";
var emsp$1 = " ";
var eng = "ŋ";
var ensp$1 = " ";
var eogon = "ę";
var eopf = "𝕖";
var epar = "⋕";
var eparsl = "⧣";
var eplus = "⩱";
var epsi = "ε";
var epsilon$1 = "ε";
var epsiv = "ϵ";
var eqcirc = "≖";
var eqcolon = "≕";
var eqsim = "≂";
var eqslantgtr = "⪖";
var eqslantless = "⪕";
var equals = "=";
var equest = "≟";
var equiv$1 = "≡";
var equivDD = "⩸";
var eqvparsl = "⧥";
var erDot = "≓";
var erarr = "⥱";
var escr = "ℯ";
var esdot = "≐";
var esim = "≂";
var eta$1 = "η";
var et = "ð";
var eth$1 = "ð";
var eum = "ë";
var euml$1 = "ë";
var euro$1 = "€";
var excl = "!";
var exist$1 = "∃";
var expectation = "ℰ";
var exponentiale = "ⅇ";
var fallingdotseq = "≒";
var fcy = "ф";
var female = "♀";
var ffilig = "ﬃ";
var fflig = "ﬀ";
var ffllig = "ﬄ";
var ffr = "𝔣";
var filig = "ﬁ";
var fjlig = "fj";
var flat = "♭";
var fllig = "ﬂ";
var fltns = "▱";
var fnof$1 = "ƒ";
var fopf = "𝕗";
var forall$1 = "∀";
var fork = "⋔";
var forkv = "⫙";
var fpartint = "⨍";
var frac1 = "¼";
var frac12$1 = "½";
var frac13 = "⅓";
var frac14$1 = "¼";
var frac15 = "⅕";
var frac16 = "⅙";
var frac18 = "⅛";
var frac23 = "⅔";
var frac25 = "⅖";
var frac3 = "¾";
var frac34$1 = "¾";
var frac35 = "⅗";
var frac38 = "⅜";
var frac45 = "⅘";
var frac56 = "⅚";
var frac58 = "⅝";
var frac78 = "⅞";
var frasl$1 = "⁄";
var frown = "⌢";
var fscr = "𝒻";
var gE = "≧";
var gEl = "⪌";
var gacute = "ǵ";
var gamma$1 = "γ";
var gammad = "ϝ";
var gap = "⪆";
var gbreve = "ğ";
var gcirc = "ĝ";
var gcy = "г";
var gdot = "ġ";
var ge$1 = "≥";
var gel = "⋛";
var geq = "≥";
var geqq = "≧";
var geqslant = "⩾";
var ges = "⩾";
var gescc = "⪩";
var gesdot = "⪀";
var gesdoto = "⪂";
var gesdotol = "⪄";
var gesl = "⋛︀";
var gesles = "⪔";
var gfr = "𝔤";
var gg = "≫";
var ggg = "⋙";
var gimel = "ℷ";
var gjcy = "ѓ";
var gl = "≷";
var glE = "⪒";
var gla = "⪥";
var glj = "⪤";
var gnE = "≩";
var gnap = "⪊";
var gnapprox = "⪊";
var gne = "⪈";
var gneq = "⪈";
var gneqq = "≩";
var gnsim = "⋧";
var gopf = "𝕘";
var grave = "`";
var gscr = "ℊ";
var gsim = "≳";
var gsime = "⪎";
var gsiml = "⪐";
var g = ">";
var gt$1 = ">";
var gtcc = "⪧";
var gtcir = "⩺";
var gtdot = "⋗";
var gtlPar = "⦕";
var gtquest = "⩼";
var gtrapprox = "⪆";
var gtrarr = "⥸";
var gtrdot = "⋗";
var gtreqless = "⋛";
var gtreqqless = "⪌";
var gtrless = "≷";
var gtrsim = "≳";
var gvertneqq = "≩︀";
var gvnE = "≩︀";
var hArr$1 = "⇔";
var hairsp = " ";
var half = "½";
var hamilt = "ℋ";
var hardcy = "ъ";
var harr$1 = "↔";
var harrcir = "⥈";
var harrw = "↭";
var hbar = "ℏ";
var hcirc = "ĥ";
var hearts$1 = "♥";
var heartsuit = "♥";
var hellip$1 = "…";
var hercon = "⊹";
var hfr = "𝔥";
var hksearow = "⤥";
var hkswarow = "⤦";
var hoarr = "⇿";
var homtht = "∻";
var hookleftarrow = "↩";
var hookrightarrow = "↪";
var hopf = "𝕙";
var horbar = "―";
var hscr = "𝒽";
var hslash = "ℏ";
var hstrok = "ħ";
var hybull = "⁃";
var hyphen = "‐";
var iacut = "í";
var iacute$1 = "í";
var ic = "⁣";
var icir = "î";
var icirc$1 = "î";
var icy = "и";
var iecy = "е";
var iexc = "¡";
var iexcl$1 = "¡";
var iff = "⇔";
var ifr = "𝔦";
var igrav = "ì";
var igrave$1 = "ì";
var ii = "ⅈ";
var iiiint = "⨌";
var iiint = "∭";
var iinfin = "⧜";
var iiota = "℩";
var ijlig = "ĳ";
var imacr = "ī";
var image$3 = "ℑ";
var imagline = "ℐ";
var imagpart = "ℑ";
var imath = "ı";
var imof = "⊷";
var imped = "Ƶ";
var incare = "℅";
var infin$1 = "∞";
var infintie = "⧝";
var inodot = "ı";
var int$1 = "∫";
var intcal = "⊺";
var integers = "ℤ";
var intercal = "⊺";
var intlarhk = "⨗";
var intprod = "⨼";
var iocy = "ё";
var iogon = "į";
var iopf = "𝕚";
var iota$1 = "ι";
var iprod = "⨼";
var iques = "¿";
var iquest$1 = "¿";
var iscr = "𝒾";
var isin$1 = "∈";
var isinE = "⋹";
var isindot = "⋵";
var isins = "⋴";
var isinsv = "⋳";
var isinv = "∈";
var it = "⁢";
var itilde = "ĩ";
var iukcy = "і";
var ium = "ï";
var iuml$1 = "ï";
var jcirc = "ĵ";
var jcy = "й";
var jfr = "𝔧";
var jmath = "ȷ";
var jopf = "𝕛";
var jscr = "𝒿";
var jsercy = "ј";
var jukcy = "є";
var kappa$1 = "κ";
var kappav = "ϰ";
var kcedil = "ķ";
var kcy = "к";
var kfr = "𝔨";
var kgreen = "ĸ";
var khcy = "х";
var kjcy = "ќ";
var kopf = "𝕜";
var kscr = "𝓀";
var lAarr = "⇚";
var lArr$1 = "⇐";
var lAtail = "⤛";
var lBarr = "⤎";
var lE = "≦";
var lEg = "⪋";
var lHar = "⥢";
var lacute = "ĺ";
var laemptyv = "⦴";
var lagran = "ℒ";
var lambda$1 = "λ";
var lang$1 = "⟨";
var langd = "⦑";
var langle = "⟨";
var lap = "⪅";
var laqu = "«";
var laquo$1 = "«";
var larr$1 = "←";
var larrb = "⇤";
var larrbfs = "⤟";
var larrfs = "⤝";
var larrhk = "↩";
var larrlp = "↫";
var larrpl = "⤹";
var larrsim = "⥳";
var larrtl = "↢";
var lat = "⪫";
var latail = "⤙";
var late = "⪭";
var lates = "⪭︀";
var lbarr = "⤌";
var lbbrk = "❲";
var lbrace = "{";
var lbrack = "[";
var lbrke = "⦋";
var lbrksld = "⦏";
var lbrkslu = "⦍";
var lcaron = "ľ";
var lcedil = "ļ";
var lceil$1 = "⌈";
var lcub = "{";
var lcy = "л";
var ldca = "⤶";
var ldquo$1 = "“";
var ldquor = "„";
var ldrdhar = "⥧";
var ldrushar = "⥋";
var ldsh = "↲";
var le$1 = "≤";
var leftarrow = "←";
var leftarrowtail = "↢";
var leftharpoondown = "↽";
var leftharpoonup = "↼";
var leftleftarrows = "⇇";
var leftrightarrow = "↔";
var leftrightarrows = "⇆";
var leftrightharpoons = "⇋";
var leftrightsquigarrow = "↭";
var leftthreetimes = "⋋";
var leg = "⋚";
var leq = "≤";
var leqq = "≦";
var leqslant = "⩽";
var les = "⩽";
var lescc = "⪨";
var lesdot = "⩿";
var lesdoto = "⪁";
var lesdotor = "⪃";
var lesg = "⋚︀";
var lesges = "⪓";
var lessapprox = "⪅";
var lessdot = "⋖";
var lesseqgtr = "⋚";
var lesseqqgtr = "⪋";
var lessgtr = "≶";
var lesssim = "≲";
var lfisht = "⥼";
var lfloor$1 = "⌊";
var lfr = "𝔩";
var lg = "≶";
var lgE = "⪑";
var lhard = "↽";
var lharu = "↼";
var lharul = "⥪";
var lhblk = "▄";
var ljcy = "љ";
var ll = "≪";
var llarr = "⇇";
var llcorner = "⌞";
var llhard = "⥫";
var lltri = "◺";
var lmidot = "ŀ";
var lmoust = "⎰";
var lmoustache = "⎰";
var lnE = "≨";
var lnap = "⪉";
var lnapprox = "⪉";
var lne = "⪇";
var lneq = "⪇";
var lneqq = "≨";
var lnsim = "⋦";
var loang = "⟬";
var loarr = "⇽";
var lobrk = "⟦";
var longleftarrow = "⟵";
var longleftrightarrow = "⟷";
var longmapsto = "⟼";
var longrightarrow = "⟶";
var looparrowleft = "↫";
var looparrowright = "↬";
var lopar = "⦅";
var lopf = "𝕝";
var loplus = "⨭";
var lotimes = "⨴";
var lowast$1 = "∗";
var lowbar = "_";
var loz$1 = "◊";
var lozenge = "◊";
var lozf = "⧫";
var lpar = "(";
var lparlt = "⦓";
var lrarr = "⇆";
var lrcorner = "⌟";
var lrhar = "⇋";
var lrhard = "⥭";
var lrm$1 = "‎";
var lrtri = "⊿";
var lsaquo$1 = "‹";
var lscr = "𝓁";
var lsh = "↰";
var lsim = "≲";
var lsime = "⪍";
var lsimg = "⪏";
var lsqb = "[";
var lsquo$1 = "‘";
var lsquor = "‚";
var lstrok = "ł";
var l = "<";
var lt$1 = "<";
var ltcc = "⪦";
var ltcir = "⩹";
var ltdot = "⋖";
var lthree = "⋋";
var ltimes = "⋉";
var ltlarr = "⥶";
var ltquest = "⩻";
var ltrPar = "⦖";
var ltri = "◃";
var ltrie = "⊴";
var ltrif = "◂";
var lurdshar = "⥊";
var luruhar = "⥦";
var lvertneqq = "≨︀";
var lvnE = "≨︀";
var mDDot = "∺";
var mac = "¯";
var macr$1 = "¯";
var male = "♂";
var malt = "✠";
var maltese = "✠";
var map$1 = "↦";
var mapsto = "↦";
var mapstodown = "↧";
var mapstoleft = "↤";
var mapstoup = "↥";
var marker = "▮";
var mcomma = "⨩";
var mcy = "м";
var mdash$1 = "—";
var measuredangle = "∡";
var mfr = "𝔪";
var mho = "℧";
var micr = "µ";
var micro$1 = "µ";
var mid = "∣";
var midast = "*";
var midcir = "⫰";
var middo = "·";
var middot$1 = "·";
var minus$1 = "−";
var minusb = "⊟";
var minusd = "∸";
var minusdu = "⨪";
var mlcp = "⫛";
var mldr = "…";
var mnplus = "∓";
var models = "⊧";
var mopf = "𝕞";
var mp = "∓";
var mscr = "𝓂";
var mstpos = "∾";
var mu$1 = "μ";
var multimap = "⊸";
var mumap = "⊸";
var nGg = "⋙̸";
var nGt = "≫⃒";
var nGtv = "≫̸";
var nLeftarrow = "⇍";
var nLeftrightarrow = "⇎";
var nLl = "⋘̸";
var nLt = "≪⃒";
var nLtv = "≪̸";
var nRightarrow = "⇏";
var nVDash = "⊯";
var nVdash = "⊮";
var nabla$1 = "∇";
var nacute = "ń";
var nang = "∠⃒";
var nap = "≉";
var napE = "⩰̸";
var napid = "≋̸";
var napos = "ŉ";
var napprox = "≉";
var natur = "♮";
var natural = "♮";
var naturals = "ℕ";
var nbs = " ";
var nbsp$1 = " ";
var nbump = "≎̸";
var nbumpe = "≏̸";
var ncap = "⩃";
var ncaron = "ň";
var ncedil = "ņ";
var ncong = "≇";
var ncongdot = "⩭̸";
var ncup = "⩂";
var ncy = "н";
var ndash$1 = "–";
var ne$1 = "≠";
var neArr = "⇗";
var nearhk = "⤤";
var nearr = "↗";
var nearrow = "↗";
var nedot = "≐̸";
var nequiv = "≢";
var nesear = "⤨";
var nesim = "≂̸";
var nexist = "∄";
var nexists = "∄";
var nfr = "𝔫";
var ngE = "≧̸";
var nge = "≱";
var ngeq = "≱";
var ngeqq = "≧̸";
var ngeqslant = "⩾̸";
var nges = "⩾̸";
var ngsim = "≵";
var ngt = "≯";
var ngtr = "≯";
var nhArr = "⇎";
var nharr = "↮";
var nhpar = "⫲";
var ni$1 = "∋";
var nis = "⋼";
var nisd = "⋺";
var niv = "∋";
var njcy = "њ";
var nlArr = "⇍";
var nlE = "≦̸";
var nlarr = "↚";
var nldr = "‥";
var nle = "≰";
var nleftarrow = "↚";
var nleftrightarrow = "↮";
var nleq = "≰";
var nleqq = "≦̸";
var nleqslant = "⩽̸";
var nles = "⩽̸";
var nless = "≮";
var nlsim = "≴";
var nlt = "≮";
var nltri = "⋪";
var nltrie = "⋬";
var nmid = "∤";
var nopf = "𝕟";
var no = "¬";
var not$1 = "¬";
var notin$1 = "∉";
var notinE = "⋹̸";
var notindot = "⋵̸";
var notinva = "∉";
var notinvb = "⋷";
var notinvc = "⋶";
var notni = "∌";
var notniva = "∌";
var notnivb = "⋾";
var notnivc = "⋽";
var npar = "∦";
var nparallel = "∦";
var nparsl = "⫽⃥";
var npart = "∂̸";
var npolint = "⨔";
var npr = "⊀";
var nprcue = "⋠";
var npre = "⪯̸";
var nprec = "⊀";
var npreceq = "⪯̸";
var nrArr = "⇏";
var nrarr = "↛";
var nrarrc = "⤳̸";
var nrarrw = "↝̸";
var nrightarrow = "↛";
var nrtri = "⋫";
var nrtrie = "⋭";
var nsc = "⊁";
var nsccue = "⋡";
var nsce = "⪰̸";
var nscr = "𝓃";
var nshortmid = "∤";
var nshortparallel = "∦";
var nsim = "≁";
var nsime = "≄";
var nsimeq = "≄";
var nsmid = "∤";
var nspar = "∦";
var nsqsube = "⋢";
var nsqsupe = "⋣";
var nsub$1 = "⊄";
var nsubE = "⫅̸";
var nsube = "⊈";
var nsubset = "⊂⃒";
var nsubseteq = "⊈";
var nsubseteqq = "⫅̸";
var nsucc = "⊁";
var nsucceq = "⪰̸";
var nsup = "⊅";
var nsupE = "⫆̸";
var nsupe = "⊉";
var nsupset = "⊃⃒";
var nsupseteq = "⊉";
var nsupseteqq = "⫆̸";
var ntgl = "≹";
var ntild = "ñ";
var ntilde$1 = "ñ";
var ntlg = "≸";
var ntriangleleft = "⋪";
var ntrianglelefteq = "⋬";
var ntriangleright = "⋫";
var ntrianglerighteq = "⋭";
var nu$1 = "ν";
var num = "#";
var numero = "№";
var numsp = " ";
var nvDash = "⊭";
var nvHarr = "⤄";
var nvap = "≍⃒";
var nvdash = "⊬";
var nvge = "≥⃒";
var nvgt = ">⃒";
var nvinfin = "⧞";
var nvlArr = "⤂";
var nvle = "≤⃒";
var nvlt = "<⃒";
var nvltrie = "⊴⃒";
var nvrArr = "⤃";
var nvrtrie = "⊵⃒";
var nvsim = "∼⃒";
var nwArr = "⇖";
var nwarhk = "⤣";
var nwarr = "↖";
var nwarrow = "↖";
var nwnear = "⤧";
var oS = "Ⓢ";
var oacut = "ó";
var oacute$1 = "ó";
var oast = "⊛";
var ocir = "ô";
var ocirc$1 = "ô";
var ocy = "о";
var odash = "⊝";
var odblac = "ő";
var odiv = "⨸";
var odot = "⊙";
var odsold = "⦼";
var oelig$1 = "œ";
var ofcir = "⦿";
var ofr = "𝔬";
var ogon = "˛";
var ograv = "ò";
var ograve$1 = "ò";
var ogt = "⧁";
var ohbar = "⦵";
var ohm = "Ω";
var oint = "∮";
var olarr = "↺";
var olcir = "⦾";
var olcross = "⦻";
var oline$1 = "‾";
var olt = "⧀";
var omacr = "ō";
var omega$1 = "ω";
var omicron$1 = "ο";
var omid = "⦶";
var ominus = "⊖";
var oopf = "𝕠";
var opar = "⦷";
var operp = "⦹";
var oplus$1 = "⊕";
var or$1 = "∨";
var orarr = "↻";
var ord = "º";
var order = "ℴ";
var orderof = "ℴ";
var ordf$1 = "ª";
var ordm$1 = "º";
var origof = "⊶";
var oror = "⩖";
var orslope = "⩗";
var orv = "⩛";
var oscr = "ℴ";
var oslas = "ø";
var oslash$1 = "ø";
var osol = "⊘";
var otild = "õ";
var otilde$1 = "õ";
var otimes$1 = "⊗";
var otimesas = "⨶";
var oum = "ö";
var ouml$1 = "ö";
var ovbar = "⌽";
var par = "¶";
var para$1 = "¶";
var parallel = "∥";
var parsim = "⫳";
var parsl = "⫽";
var part$1 = "∂";
var pcy = "п";
var percnt = "%";
var period = ".";
var permil$1 = "‰";
var perp$1 = "⊥";
var pertenk = "‱";
var pfr = "𝔭";
var phi$1 = "φ";
var phiv = "ϕ";
var phmmat = "ℳ";
var phone = "☎";
var pi$1 = "π";
var pitchfork = "⋔";
var piv$1 = "ϖ";
var planck = "ℏ";
var planckh = "ℎ";
var plankv = "ℏ";
var plus = "+";
var plusacir = "⨣";
var plusb = "⊞";
var pluscir = "⨢";
var plusdo = "∔";
var plusdu = "⨥";
var pluse = "⩲";
var plusm = "±";
var plusmn$1 = "±";
var plussim = "⨦";
var plustwo = "⨧";
var pm = "±";
var pointint = "⨕";
var popf = "𝕡";
var poun = "£";
var pound$1 = "£";
var pr = "≺";
var prE = "⪳";
var prap = "⪷";
var prcue = "≼";
var pre = "⪯";
var prec = "≺";
var precapprox = "⪷";
var preccurlyeq = "≼";
var preceq = "⪯";
var precnapprox = "⪹";
var precneqq = "⪵";
var precnsim = "⋨";
var precsim = "≾";
var prime$1 = "′";
var primes = "ℙ";
var prnE = "⪵";
var prnap = "⪹";
var prnsim = "⋨";
var prod$1 = "∏";
var profalar = "⌮";
var profline = "⌒";
var profsurf = "⌓";
var prop$1 = "∝";
var propto = "∝";
var prsim = "≾";
var prurel = "⊰";
var pscr = "𝓅";
var psi$1 = "ψ";
var puncsp = " ";
var qfr = "𝔮";
var qint = "⨌";
var qopf = "𝕢";
var qprime = "⁗";
var qscr = "𝓆";
var quaternions = "ℍ";
var quatint = "⨖";
var quest = "?";
var questeq = "≟";
var quo = "\"";
var quot$1 = "\"";
var rAarr = "⇛";
var rArr$1 = "⇒";
var rAtail = "⤜";
var rBarr = "⤏";
var rHar = "⥤";
var race = "∽̱";
var racute = "ŕ";
var radic$1 = "√";
var raemptyv = "⦳";
var rang$1 = "⟩";
var rangd = "⦒";
var range = "⦥";
var rangle = "⟩";
var raqu = "»";
var raquo$1 = "»";
var rarr$1 = "→";
var rarrap = "⥵";
var rarrb = "⇥";
var rarrbfs = "⤠";
var rarrc = "⤳";
var rarrfs = "⤞";
var rarrhk = "↪";
var rarrlp = "↬";
var rarrpl = "⥅";
var rarrsim = "⥴";
var rarrtl = "↣";
var rarrw = "↝";
var ratail = "⤚";
var ratio = "∶";
var rationals = "ℚ";
var rbarr = "⤍";
var rbbrk = "❳";
var rbrace = "}";
var rbrack = "]";
var rbrke = "⦌";
var rbrksld = "⦎";
var rbrkslu = "⦐";
var rcaron = "ř";
var rcedil = "ŗ";
var rceil$1 = "⌉";
var rcub = "}";
var rcy = "р";
var rdca = "⤷";
var rdldhar = "⥩";
var rdquo$1 = "”";
var rdquor = "”";
var rdsh = "↳";
var real$1 = "ℜ";
var realine = "ℛ";
var realpart = "ℜ";
var reals = "ℝ";
var rect = "▭";
var re$3 = "®";
var reg$1 = "®";
var rfisht = "⥽";
var rfloor$1 = "⌋";
var rfr = "𝔯";
var rhard = "⇁";
var rharu = "⇀";
var rharul = "⥬";
var rho$1 = "ρ";
var rhov = "ϱ";
var rightarrow = "→";
var rightarrowtail = "↣";
var rightharpoondown = "⇁";
var rightharpoonup = "⇀";
var rightleftarrows = "⇄";
var rightleftharpoons = "⇌";
var rightrightarrows = "⇉";
var rightsquigarrow = "↝";
var rightthreetimes = "⋌";
var ring = "˚";
var risingdotseq = "≓";
var rlarr = "⇄";
var rlhar = "⇌";
var rlm$1 = "‏";
var rmoust = "⎱";
var rmoustache = "⎱";
var rnmid = "⫮";
var roang = "⟭";
var roarr = "⇾";
var robrk = "⟧";
var ropar = "⦆";
var ropf = "𝕣";
var roplus = "⨮";
var rotimes = "⨵";
var rpar = ")";
var rpargt = "⦔";
var rppolint = "⨒";
var rrarr = "⇉";
var rsaquo$1 = "›";
var rscr = "𝓇";
var rsh = "↱";
var rsqb = "]";
var rsquo$1 = "’";
var rsquor = "’";
var rthree = "⋌";
var rtimes = "⋊";
var rtri = "▹";
var rtrie = "⊵";
var rtrif = "▸";
var rtriltri = "⧎";
var ruluhar = "⥨";
var rx = "℞";
var sacute = "ś";
var sbquo$1 = "‚";
var sc = "≻";
var scE = "⪴";
var scap = "⪸";
var scaron$1 = "š";
var sccue = "≽";
var sce = "⪰";
var scedil = "ş";
var scirc = "ŝ";
var scnE = "⪶";
var scnap = "⪺";
var scnsim = "⋩";
var scpolint = "⨓";
var scsim = "≿";
var scy = "с";
var sdot$1 = "⋅";
var sdotb = "⊡";
var sdote = "⩦";
var seArr = "⇘";
var searhk = "⤥";
var searr = "↘";
var searrow = "↘";
var sec = "§";
var sect$1 = "§";
var semi = ";";
var seswar = "⤩";
var setminus = "∖";
var setmn = "∖";
var sext = "✶";
var sfr = "𝔰";
var sfrown = "⌢";
var sharp = "♯";
var shchcy = "щ";
var shcy = "ш";
var shortmid = "∣";
var shortparallel = "∥";
var sh = "­";
var shy$1 = "­";
var sigma$1 = "σ";
var sigmaf$1 = "ς";
var sigmav = "ς";
var sim$1 = "∼";
var simdot = "⩪";
var sime = "≃";
var simeq = "≃";
var simg = "⪞";
var simgE = "⪠";
var siml = "⪝";
var simlE = "⪟";
var simne = "≆";
var simplus = "⨤";
var simrarr = "⥲";
var slarr = "←";
var smallsetminus = "∖";
var smashp = "⨳";
var smeparsl = "⧤";
var smid = "∣";
var smile = "⌣";
var smt = "⪪";
var smte = "⪬";
var smtes = "⪬︀";
var softcy = "ь";
var sol = "/";
var solb = "⧄";
var solbar = "⌿";
var sopf = "𝕤";
var spades$1 = "♠";
var spadesuit = "♠";
var spar = "∥";
var sqcap = "⊓";
var sqcaps = "⊓︀";
var sqcup = "⊔";
var sqcups = "⊔︀";
var sqsub = "⊏";
var sqsube = "⊑";
var sqsubset = "⊏";
var sqsubseteq = "⊑";
var sqsup = "⊐";
var sqsupe = "⊒";
var sqsupset = "⊐";
var sqsupseteq = "⊒";
var squ = "□";
var square = "□";
var squarf = "▪";
var squf = "▪";
var srarr = "→";
var sscr = "𝓈";
var ssetmn = "∖";
var ssmile = "⌣";
var sstarf = "⋆";
var star = "☆";
var starf = "★";
var straightepsilon = "ϵ";
var straightphi = "ϕ";
var strns = "¯";
var sub$1 = "⊂";
var subE = "⫅";
var subdot = "⪽";
var sube$1 = "⊆";
var subedot = "⫃";
var submult = "⫁";
var subnE = "⫋";
var subne = "⊊";
var subplus = "⪿";
var subrarr = "⥹";
var subset = "⊂";
var subseteq = "⊆";
var subseteqq = "⫅";
var subsetneq = "⊊";
var subsetneqq = "⫋";
var subsim = "⫇";
var subsub = "⫕";
var subsup = "⫓";
var succ = "≻";
var succapprox = "⪸";
var succcurlyeq = "≽";
var succeq = "⪰";
var succnapprox = "⪺";
var succneqq = "⪶";
var succnsim = "⋩";
var succsim = "≿";
var sum$1 = "∑";
var sung = "♪";
var sup$1 = "⊃";
var sup1$1 = "¹";
var sup2$1 = "²";
var sup3$1 = "³";
var supE = "⫆";
var supdot = "⪾";
var supdsub = "⫘";
var supe$1 = "⊇";
var supedot = "⫄";
var suphsol = "⟉";
var suphsub = "⫗";
var suplarr = "⥻";
var supmult = "⫂";
var supnE = "⫌";
var supne = "⊋";
var supplus = "⫀";
var supset = "⊃";
var supseteq = "⊇";
var supseteqq = "⫆";
var supsetneq = "⊋";
var supsetneqq = "⫌";
var supsim = "⫈";
var supsub = "⫔";
var supsup = "⫖";
var swArr = "⇙";
var swarhk = "⤦";
var swarr = "↙";
var swarrow = "↙";
var swnwar = "⤪";
var szli = "ß";
var szlig$1 = "ß";
var target = "⌖";
var tau$1 = "τ";
var tbrk = "⎴";
var tcaron = "ť";
var tcedil = "ţ";
var tcy = "т";
var tdot = "⃛";
var telrec = "⌕";
var tfr = "𝔱";
var there4$1 = "∴";
var therefore = "∴";
var theta$1 = "θ";
var thetasym$1 = "ϑ";
var thetav = "ϑ";
var thickapprox = "≈";
var thicksim = "∼";
var thinsp$1 = " ";
var thkap = "≈";
var thksim = "∼";
var thor = "þ";
var thorn$1 = "þ";
var tilde$4 = "˜";
var time = "×";
var times$1 = "×";
var timesb = "⊠";
var timesbar = "⨱";
var timesd = "⨰";
var tint = "∭";
var toea = "⤨";
var top = "⊤";
var topbot = "⌶";
var topcir = "⫱";
var topf = "𝕥";
var topfork = "⫚";
var tosa = "⤩";
var tprime = "‴";
var trade$1 = "™";
var triangle = "▵";
var triangledown = "▿";
var triangleleft = "◃";
var trianglelefteq = "⊴";
var triangleq = "≜";
var triangleright = "▹";
var trianglerighteq = "⊵";
var tridot = "◬";
var trie = "≜";
var triminus = "⨺";
var triplus = "⨹";
var trisb = "⧍";
var tritime = "⨻";
var trpezium = "⏢";
var tscr = "𝓉";
var tscy = "ц";
var tshcy = "ћ";
var tstrok = "ŧ";
var twixt = "≬";
var twoheadleftarrow = "↞";
var twoheadrightarrow = "↠";
var uArr$1 = "⇑";
var uHar = "⥣";
var uacut = "ú";
var uacute$1 = "ú";
var uarr$1 = "↑";
var ubrcy = "ў";
var ubreve = "ŭ";
var ucir = "û";
var ucirc$1 = "û";
var ucy = "у";
var udarr = "⇅";
var udblac = "ű";
var udhar = "⥮";
var ufisht = "⥾";
var ufr = "𝔲";
var ugrav = "ù";
var ugrave$1 = "ù";
var uharl = "↿";
var uharr = "↾";
var uhblk = "▀";
var ulcorn = "⌜";
var ulcorner = "⌜";
var ulcrop = "⌏";
var ultri = "◸";
var umacr = "ū";
var um = "¨";
var uml$1 = "¨";
var uogon = "ų";
var uopf = "𝕦";
var uparrow = "↑";
var updownarrow = "↕";
var upharpoonleft = "↿";
var upharpoonright = "↾";
var uplus = "⊎";
var upsi = "υ";
var upsih$1 = "ϒ";
var upsilon$1 = "υ";
var upuparrows = "⇈";
var urcorn = "⌝";
var urcorner = "⌝";
var urcrop = "⌎";
var uring = "ů";
var urtri = "◹";
var uscr = "𝓊";
var utdot = "⋰";
var utilde = "ũ";
var utri = "▵";
var utrif = "▴";
var uuarr = "⇈";
var uum = "ü";
var uuml$1 = "ü";
var uwangle = "⦧";
var vArr = "⇕";
var vBar = "⫨";
var vBarv = "⫩";
var vDash = "⊨";
var vangrt = "⦜";
var varepsilon = "ϵ";
var varkappa = "ϰ";
var varnothing = "∅";
var varphi = "ϕ";
var varpi = "ϖ";
var varpropto = "∝";
var varr = "↕";
var varrho = "ϱ";
var varsigma = "ς";
var varsubsetneq = "⊊︀";
var varsubsetneqq = "⫋︀";
var varsupsetneq = "⊋︀";
var varsupsetneqq = "⫌︀";
var vartheta = "ϑ";
var vartriangleleft = "⊲";
var vartriangleright = "⊳";
var vcy = "в";
var vdash = "⊢";
var vee = "∨";
var veebar = "⊻";
var veeeq = "≚";
var vellip = "⋮";
var verbar = "|";
var vert = "|";
var vfr = "𝔳";
var vltri = "⊲";
var vnsub = "⊂⃒";
var vnsup = "⊃⃒";
var vopf = "𝕧";
var vprop = "∝";
var vrtri = "⊳";
var vscr = "𝓋";
var vsubnE = "⫋︀";
var vsubne = "⊊︀";
var vsupnE = "⫌︀";
var vsupne = "⊋︀";
var vzigzag = "⦚";
var wcirc = "ŵ";
var wedbar = "⩟";
var wedge = "∧";
var wedgeq = "≙";
var weierp$1 = "℘";
var wfr = "𝔴";
var wopf = "𝕨";
var wp = "℘";
var wr = "≀";
var wreath = "≀";
var wscr = "𝓌";
var xcap = "⋂";
var xcirc = "◯";
var xcup = "⋃";
var xdtri = "▽";
var xfr = "𝔵";
var xhArr = "⟺";
var xharr = "⟷";
var xi$1 = "ξ";
var xlArr = "⟸";
var xlarr = "⟵";
var xmap = "⟼";
var xnis = "⋻";
var xodot = "⨀";
var xopf = "𝕩";
var xoplus = "⨁";
var xotime = "⨂";
var xrArr = "⟹";
var xrarr = "⟶";
var xscr = "𝓍";
var xsqcup = "⨆";
var xuplus = "⨄";
var xutri = "△";
var xvee = "⋁";
var xwedge = "⋀";
var yacut = "ý";
var yacute$1 = "ý";
var yacy = "я";
var ycirc = "ŷ";
var ycy = "ы";
var ye = "¥";
var yen$1 = "¥";
var yfr = "𝔶";
var yicy = "ї";
var yopf = "𝕪";
var yscr = "𝓎";
var yucy = "ю";
var yum = "ÿ";
var yuml$1 = "ÿ";
var zacute = "ź";
var zcaron = "ž";
var zcy = "з";
var zdot = "ż";
var zeetrf = "ℨ";
var zeta$1 = "ζ";
var zfr = "𝔷";
var zhcy = "ж";
var zigrarr = "⇝";
var zopf = "𝕫";
var zscr = "𝓏";
var zwj$1 = "‍";
var zwnj$1 = "‌";
var index$3 = {
	AEli: AEli,
	AElig: AElig$1,
	AM: AM,
	AMP: AMP$1,
	Aacut: Aacut,
	Aacute: Aacute$1,
	Abreve: Abreve,
	Acir: Acir,
	Acirc: Acirc$1,
	Acy: Acy,
	Afr: Afr,
	Agrav: Agrav,
	Agrave: Agrave$1,
	Alpha: Alpha$1,
	Amacr: Amacr,
	And: And,
	Aogon: Aogon,
	Aopf: Aopf,
	ApplyFunction: ApplyFunction,
	Arin: Arin,
	Aring: Aring$1,
	Ascr: Ascr,
	Assign: Assign,
	Atild: Atild,
	Atilde: Atilde$1,
	Aum: Aum,
	Auml: Auml$1,
	Backslash: Backslash,
	Barv: Barv,
	Barwed: Barwed,
	Bcy: Bcy,
	Because: Because,
	Bernoullis: Bernoullis,
	Beta: Beta$1,
	Bfr: Bfr,
	Bopf: Bopf,
	Breve: Breve,
	Bscr: Bscr,
	Bumpeq: Bumpeq,
	CHcy: CHcy,
	COP: COP,
	COPY: COPY,
	Cacute: Cacute,
	Cap: Cap,
	CapitalDifferentialD: CapitalDifferentialD,
	Cayleys: Cayleys,
	Ccaron: Ccaron,
	Ccedi: Ccedi,
	Ccedil: Ccedil$1,
	Ccirc: Ccirc,
	Cconint: Cconint,
	Cdot: Cdot,
	Cedilla: Cedilla,
	CenterDot: CenterDot,
	Cfr: Cfr,
	Chi: Chi$1,
	CircleDot: CircleDot,
	CircleMinus: CircleMinus,
	CirclePlus: CirclePlus,
	CircleTimes: CircleTimes,
	ClockwiseContourIntegral: ClockwiseContourIntegral,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
	CloseCurlyQuote: CloseCurlyQuote,
	Colon: Colon,
	Colone: Colone,
	Congruent: Congruent,
	Conint: Conint,
	ContourIntegral: ContourIntegral,
	Copf: Copf,
	Coproduct: Coproduct,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
	Cross: Cross,
	Cscr: Cscr,
	Cup: Cup,
	CupCap: CupCap,
	DD: DD,
	DDotrahd: DDotrahd,
	DJcy: DJcy,
	DScy: DScy,
	DZcy: DZcy,
	Dagger: Dagger$1,
	Darr: Darr,
	Dashv: Dashv,
	Dcaron: Dcaron,
	Dcy: Dcy,
	Del: Del,
	Delta: Delta$1,
	Dfr: Dfr,
	DiacriticalAcute: DiacriticalAcute,
	DiacriticalDot: DiacriticalDot,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
	DiacriticalGrave: DiacriticalGrave,
	DiacriticalTilde: DiacriticalTilde,
	Diamond: Diamond,
	DifferentialD: DifferentialD,
	Dopf: Dopf,
	Dot: Dot,
	DotDot: DotDot,
	DotEqual: DotEqual,
	DoubleContourIntegral: DoubleContourIntegral,
	DoubleDot: DoubleDot,
	DoubleDownArrow: DoubleDownArrow,
	DoubleLeftArrow: DoubleLeftArrow,
	DoubleLeftRightArrow: DoubleLeftRightArrow,
	DoubleLeftTee: DoubleLeftTee,
	DoubleLongLeftArrow: DoubleLongLeftArrow,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
	DoubleLongRightArrow: DoubleLongRightArrow,
	DoubleRightArrow: DoubleRightArrow,
	DoubleRightTee: DoubleRightTee,
	DoubleUpArrow: DoubleUpArrow,
	DoubleUpDownArrow: DoubleUpDownArrow,
	DoubleVerticalBar: DoubleVerticalBar,
	DownArrow: DownArrow,
	DownArrowBar: DownArrowBar,
	DownArrowUpArrow: DownArrowUpArrow,
	DownBreve: DownBreve,
	DownLeftRightVector: DownLeftRightVector,
	DownLeftTeeVector: DownLeftTeeVector,
	DownLeftVector: DownLeftVector,
	DownLeftVectorBar: DownLeftVectorBar,
	DownRightTeeVector: DownRightTeeVector,
	DownRightVector: DownRightVector,
	DownRightVectorBar: DownRightVectorBar,
	DownTee: DownTee,
	DownTeeArrow: DownTeeArrow,
	Downarrow: Downarrow,
	Dscr: Dscr,
	Dstrok: Dstrok,
	ENG: ENG,
	ET: ET,
	ETH: ETH$1,
	Eacut: Eacut,
	Eacute: Eacute$1,
	Ecaron: Ecaron,
	Ecir: Ecir,
	Ecirc: Ecirc$1,
	Ecy: Ecy,
	Edot: Edot,
	Efr: Efr,
	Egrav: Egrav,
	Egrave: Egrave$1,
	Element: Element,
	Emacr: Emacr,
	EmptySmallSquare: EmptySmallSquare,
	EmptyVerySmallSquare: EmptyVerySmallSquare,
	Eogon: Eogon,
	Eopf: Eopf,
	Epsilon: Epsilon$1,
	Equal: Equal,
	EqualTilde: EqualTilde,
	Equilibrium: Equilibrium,
	Escr: Escr,
	Esim: Esim,
	Eta: Eta$1,
	Eum: Eum,
	Euml: Euml$1,
	Exists: Exists,
	ExponentialE: ExponentialE,
	Fcy: Fcy,
	Ffr: Ffr,
	FilledSmallSquare: FilledSmallSquare,
	FilledVerySmallSquare: FilledVerySmallSquare,
	Fopf: Fopf,
	ForAll: ForAll,
	Fouriertrf: Fouriertrf,
	Fscr: Fscr,
	GJcy: GJcy,
	G: G,
	GT: GT$1,
	Gamma: Gamma$1,
	Gammad: Gammad,
	Gbreve: Gbreve,
	Gcedil: Gcedil,
	Gcirc: Gcirc,
	Gcy: Gcy,
	Gdot: Gdot,
	Gfr: Gfr,
	Gg: Gg,
	Gopf: Gopf,
	GreaterEqual: GreaterEqual,
	GreaterEqualLess: GreaterEqualLess,
	GreaterFullEqual: GreaterFullEqual,
	GreaterGreater: GreaterGreater,
	GreaterLess: GreaterLess,
	GreaterSlantEqual: GreaterSlantEqual,
	GreaterTilde: GreaterTilde,
	Gscr: Gscr,
	Gt: Gt,
	HARDcy: HARDcy,
	Hacek: Hacek,
	Hat: Hat,
	Hcirc: Hcirc,
	Hfr: Hfr,
	HilbertSpace: HilbertSpace,
	Hopf: Hopf,
	HorizontalLine: HorizontalLine,
	Hscr: Hscr,
	Hstrok: Hstrok,
	HumpDownHump: HumpDownHump,
	HumpEqual: HumpEqual,
	IEcy: IEcy,
	IJlig: IJlig,
	IOcy: IOcy,
	Iacut: Iacut,
	Iacute: Iacute$1,
	Icir: Icir,
	Icirc: Icirc$1,
	Icy: Icy,
	Idot: Idot,
	Ifr: Ifr,
	Igrav: Igrav,
	Igrave: Igrave$1,
	Im: Im,
	Imacr: Imacr,
	ImaginaryI: ImaginaryI,
	Implies: Implies,
	Int: Int,
	Integral: Integral,
	Intersection: Intersection,
	InvisibleComma: InvisibleComma,
	InvisibleTimes: InvisibleTimes,
	Iogon: Iogon,
	Iopf: Iopf,
	Iota: Iota$1,
	Iscr: Iscr,
	Itilde: Itilde,
	Iukcy: Iukcy,
	Ium: Ium,
	Iuml: Iuml$1,
	Jcirc: Jcirc,
	Jcy: Jcy,
	Jfr: Jfr,
	Jopf: Jopf,
	Jscr: Jscr,
	Jsercy: Jsercy,
	Jukcy: Jukcy,
	KHcy: KHcy,
	KJcy: KJcy,
	Kappa: Kappa$1,
	Kcedil: Kcedil,
	Kcy: Kcy,
	Kfr: Kfr,
	Kopf: Kopf,
	Kscr: Kscr,
	LJcy: LJcy,
	L: L,
	LT: LT$1,
	Lacute: Lacute,
	Lambda: Lambda$1,
	Lang: Lang,
	Laplacetrf: Laplacetrf,
	Larr: Larr,
	Lcaron: Lcaron,
	Lcedil: Lcedil,
	Lcy: Lcy,
	LeftAngleBracket: LeftAngleBracket,
	LeftArrow: LeftArrow,
	LeftArrowBar: LeftArrowBar,
	LeftArrowRightArrow: LeftArrowRightArrow,
	LeftCeiling: LeftCeiling,
	LeftDoubleBracket: LeftDoubleBracket,
	LeftDownTeeVector: LeftDownTeeVector,
	LeftDownVector: LeftDownVector,
	LeftDownVectorBar: LeftDownVectorBar,
	LeftFloor: LeftFloor,
	LeftRightArrow: LeftRightArrow,
	LeftRightVector: LeftRightVector,
	LeftTee: LeftTee,
	LeftTeeArrow: LeftTeeArrow,
	LeftTeeVector: LeftTeeVector,
	LeftTriangle: LeftTriangle,
	LeftTriangleBar: LeftTriangleBar,
	LeftTriangleEqual: LeftTriangleEqual,
	LeftUpDownVector: LeftUpDownVector,
	LeftUpTeeVector: LeftUpTeeVector,
	LeftUpVector: LeftUpVector,
	LeftUpVectorBar: LeftUpVectorBar,
	LeftVector: LeftVector,
	LeftVectorBar: LeftVectorBar,
	Leftarrow: Leftarrow,
	Leftrightarrow: Leftrightarrow,
	LessEqualGreater: LessEqualGreater,
	LessFullEqual: LessFullEqual,
	LessGreater: LessGreater,
	LessLess: LessLess,
	LessSlantEqual: LessSlantEqual,
	LessTilde: LessTilde,
	Lfr: Lfr,
	Ll: Ll,
	Lleftarrow: Lleftarrow,
	Lmidot: Lmidot,
	LongLeftArrow: LongLeftArrow,
	LongLeftRightArrow: LongLeftRightArrow,
	LongRightArrow: LongRightArrow,
	Longleftarrow: Longleftarrow,
	Longleftrightarrow: Longleftrightarrow,
	Longrightarrow: Longrightarrow,
	Lopf: Lopf,
	LowerLeftArrow: LowerLeftArrow,
	LowerRightArrow: LowerRightArrow,
	Lscr: Lscr,
	Lsh: Lsh,
	Lstrok: Lstrok,
	Lt: Lt,
	"Map": "⤅",
	Mcy: Mcy,
	MediumSpace: MediumSpace,
	Mellintrf: Mellintrf,
	Mfr: Mfr,
	MinusPlus: MinusPlus,
	Mopf: Mopf,
	Mscr: Mscr,
	Mu: Mu$1,
	NJcy: NJcy,
	Nacute: Nacute,
	Ncaron: Ncaron,
	Ncedil: Ncedil,
	Ncy: Ncy,
	NegativeMediumSpace: NegativeMediumSpace,
	NegativeThickSpace: NegativeThickSpace,
	NegativeThinSpace: NegativeThinSpace,
	NegativeVeryThinSpace: NegativeVeryThinSpace,
	NestedGreaterGreater: NestedGreaterGreater,
	NestedLessLess: NestedLessLess,
	NewLine: NewLine,
	Nfr: Nfr,
	NoBreak: NoBreak,
	NonBreakingSpace: NonBreakingSpace,
	Nopf: Nopf,
	Not: Not,
	NotCongruent: NotCongruent,
	NotCupCap: NotCupCap,
	NotDoubleVerticalBar: NotDoubleVerticalBar,
	NotElement: NotElement,
	NotEqual: NotEqual,
	NotEqualTilde: NotEqualTilde,
	NotExists: NotExists,
	NotGreater: NotGreater,
	NotGreaterEqual: NotGreaterEqual,
	NotGreaterFullEqual: NotGreaterFullEqual,
	NotGreaterGreater: NotGreaterGreater,
	NotGreaterLess: NotGreaterLess,
	NotGreaterSlantEqual: NotGreaterSlantEqual,
	NotGreaterTilde: NotGreaterTilde,
	NotHumpDownHump: NotHumpDownHump,
	NotHumpEqual: NotHumpEqual,
	NotLeftTriangle: NotLeftTriangle,
	NotLeftTriangleBar: NotLeftTriangleBar,
	NotLeftTriangleEqual: NotLeftTriangleEqual,
	NotLess: NotLess,
	NotLessEqual: NotLessEqual,
	NotLessGreater: NotLessGreater,
	NotLessLess: NotLessLess,
	NotLessSlantEqual: NotLessSlantEqual,
	NotLessTilde: NotLessTilde,
	NotNestedGreaterGreater: NotNestedGreaterGreater,
	NotNestedLessLess: NotNestedLessLess,
	NotPrecedes: NotPrecedes,
	NotPrecedesEqual: NotPrecedesEqual,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
	NotReverseElement: NotReverseElement,
	NotRightTriangle: NotRightTriangle,
	NotRightTriangleBar: NotRightTriangleBar,
	NotRightTriangleEqual: NotRightTriangleEqual,
	NotSquareSubset: NotSquareSubset,
	NotSquareSubsetEqual: NotSquareSubsetEqual,
	NotSquareSuperset: NotSquareSuperset,
	NotSquareSupersetEqual: NotSquareSupersetEqual,
	NotSubset: NotSubset,
	NotSubsetEqual: NotSubsetEqual,
	NotSucceeds: NotSucceeds,
	NotSucceedsEqual: NotSucceedsEqual,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
	NotSucceedsTilde: NotSucceedsTilde,
	NotSuperset: NotSuperset,
	NotSupersetEqual: NotSupersetEqual,
	NotTilde: NotTilde,
	NotTildeEqual: NotTildeEqual,
	NotTildeFullEqual: NotTildeFullEqual,
	NotTildeTilde: NotTildeTilde,
	NotVerticalBar: NotVerticalBar,
	Nscr: Nscr,
	Ntild: Ntild,
	Ntilde: Ntilde$1,
	Nu: Nu$1,
	OElig: OElig$1,
	Oacut: Oacut,
	Oacute: Oacute$1,
	Ocir: Ocir,
	Ocirc: Ocirc$1,
	Ocy: Ocy,
	Odblac: Odblac,
	Ofr: Ofr,
	Ograv: Ograv,
	Ograve: Ograve$1,
	Omacr: Omacr,
	Omega: Omega$1,
	Omicron: Omicron$1,
	Oopf: Oopf,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
	OpenCurlyQuote: OpenCurlyQuote,
	Or: Or,
	Oscr: Oscr,
	Oslas: Oslas,
	Oslash: Oslash$1,
	Otild: Otild,
	Otilde: Otilde$1,
	Otimes: Otimes,
	Oum: Oum,
	Ouml: Ouml$1,
	OverBar: OverBar,
	OverBrace: OverBrace,
	OverBracket: OverBracket,
	OverParenthesis: OverParenthesis,
	PartialD: PartialD,
	Pcy: Pcy,
	Pfr: Pfr,
	Phi: Phi$1,
	Pi: Pi$1,
	PlusMinus: PlusMinus,
	Poincareplane: Poincareplane,
	Popf: Popf,
	Pr: Pr,
	Precedes: Precedes,
	PrecedesEqual: PrecedesEqual,
	PrecedesSlantEqual: PrecedesSlantEqual,
	PrecedesTilde: PrecedesTilde,
	Prime: Prime$1,
	Product: Product,
	Proportion: Proportion,
	Proportional: Proportional,
	Pscr: Pscr,
	Psi: Psi$1,
	QUO: QUO,
	QUOT: QUOT,
	Qfr: Qfr,
	Qopf: Qopf,
	Qscr: Qscr,
	RBarr: RBarr,
	RE: RE,
	REG: REG,
	Racute: Racute,
	Rang: Rang,
	Rarr: Rarr,
	Rarrtl: Rarrtl,
	Rcaron: Rcaron,
	Rcedil: Rcedil,
	Rcy: Rcy,
	Re: Re,
	ReverseElement: ReverseElement,
	ReverseEquilibrium: ReverseEquilibrium,
	ReverseUpEquilibrium: ReverseUpEquilibrium,
	Rfr: Rfr,
	Rho: Rho$1,
	RightAngleBracket: RightAngleBracket,
	RightArrow: RightArrow,
	RightArrowBar: RightArrowBar,
	RightArrowLeftArrow: RightArrowLeftArrow,
	RightCeiling: RightCeiling,
	RightDoubleBracket: RightDoubleBracket,
	RightDownTeeVector: RightDownTeeVector,
	RightDownVector: RightDownVector,
	RightDownVectorBar: RightDownVectorBar,
	RightFloor: RightFloor,
	RightTee: RightTee,
	RightTeeArrow: RightTeeArrow,
	RightTeeVector: RightTeeVector,
	RightTriangle: RightTriangle,
	RightTriangleBar: RightTriangleBar,
	RightTriangleEqual: RightTriangleEqual,
	RightUpDownVector: RightUpDownVector,
	RightUpTeeVector: RightUpTeeVector,
	RightUpVector: RightUpVector,
	RightUpVectorBar: RightUpVectorBar,
	RightVector: RightVector,
	RightVectorBar: RightVectorBar,
	Rightarrow: Rightarrow,
	Ropf: Ropf,
	RoundImplies: RoundImplies,
	Rrightarrow: Rrightarrow,
	Rscr: Rscr,
	Rsh: Rsh,
	RuleDelayed: RuleDelayed,
	SHCHcy: SHCHcy,
	SHcy: SHcy,
	SOFTcy: SOFTcy,
	Sacute: Sacute,
	Sc: Sc,
	Scaron: Scaron$1,
	Scedil: Scedil,
	Scirc: Scirc,
	Scy: Scy,
	Sfr: Sfr,
	ShortDownArrow: ShortDownArrow,
	ShortLeftArrow: ShortLeftArrow,
	ShortRightArrow: ShortRightArrow,
	ShortUpArrow: ShortUpArrow,
	Sigma: Sigma$1,
	SmallCircle: SmallCircle,
	Sopf: Sopf,
	Sqrt: Sqrt,
	Square: Square,
	SquareIntersection: SquareIntersection,
	SquareSubset: SquareSubset,
	SquareSubsetEqual: SquareSubsetEqual,
	SquareSuperset: SquareSuperset,
	SquareSupersetEqual: SquareSupersetEqual,
	SquareUnion: SquareUnion,
	Sscr: Sscr,
	Star: Star,
	Sub: Sub,
	Subset: Subset,
	SubsetEqual: SubsetEqual,
	Succeeds: Succeeds,
	SucceedsEqual: SucceedsEqual,
	SucceedsSlantEqual: SucceedsSlantEqual,
	SucceedsTilde: SucceedsTilde,
	SuchThat: SuchThat,
	Sum: Sum,
	Sup: Sup,
	Superset: Superset,
	SupersetEqual: SupersetEqual,
	Supset: Supset,
	THOR: THOR,
	THORN: THORN$1,
	TRADE: TRADE,
	TSHcy: TSHcy,
	TScy: TScy,
	Tab: Tab,
	Tau: Tau$1,
	Tcaron: Tcaron,
	Tcedil: Tcedil,
	Tcy: Tcy,
	Tfr: Tfr,
	Therefore: Therefore,
	Theta: Theta$1,
	ThickSpace: ThickSpace,
	ThinSpace: ThinSpace,
	Tilde: Tilde,
	TildeEqual: TildeEqual,
	TildeFullEqual: TildeFullEqual,
	TildeTilde: TildeTilde,
	Topf: Topf,
	TripleDot: TripleDot,
	Tscr: Tscr,
	Tstrok: Tstrok,
	Uacut: Uacut,
	Uacute: Uacute$1,
	Uarr: Uarr,
	Uarrocir: Uarrocir,
	Ubrcy: Ubrcy,
	Ubreve: Ubreve,
	Ucir: Ucir,
	Ucirc: Ucirc$1,
	Ucy: Ucy,
	Udblac: Udblac,
	Ufr: Ufr,
	Ugrav: Ugrav,
	Ugrave: Ugrave$1,
	Umacr: Umacr,
	UnderBar: UnderBar,
	UnderBrace: UnderBrace,
	UnderBracket: UnderBracket,
	UnderParenthesis: UnderParenthesis,
	Union: Union,
	UnionPlus: UnionPlus,
	Uogon: Uogon,
	Uopf: Uopf,
	UpArrow: UpArrow,
	UpArrowBar: UpArrowBar,
	UpArrowDownArrow: UpArrowDownArrow,
	UpDownArrow: UpDownArrow,
	UpEquilibrium: UpEquilibrium,
	UpTee: UpTee,
	UpTeeArrow: UpTeeArrow,
	Uparrow: Uparrow,
	Updownarrow: Updownarrow,
	UpperLeftArrow: UpperLeftArrow,
	UpperRightArrow: UpperRightArrow,
	Upsi: Upsi,
	Upsilon: Upsilon$1,
	Uring: Uring,
	Uscr: Uscr,
	Utilde: Utilde,
	Uum: Uum,
	Uuml: Uuml$1,
	VDash: VDash,
	Vbar: Vbar,
	Vcy: Vcy,
	Vdash: Vdash,
	Vdashl: Vdashl,
	Vee: Vee,
	Verbar: Verbar,
	Vert: Vert,
	VerticalBar: VerticalBar,
	VerticalLine: VerticalLine,
	VerticalSeparator: VerticalSeparator,
	VerticalTilde: VerticalTilde,
	VeryThinSpace: VeryThinSpace,
	Vfr: Vfr,
	Vopf: Vopf,
	Vscr: Vscr,
	Vvdash: Vvdash,
	Wcirc: Wcirc,
	Wedge: Wedge,
	Wfr: Wfr,
	Wopf: Wopf,
	Wscr: Wscr,
	Xfr: Xfr,
	Xi: Xi$1,
	Xopf: Xopf,
	Xscr: Xscr,
	YAcy: YAcy,
	YIcy: YIcy,
	YUcy: YUcy,
	Yacut: Yacut,
	Yacute: Yacute$1,
	Ycirc: Ycirc,
	Ycy: Ycy,
	Yfr: Yfr,
	Yopf: Yopf,
	Yscr: Yscr,
	Yuml: Yuml$1,
	ZHcy: ZHcy,
	Zacute: Zacute,
	Zcaron: Zcaron,
	Zcy: Zcy,
	Zdot: Zdot,
	ZeroWidthSpace: ZeroWidthSpace,
	Zeta: Zeta$1,
	Zfr: Zfr,
	Zopf: Zopf,
	Zscr: Zscr,
	aacut: aacut,
	aacute: aacute$1,
	abreve: abreve,
	ac: ac,
	acE: acE,
	acd: acd,
	acir: acir,
	acirc: acirc$1,
	acut: acut,
	acute: acute$1,
	acy: acy,
	aeli: aeli,
	aelig: aelig$1,
	af: af,
	afr: afr,
	agrav: agrav,
	agrave: agrave$1,
	alefsym: alefsym$1,
	aleph: aleph,
	alpha: alpha$1,
	amacr: amacr,
	amalg: amalg,
	am: am,
	amp: amp$1,
	and: and$1,
	andand: andand,
	andd: andd,
	andslope: andslope,
	andv: andv,
	ang: ang$1,
	ange: ange,
	angle: angle,
	angmsd: angmsd,
	angmsdaa: angmsdaa,
	angmsdab: angmsdab,
	angmsdac: angmsdac,
	angmsdad: angmsdad,
	angmsdae: angmsdae,
	angmsdaf: angmsdaf,
	angmsdag: angmsdag,
	angmsdah: angmsdah,
	angrt: angrt,
	angrtvb: angrtvb,
	angrtvbd: angrtvbd,
	angsph: angsph,
	angst: angst,
	angzarr: angzarr,
	aogon: aogon,
	aopf: aopf,
	ap: ap,
	apE: apE,
	apacir: apacir,
	ape: ape,
	apid: apid,
	apos: apos,
	approx: approx,
	approxeq: approxeq,
	arin: arin,
	aring: aring$1,
	ascr: ascr,
	ast: ast,
	asymp: asymp$1,
	asympeq: asympeq,
	atild: atild,
	atilde: atilde$1,
	aum: aum,
	auml: auml$1,
	awconint: awconint,
	awint: awint,
	bNot: bNot,
	backcong: backcong,
	backepsilon: backepsilon,
	backprime: backprime,
	backsim: backsim,
	backsimeq: backsimeq,
	barvee: barvee,
	barwed: barwed,
	barwedge: barwedge,
	bbrk: bbrk,
	bbrktbrk: bbrktbrk,
	bcong: bcong,
	bcy: bcy,
	bdquo: bdquo$1,
	becaus: becaus,
	because: because,
	bemptyv: bemptyv,
	bepsi: bepsi,
	bernou: bernou,
	beta: beta$1,
	beth: beth,
	between: between,
	bfr: bfr,
	bigcap: bigcap,
	bigcirc: bigcirc,
	bigcup: bigcup,
	bigodot: bigodot,
	bigoplus: bigoplus,
	bigotimes: bigotimes,
	bigsqcup: bigsqcup,
	bigstar: bigstar,
	bigtriangledown: bigtriangledown,
	bigtriangleup: bigtriangleup,
	biguplus: biguplus,
	bigvee: bigvee,
	bigwedge: bigwedge,
	bkarow: bkarow,
	blacklozenge: blacklozenge,
	blacksquare: blacksquare,
	blacktriangle: blacktriangle,
	blacktriangledown: blacktriangledown,
	blacktriangleleft: blacktriangleleft,
	blacktriangleright: blacktriangleright,
	blank: blank,
	blk12: blk12,
	blk14: blk14,
	blk34: blk34,
	block: block,
	bne: bne,
	bnequiv: bnequiv,
	bnot: bnot,
	bopf: bopf,
	bot: bot,
	bottom: bottom,
	bowtie: bowtie,
	boxDL: boxDL,
	boxDR: boxDR,
	boxDl: boxDl,
	boxDr: boxDr,
	boxH: boxH,
	boxHD: boxHD,
	boxHU: boxHU,
	boxHd: boxHd,
	boxHu: boxHu,
	boxUL: boxUL,
	boxUR: boxUR,
	boxUl: boxUl,
	boxUr: boxUr,
	boxV: boxV,
	boxVH: boxVH,
	boxVL: boxVL,
	boxVR: boxVR,
	boxVh: boxVh,
	boxVl: boxVl,
	boxVr: boxVr,
	boxbox: boxbox,
	boxdL: boxdL,
	boxdR: boxdR,
	boxdl: boxdl,
	boxdr: boxdr,
	boxh: boxh,
	boxhD: boxhD,
	boxhU: boxhU,
	boxhd: boxhd,
	boxhu: boxhu,
	boxminus: boxminus,
	boxplus: boxplus,
	boxtimes: boxtimes,
	boxuL: boxuL,
	boxuR: boxuR,
	boxul: boxul,
	boxur: boxur,
	boxv: boxv,
	boxvH: boxvH,
	boxvL: boxvL,
	boxvR: boxvR,
	boxvh: boxvh,
	boxvl: boxvl,
	boxvr: boxvr,
	bprime: bprime,
	breve: breve,
	brvba: brvba,
	brvbar: brvbar$1,
	bscr: bscr,
	bsemi: bsemi,
	bsim: bsim,
	bsime: bsime,
	bsol: bsol,
	bsolb: bsolb,
	bsolhsub: bsolhsub,
	bull: bull$1,
	bullet: bullet,
	bump: bump,
	bumpE: bumpE,
	bumpe: bumpe,
	bumpeq: bumpeq,
	cacute: cacute,
	cap: cap$2,
	capand: capand,
	capbrcup: capbrcup,
	capcap: capcap,
	capcup: capcup,
	capdot: capdot,
	caps: caps,
	caret: caret,
	caron: caron,
	ccaps: ccaps,
	ccaron: ccaron,
	ccedi: ccedi,
	ccedil: ccedil$1,
	ccirc: ccirc,
	ccups: ccups,
	ccupssm: ccupssm,
	cdot: cdot,
	cedi: cedi,
	cedil: cedil$1,
	cemptyv: cemptyv,
	cen: cen,
	cent: cent$1,
	centerdot: centerdot,
	cfr: cfr,
	chcy: chcy,
	check: check,
	checkmark: checkmark,
	chi: chi$1,
	cir: cir,
	cirE: cirE,
	circ: circ$1,
	circeq: circeq,
	circlearrowleft: circlearrowleft,
	circlearrowright: circlearrowright,
	circledR: circledR,
	circledS: circledS,
	circledast: circledast,
	circledcirc: circledcirc,
	circleddash: circleddash,
	cire: cire,
	cirfnint: cirfnint,
	cirmid: cirmid,
	cirscir: cirscir,
	clubs: clubs$1,
	clubsuit: clubsuit,
	colon: colon$3,
	colone: colone,
	coloneq: coloneq,
	comma: comma$2,
	commat: commat,
	comp: comp,
	compfn: compfn,
	complement: complement,
	complexes: complexes,
	cong: cong$1,
	congdot: congdot,
	conint: conint,
	copf: copf,
	coprod: coprod,
	cop: cop,
	copy: copy$1,
	copysr: copysr,
	crarr: crarr$1,
	cross: cross,
	cscr: cscr,
	csub: csub,
	csube: csube,
	csup: csup,
	csupe: csupe,
	ctdot: ctdot,
	cudarrl: cudarrl,
	cudarrr: cudarrr,
	cuepr: cuepr,
	cuesc: cuesc,
	cularr: cularr,
	cularrp: cularrp,
	cup: cup$1,
	cupbrcap: cupbrcap,
	cupcap: cupcap,
	cupcup: cupcup,
	cupdot: cupdot,
	cupor: cupor,
	cups: cups,
	curarr: curarr,
	curarrm: curarrm,
	curlyeqprec: curlyeqprec,
	curlyeqsucc: curlyeqsucc,
	curlyvee: curlyvee,
	curlywedge: curlywedge,
	curre: curre,
	curren: curren$1,
	curvearrowleft: curvearrowleft,
	curvearrowright: curvearrowright,
	cuvee: cuvee,
	cuwed: cuwed,
	cwconint: cwconint,
	cwint: cwint,
	cylcty: cylcty,
	dArr: dArr$1,
	dHar: dHar,
	dagger: dagger$1,
	daleth: daleth,
	darr: darr$1,
	dash: dash$8,
	dashv: dashv,
	dbkarow: dbkarow,
	dblac: dblac,
	dcaron: dcaron,
	dcy: dcy,
	dd: dd$1,
	ddagger: ddagger,
	ddarr: ddarr,
	ddotseq: ddotseq,
	de: de,
	deg: deg$1,
	delta: delta$1,
	demptyv: demptyv,
	dfisht: dfisht,
	dfr: dfr,
	dharl: dharl,
	dharr: dharr,
	diam: diam,
	diamond: diamond,
	diamondsuit: diamondsuit,
	diams: diams$1,
	die: die,
	digamma: digamma,
	disin: disin,
	div: div,
	divid: divid,
	divide: divide$1,
	divideontimes: divideontimes,
	divonx: divonx,
	djcy: djcy,
	dlcorn: dlcorn,
	dlcrop: dlcrop,
	dollar: dollar,
	dopf: dopf,
	dot: dot$4,
	doteq: doteq,
	doteqdot: doteqdot,
	dotminus: dotminus,
	dotplus: dotplus,
	dotsquare: dotsquare,
	doublebarwedge: doublebarwedge,
	downarrow: downarrow,
	downdownarrows: downdownarrows,
	downharpoonleft: downharpoonleft,
	downharpoonright: downharpoonright,
	drbkarow: drbkarow,
	drcorn: drcorn,
	drcrop: drcrop,
	dscr: dscr,
	dscy: dscy,
	dsol: dsol,
	dstrok: dstrok,
	dtdot: dtdot,
	dtri: dtri,
	dtrif: dtrif,
	duarr: duarr,
	duhar: duhar,
	dwangle: dwangle,
	dzcy: dzcy,
	dzigrarr: dzigrarr,
	eDDot: eDDot,
	eDot: eDot,
	eacut: eacut,
	eacute: eacute$1,
	easter: easter,
	ecaron: ecaron,
	ecir: ecir,
	ecirc: ecirc$1,
	ecolon: ecolon,
	ecy: ecy,
	edot: edot,
	ee: ee,
	efDot: efDot,
	efr: efr,
	eg: eg,
	egrav: egrav,
	egrave: egrave$1,
	egs: egs,
	egsdot: egsdot,
	el: el,
	elinters: elinters,
	ell: ell,
	els: els,
	elsdot: elsdot,
	emacr: emacr,
	empty: empty$3,
	emptyset: emptyset,
	emptyv: emptyv,
	emsp13: emsp13,
	emsp14: emsp14,
	emsp: emsp$1,
	eng: eng,
	ensp: ensp$1,
	eogon: eogon,
	eopf: eopf,
	epar: epar,
	eparsl: eparsl,
	eplus: eplus,
	epsi: epsi,
	epsilon: epsilon$1,
	epsiv: epsiv,
	eqcirc: eqcirc,
	eqcolon: eqcolon,
	eqsim: eqsim,
	eqslantgtr: eqslantgtr,
	eqslantless: eqslantless,
	equals: equals,
	equest: equest,
	equiv: equiv$1,
	equivDD: equivDD,
	eqvparsl: eqvparsl,
	erDot: erDot,
	erarr: erarr,
	escr: escr,
	esdot: esdot,
	esim: esim,
	eta: eta$1,
	et: et,
	eth: eth$1,
	eum: eum,
	euml: euml$1,
	euro: euro$1,
	excl: excl,
	exist: exist$1,
	expectation: expectation,
	exponentiale: exponentiale,
	fallingdotseq: fallingdotseq,
	fcy: fcy,
	female: female,
	ffilig: ffilig,
	fflig: fflig,
	ffllig: ffllig,
	ffr: ffr,
	filig: filig,
	fjlig: fjlig,
	flat: flat,
	fllig: fllig,
	fltns: fltns,
	fnof: fnof$1,
	fopf: fopf,
	forall: forall$1,
	fork: fork,
	forkv: forkv,
	fpartint: fpartint,
	frac1: frac1,
	frac12: frac12$1,
	frac13: frac13,
	frac14: frac14$1,
	frac15: frac15,
	frac16: frac16,
	frac18: frac18,
	frac23: frac23,
	frac25: frac25,
	frac3: frac3,
	frac34: frac34$1,
	frac35: frac35,
	frac38: frac38,
	frac45: frac45,
	frac56: frac56,
	frac58: frac58,
	frac78: frac78,
	frasl: frasl$1,
	frown: frown,
	fscr: fscr,
	gE: gE,
	gEl: gEl,
	gacute: gacute,
	gamma: gamma$1,
	gammad: gammad,
	gap: gap,
	gbreve: gbreve,
	gcirc: gcirc,
	gcy: gcy,
	gdot: gdot,
	ge: ge$1,
	gel: gel,
	geq: geq,
	geqq: geqq,
	geqslant: geqslant,
	ges: ges,
	gescc: gescc,
	gesdot: gesdot,
	gesdoto: gesdoto,
	gesdotol: gesdotol,
	gesl: gesl,
	gesles: gesles,
	gfr: gfr,
	gg: gg,
	ggg: ggg,
	gimel: gimel,
	gjcy: gjcy,
	gl: gl,
	glE: glE,
	gla: gla,
	glj: glj,
	gnE: gnE,
	gnap: gnap,
	gnapprox: gnapprox,
	gne: gne,
	gneq: gneq,
	gneqq: gneqq,
	gnsim: gnsim,
	gopf: gopf,
	grave: grave,
	gscr: gscr,
	gsim: gsim,
	gsime: gsime,
	gsiml: gsiml,
	g: g,
	gt: gt$1,
	gtcc: gtcc,
	gtcir: gtcir,
	gtdot: gtdot,
	gtlPar: gtlPar,
	gtquest: gtquest,
	gtrapprox: gtrapprox,
	gtrarr: gtrarr,
	gtrdot: gtrdot,
	gtreqless: gtreqless,
	gtreqqless: gtreqqless,
	gtrless: gtrless,
	gtrsim: gtrsim,
	gvertneqq: gvertneqq,
	gvnE: gvnE,
	hArr: hArr$1,
	hairsp: hairsp,
	half: half,
	hamilt: hamilt,
	hardcy: hardcy,
	harr: harr$1,
	harrcir: harrcir,
	harrw: harrw,
	hbar: hbar,
	hcirc: hcirc,
	hearts: hearts$1,
	heartsuit: heartsuit,
	hellip: hellip$1,
	hercon: hercon,
	hfr: hfr,
	hksearow: hksearow,
	hkswarow: hkswarow,
	hoarr: hoarr,
	homtht: homtht,
	hookleftarrow: hookleftarrow,
	hookrightarrow: hookrightarrow,
	hopf: hopf,
	horbar: horbar,
	hscr: hscr,
	hslash: hslash,
	hstrok: hstrok,
	hybull: hybull,
	hyphen: hyphen,
	iacut: iacut,
	iacute: iacute$1,
	ic: ic,
	icir: icir,
	icirc: icirc$1,
	icy: icy,
	iecy: iecy,
	iexc: iexc,
	iexcl: iexcl$1,
	iff: iff,
	ifr: ifr,
	igrav: igrav,
	igrave: igrave$1,
	ii: ii,
	iiiint: iiiint,
	iiint: iiint,
	iinfin: iinfin,
	iiota: iiota,
	ijlig: ijlig,
	imacr: imacr,
	image: image$3,
	imagline: imagline,
	imagpart: imagpart,
	imath: imath,
	imof: imof,
	imped: imped,
	"in": "∈",
	incare: incare,
	infin: infin$1,
	infintie: infintie,
	inodot: inodot,
	int: int$1,
	intcal: intcal,
	integers: integers,
	intercal: intercal,
	intlarhk: intlarhk,
	intprod: intprod,
	iocy: iocy,
	iogon: iogon,
	iopf: iopf,
	iota: iota$1,
	iprod: iprod,
	iques: iques,
	iquest: iquest$1,
	iscr: iscr,
	isin: isin$1,
	isinE: isinE,
	isindot: isindot,
	isins: isins,
	isinsv: isinsv,
	isinv: isinv,
	it: it,
	itilde: itilde,
	iukcy: iukcy,
	ium: ium,
	iuml: iuml$1,
	jcirc: jcirc,
	jcy: jcy,
	jfr: jfr,
	jmath: jmath,
	jopf: jopf,
	jscr: jscr,
	jsercy: jsercy,
	jukcy: jukcy,
	kappa: kappa$1,
	kappav: kappav,
	kcedil: kcedil,
	kcy: kcy,
	kfr: kfr,
	kgreen: kgreen,
	khcy: khcy,
	kjcy: kjcy,
	kopf: kopf,
	kscr: kscr,
	lAarr: lAarr,
	lArr: lArr$1,
	lAtail: lAtail,
	lBarr: lBarr,
	lE: lE,
	lEg: lEg,
	lHar: lHar,
	lacute: lacute,
	laemptyv: laemptyv,
	lagran: lagran,
	lambda: lambda$1,
	lang: lang$1,
	langd: langd,
	langle: langle,
	lap: lap,
	laqu: laqu,
	laquo: laquo$1,
	larr: larr$1,
	larrb: larrb,
	larrbfs: larrbfs,
	larrfs: larrfs,
	larrhk: larrhk,
	larrlp: larrlp,
	larrpl: larrpl,
	larrsim: larrsim,
	larrtl: larrtl,
	lat: lat,
	latail: latail,
	late: late,
	lates: lates,
	lbarr: lbarr,
	lbbrk: lbbrk,
	lbrace: lbrace,
	lbrack: lbrack,
	lbrke: lbrke,
	lbrksld: lbrksld,
	lbrkslu: lbrkslu,
	lcaron: lcaron,
	lcedil: lcedil,
	lceil: lceil$1,
	lcub: lcub,
	lcy: lcy,
	ldca: ldca,
	ldquo: ldquo$1,
	ldquor: ldquor,
	ldrdhar: ldrdhar,
	ldrushar: ldrushar,
	ldsh: ldsh,
	le: le$1,
	leftarrow: leftarrow,
	leftarrowtail: leftarrowtail,
	leftharpoondown: leftharpoondown,
	leftharpoonup: leftharpoonup,
	leftleftarrows: leftleftarrows,
	leftrightarrow: leftrightarrow,
	leftrightarrows: leftrightarrows,
	leftrightharpoons: leftrightharpoons,
	leftrightsquigarrow: leftrightsquigarrow,
	leftthreetimes: leftthreetimes,
	leg: leg,
	leq: leq,
	leqq: leqq,
	leqslant: leqslant,
	les: les,
	lescc: lescc,
	lesdot: lesdot,
	lesdoto: lesdoto,
	lesdotor: lesdotor,
	lesg: lesg,
	lesges: lesges,
	lessapprox: lessapprox,
	lessdot: lessdot,
	lesseqgtr: lesseqgtr,
	lesseqqgtr: lesseqqgtr,
	lessgtr: lessgtr,
	lesssim: lesssim,
	lfisht: lfisht,
	lfloor: lfloor$1,
	lfr: lfr,
	lg: lg,
	lgE: lgE,
	lhard: lhard,
	lharu: lharu,
	lharul: lharul,
	lhblk: lhblk,
	ljcy: ljcy,
	ll: ll,
	llarr: llarr,
	llcorner: llcorner,
	llhard: llhard,
	lltri: lltri,
	lmidot: lmidot,
	lmoust: lmoust,
	lmoustache: lmoustache,
	lnE: lnE,
	lnap: lnap,
	lnapprox: lnapprox,
	lne: lne,
	lneq: lneq,
	lneqq: lneqq,
	lnsim: lnsim,
	loang: loang,
	loarr: loarr,
	lobrk: lobrk,
	longleftarrow: longleftarrow,
	longleftrightarrow: longleftrightarrow,
	longmapsto: longmapsto,
	longrightarrow: longrightarrow,
	looparrowleft: looparrowleft,
	looparrowright: looparrowright,
	lopar: lopar,
	lopf: lopf,
	loplus: loplus,
	lotimes: lotimes,
	lowast: lowast$1,
	lowbar: lowbar,
	loz: loz$1,
	lozenge: lozenge,
	lozf: lozf,
	lpar: lpar,
	lparlt: lparlt,
	lrarr: lrarr,
	lrcorner: lrcorner,
	lrhar: lrhar,
	lrhard: lrhard,
	lrm: lrm$1,
	lrtri: lrtri,
	lsaquo: lsaquo$1,
	lscr: lscr,
	lsh: lsh,
	lsim: lsim,
	lsime: lsime,
	lsimg: lsimg,
	lsqb: lsqb,
	lsquo: lsquo$1,
	lsquor: lsquor,
	lstrok: lstrok,
	l: l,
	lt: lt$1,
	ltcc: ltcc,
	ltcir: ltcir,
	ltdot: ltdot,
	lthree: lthree,
	ltimes: ltimes,
	ltlarr: ltlarr,
	ltquest: ltquest,
	ltrPar: ltrPar,
	ltri: ltri,
	ltrie: ltrie,
	ltrif: ltrif,
	lurdshar: lurdshar,
	luruhar: luruhar,
	lvertneqq: lvertneqq,
	lvnE: lvnE,
	mDDot: mDDot,
	mac: mac,
	macr: macr$1,
	male: male,
	malt: malt,
	maltese: maltese,
	map: map$1,
	mapsto: mapsto,
	mapstodown: mapstodown,
	mapstoleft: mapstoleft,
	mapstoup: mapstoup,
	marker: marker,
	mcomma: mcomma,
	mcy: mcy,
	mdash: mdash$1,
	measuredangle: measuredangle,
	mfr: mfr,
	mho: mho,
	micr: micr,
	micro: micro$1,
	mid: mid,
	midast: midast,
	midcir: midcir,
	middo: middo,
	middot: middot$1,
	minus: minus$1,
	minusb: minusb,
	minusd: minusd,
	minusdu: minusdu,
	mlcp: mlcp,
	mldr: mldr,
	mnplus: mnplus,
	models: models,
	mopf: mopf,
	mp: mp,
	mscr: mscr,
	mstpos: mstpos,
	mu: mu$1,
	multimap: multimap,
	mumap: mumap,
	nGg: nGg,
	nGt: nGt,
	nGtv: nGtv,
	nLeftarrow: nLeftarrow,
	nLeftrightarrow: nLeftrightarrow,
	nLl: nLl,
	nLt: nLt,
	nLtv: nLtv,
	nRightarrow: nRightarrow,
	nVDash: nVDash,
	nVdash: nVdash,
	nabla: nabla$1,
	nacute: nacute,
	nang: nang,
	nap: nap,
	napE: napE,
	napid: napid,
	napos: napos,
	napprox: napprox,
	natur: natur,
	natural: natural,
	naturals: naturals,
	nbs: nbs,
	nbsp: nbsp$1,
	nbump: nbump,
	nbumpe: nbumpe,
	ncap: ncap,
	ncaron: ncaron,
	ncedil: ncedil,
	ncong: ncong,
	ncongdot: ncongdot,
	ncup: ncup,
	ncy: ncy,
	ndash: ndash$1,
	ne: ne$1,
	neArr: neArr,
	nearhk: nearhk,
	nearr: nearr,
	nearrow: nearrow,
	nedot: nedot,
	nequiv: nequiv,
	nesear: nesear,
	nesim: nesim,
	nexist: nexist,
	nexists: nexists,
	nfr: nfr,
	ngE: ngE,
	nge: nge,
	ngeq: ngeq,
	ngeqq: ngeqq,
	ngeqslant: ngeqslant,
	nges: nges,
	ngsim: ngsim,
	ngt: ngt,
	ngtr: ngtr,
	nhArr: nhArr,
	nharr: nharr,
	nhpar: nhpar,
	ni: ni$1,
	nis: nis,
	nisd: nisd,
	niv: niv,
	njcy: njcy,
	nlArr: nlArr,
	nlE: nlE,
	nlarr: nlarr,
	nldr: nldr,
	nle: nle,
	nleftarrow: nleftarrow,
	nleftrightarrow: nleftrightarrow,
	nleq: nleq,
	nleqq: nleqq,
	nleqslant: nleqslant,
	nles: nles,
	nless: nless,
	nlsim: nlsim,
	nlt: nlt,
	nltri: nltri,
	nltrie: nltrie,
	nmid: nmid,
	nopf: nopf,
	no: no,
	not: not$1,
	notin: notin$1,
	notinE: notinE,
	notindot: notindot,
	notinva: notinva,
	notinvb: notinvb,
	notinvc: notinvc,
	notni: notni,
	notniva: notniva,
	notnivb: notnivb,
	notnivc: notnivc,
	npar: npar,
	nparallel: nparallel,
	nparsl: nparsl,
	npart: npart,
	npolint: npolint,
	npr: npr,
	nprcue: nprcue,
	npre: npre,
	nprec: nprec,
	npreceq: npreceq,
	nrArr: nrArr,
	nrarr: nrarr,
	nrarrc: nrarrc,
	nrarrw: nrarrw,
	nrightarrow: nrightarrow,
	nrtri: nrtri,
	nrtrie: nrtrie,
	nsc: nsc,
	nsccue: nsccue,
	nsce: nsce,
	nscr: nscr,
	nshortmid: nshortmid,
	nshortparallel: nshortparallel,
	nsim: nsim,
	nsime: nsime,
	nsimeq: nsimeq,
	nsmid: nsmid,
	nspar: nspar,
	nsqsube: nsqsube,
	nsqsupe: nsqsupe,
	nsub: nsub$1,
	nsubE: nsubE,
	nsube: nsube,
	nsubset: nsubset,
	nsubseteq: nsubseteq,
	nsubseteqq: nsubseteqq,
	nsucc: nsucc,
	nsucceq: nsucceq,
	nsup: nsup,
	nsupE: nsupE,
	nsupe: nsupe,
	nsupset: nsupset,
	nsupseteq: nsupseteq,
	nsupseteqq: nsupseteqq,
	ntgl: ntgl,
	ntild: ntild,
	ntilde: ntilde$1,
	ntlg: ntlg,
	ntriangleleft: ntriangleleft,
	ntrianglelefteq: ntrianglelefteq,
	ntriangleright: ntriangleright,
	ntrianglerighteq: ntrianglerighteq,
	nu: nu$1,
	num: num,
	numero: numero,
	numsp: numsp,
	nvDash: nvDash,
	nvHarr: nvHarr,
	nvap: nvap,
	nvdash: nvdash,
	nvge: nvge,
	nvgt: nvgt,
	nvinfin: nvinfin,
	nvlArr: nvlArr,
	nvle: nvle,
	nvlt: nvlt,
	nvltrie: nvltrie,
	nvrArr: nvrArr,
	nvrtrie: nvrtrie,
	nvsim: nvsim,
	nwArr: nwArr,
	nwarhk: nwarhk,
	nwarr: nwarr,
	nwarrow: nwarrow,
	nwnear: nwnear,
	oS: oS,
	oacut: oacut,
	oacute: oacute$1,
	oast: oast,
	ocir: ocir,
	ocirc: ocirc$1,
	ocy: ocy,
	odash: odash,
	odblac: odblac,
	odiv: odiv,
	odot: odot,
	odsold: odsold,
	oelig: oelig$1,
	ofcir: ofcir,
	ofr: ofr,
	ogon: ogon,
	ograv: ograv,
	ograve: ograve$1,
	ogt: ogt,
	ohbar: ohbar,
	ohm: ohm,
	oint: oint,
	olarr: olarr,
	olcir: olcir,
	olcross: olcross,
	oline: oline$1,
	olt: olt,
	omacr: omacr,
	omega: omega$1,
	omicron: omicron$1,
	omid: omid,
	ominus: ominus,
	oopf: oopf,
	opar: opar,
	operp: operp,
	oplus: oplus$1,
	or: or$1,
	orarr: orarr,
	ord: ord,
	order: order,
	orderof: orderof,
	ordf: ordf$1,
	ordm: ordm$1,
	origof: origof,
	oror: oror,
	orslope: orslope,
	orv: orv,
	oscr: oscr,
	oslas: oslas,
	oslash: oslash$1,
	osol: osol,
	otild: otild,
	otilde: otilde$1,
	otimes: otimes$1,
	otimesas: otimesas,
	oum: oum,
	ouml: ouml$1,
	ovbar: ovbar,
	par: par,
	para: para$1,
	parallel: parallel,
	parsim: parsim,
	parsl: parsl,
	part: part$1,
	pcy: pcy,
	percnt: percnt,
	period: period,
	permil: permil$1,
	perp: perp$1,
	pertenk: pertenk,
	pfr: pfr,
	phi: phi$1,
	phiv: phiv,
	phmmat: phmmat,
	phone: phone,
	pi: pi$1,
	pitchfork: pitchfork,
	piv: piv$1,
	planck: planck,
	planckh: planckh,
	plankv: plankv,
	plus: plus,
	plusacir: plusacir,
	plusb: plusb,
	pluscir: pluscir,
	plusdo: plusdo,
	plusdu: plusdu,
	pluse: pluse,
	plusm: plusm,
	plusmn: plusmn$1,
	plussim: plussim,
	plustwo: plustwo,
	pm: pm,
	pointint: pointint,
	popf: popf,
	poun: poun,
	pound: pound$1,
	pr: pr,
	prE: prE,
	prap: prap,
	prcue: prcue,
	pre: pre,
	prec: prec,
	precapprox: precapprox,
	preccurlyeq: preccurlyeq,
	preceq: preceq,
	precnapprox: precnapprox,
	precneqq: precneqq,
	precnsim: precnsim,
	precsim: precsim,
	prime: prime$1,
	primes: primes,
	prnE: prnE,
	prnap: prnap,
	prnsim: prnsim,
	prod: prod$1,
	profalar: profalar,
	profline: profline,
	profsurf: profsurf,
	prop: prop$1,
	propto: propto,
	prsim: prsim,
	prurel: prurel,
	pscr: pscr,
	psi: psi$1,
	puncsp: puncsp,
	qfr: qfr,
	qint: qint,
	qopf: qopf,
	qprime: qprime,
	qscr: qscr,
	quaternions: quaternions,
	quatint: quatint,
	quest: quest,
	questeq: questeq,
	quo: quo,
	quot: quot$1,
	rAarr: rAarr,
	rArr: rArr$1,
	rAtail: rAtail,
	rBarr: rBarr,
	rHar: rHar,
	race: race,
	racute: racute,
	radic: radic$1,
	raemptyv: raemptyv,
	rang: rang$1,
	rangd: rangd,
	range: range,
	rangle: rangle,
	raqu: raqu,
	raquo: raquo$1,
	rarr: rarr$1,
	rarrap: rarrap,
	rarrb: rarrb,
	rarrbfs: rarrbfs,
	rarrc: rarrc,
	rarrfs: rarrfs,
	rarrhk: rarrhk,
	rarrlp: rarrlp,
	rarrpl: rarrpl,
	rarrsim: rarrsim,
	rarrtl: rarrtl,
	rarrw: rarrw,
	ratail: ratail,
	ratio: ratio,
	rationals: rationals,
	rbarr: rbarr,
	rbbrk: rbbrk,
	rbrace: rbrace,
	rbrack: rbrack,
	rbrke: rbrke,
	rbrksld: rbrksld,
	rbrkslu: rbrkslu,
	rcaron: rcaron,
	rcedil: rcedil,
	rceil: rceil$1,
	rcub: rcub,
	rcy: rcy,
	rdca: rdca,
	rdldhar: rdldhar,
	rdquo: rdquo$1,
	rdquor: rdquor,
	rdsh: rdsh,
	real: real$1,
	realine: realine,
	realpart: realpart,
	reals: reals,
	rect: rect,
	re: re$3,
	reg: reg$1,
	rfisht: rfisht,
	rfloor: rfloor$1,
	rfr: rfr,
	rhard: rhard,
	rharu: rharu,
	rharul: rharul,
	rho: rho$1,
	rhov: rhov,
	rightarrow: rightarrow,
	rightarrowtail: rightarrowtail,
	rightharpoondown: rightharpoondown,
	rightharpoonup: rightharpoonup,
	rightleftarrows: rightleftarrows,
	rightleftharpoons: rightleftharpoons,
	rightrightarrows: rightrightarrows,
	rightsquigarrow: rightsquigarrow,
	rightthreetimes: rightthreetimes,
	ring: ring,
	risingdotseq: risingdotseq,
	rlarr: rlarr,
	rlhar: rlhar,
	rlm: rlm$1,
	rmoust: rmoust,
	rmoustache: rmoustache,
	rnmid: rnmid,
	roang: roang,
	roarr: roarr,
	robrk: robrk,
	ropar: ropar,
	ropf: ropf,
	roplus: roplus,
	rotimes: rotimes,
	rpar: rpar,
	rpargt: rpargt,
	rppolint: rppolint,
	rrarr: rrarr,
	rsaquo: rsaquo$1,
	rscr: rscr,
	rsh: rsh,
	rsqb: rsqb,
	rsquo: rsquo$1,
	rsquor: rsquor,
	rthree: rthree,
	rtimes: rtimes,
	rtri: rtri,
	rtrie: rtrie,
	rtrif: rtrif,
	rtriltri: rtriltri,
	ruluhar: ruluhar,
	rx: rx,
	sacute: sacute,
	sbquo: sbquo$1,
	sc: sc,
	scE: scE,
	scap: scap,
	scaron: scaron$1,
	sccue: sccue,
	sce: sce,
	scedil: scedil,
	scirc: scirc,
	scnE: scnE,
	scnap: scnap,
	scnsim: scnsim,
	scpolint: scpolint,
	scsim: scsim,
	scy: scy,
	sdot: sdot$1,
	sdotb: sdotb,
	sdote: sdote,
	seArr: seArr,
	searhk: searhk,
	searr: searr,
	searrow: searrow,
	sec: sec,
	sect: sect$1,
	semi: semi,
	seswar: seswar,
	setminus: setminus,
	setmn: setmn,
	sext: sext,
	sfr: sfr,
	sfrown: sfrown,
	sharp: sharp,
	shchcy: shchcy,
	shcy: shcy,
	shortmid: shortmid,
	shortparallel: shortparallel,
	sh: sh,
	shy: shy$1,
	sigma: sigma$1,
	sigmaf: sigmaf$1,
	sigmav: sigmav,
	sim: sim$1,
	simdot: simdot,
	sime: sime,
	simeq: simeq,
	simg: simg,
	simgE: simgE,
	siml: siml,
	simlE: simlE,
	simne: simne,
	simplus: simplus,
	simrarr: simrarr,
	slarr: slarr,
	smallsetminus: smallsetminus,
	smashp: smashp,
	smeparsl: smeparsl,
	smid: smid,
	smile: smile,
	smt: smt,
	smte: smte,
	smtes: smtes,
	softcy: softcy,
	sol: sol,
	solb: solb,
	solbar: solbar,
	sopf: sopf,
	spades: spades$1,
	spadesuit: spadesuit,
	spar: spar,
	sqcap: sqcap,
	sqcaps: sqcaps,
	sqcup: sqcup,
	sqcups: sqcups,
	sqsub: sqsub,
	sqsube: sqsube,
	sqsubset: sqsubset,
	sqsubseteq: sqsubseteq,
	sqsup: sqsup,
	sqsupe: sqsupe,
	sqsupset: sqsupset,
	sqsupseteq: sqsupseteq,
	squ: squ,
	square: square,
	squarf: squarf,
	squf: squf,
	srarr: srarr,
	sscr: sscr,
	ssetmn: ssetmn,
	ssmile: ssmile,
	sstarf: sstarf,
	star: star,
	starf: starf,
	straightepsilon: straightepsilon,
	straightphi: straightphi,
	strns: strns,
	sub: sub$1,
	subE: subE,
	subdot: subdot,
	sube: sube$1,
	subedot: subedot,
	submult: submult,
	subnE: subnE,
	subne: subne,
	subplus: subplus,
	subrarr: subrarr,
	subset: subset,
	subseteq: subseteq,
	subseteqq: subseteqq,
	subsetneq: subsetneq,
	subsetneqq: subsetneqq,
	subsim: subsim,
	subsub: subsub,
	subsup: subsup,
	succ: succ,
	succapprox: succapprox,
	succcurlyeq: succcurlyeq,
	succeq: succeq,
	succnapprox: succnapprox,
	succneqq: succneqq,
	succnsim: succnsim,
	succsim: succsim,
	sum: sum$1,
	sung: sung,
	sup: sup$1,
	sup1: sup1$1,
	sup2: sup2$1,
	sup3: sup3$1,
	supE: supE,
	supdot: supdot,
	supdsub: supdsub,
	supe: supe$1,
	supedot: supedot,
	suphsol: suphsol,
	suphsub: suphsub,
	suplarr: suplarr,
	supmult: supmult,
	supnE: supnE,
	supne: supne,
	supplus: supplus,
	supset: supset,
	supseteq: supseteq,
	supseteqq: supseteqq,
	supsetneq: supsetneq,
	supsetneqq: supsetneqq,
	supsim: supsim,
	supsub: supsub,
	supsup: supsup,
	swArr: swArr,
	swarhk: swarhk,
	swarr: swarr,
	swarrow: swarrow,
	swnwar: swnwar,
	szli: szli,
	szlig: szlig$1,
	target: target,
	tau: tau$1,
	tbrk: tbrk,
	tcaron: tcaron,
	tcedil: tcedil,
	tcy: tcy,
	tdot: tdot,
	telrec: telrec,
	tfr: tfr,
	there4: there4$1,
	therefore: therefore,
	theta: theta$1,
	thetasym: thetasym$1,
	thetav: thetav,
	thickapprox: thickapprox,
	thicksim: thicksim,
	thinsp: thinsp$1,
	thkap: thkap,
	thksim: thksim,
	thor: thor,
	thorn: thorn$1,
	tilde: tilde$4,
	time: time,
	times: times$1,
	timesb: timesb,
	timesbar: timesbar,
	timesd: timesd,
	tint: tint,
	toea: toea,
	top: top,
	topbot: topbot,
	topcir: topcir,
	topf: topf,
	topfork: topfork,
	tosa: tosa,
	tprime: tprime,
	trade: trade$1,
	triangle: triangle,
	triangledown: triangledown,
	triangleleft: triangleleft,
	trianglelefteq: trianglelefteq,
	triangleq: triangleq,
	triangleright: triangleright,
	trianglerighteq: trianglerighteq,
	tridot: tridot,
	trie: trie,
	triminus: triminus,
	triplus: triplus,
	trisb: trisb,
	tritime: tritime,
	trpezium: trpezium,
	tscr: tscr,
	tscy: tscy,
	tshcy: tshcy,
	tstrok: tstrok,
	twixt: twixt,
	twoheadleftarrow: twoheadleftarrow,
	twoheadrightarrow: twoheadrightarrow,
	uArr: uArr$1,
	uHar: uHar,
	uacut: uacut,
	uacute: uacute$1,
	uarr: uarr$1,
	ubrcy: ubrcy,
	ubreve: ubreve,
	ucir: ucir,
	ucirc: ucirc$1,
	ucy: ucy,
	udarr: udarr,
	udblac: udblac,
	udhar: udhar,
	ufisht: ufisht,
	ufr: ufr,
	ugrav: ugrav,
	ugrave: ugrave$1,
	uharl: uharl,
	uharr: uharr,
	uhblk: uhblk,
	ulcorn: ulcorn,
	ulcorner: ulcorner,
	ulcrop: ulcrop,
	ultri: ultri,
	umacr: umacr,
	um: um,
	uml: uml$1,
	uogon: uogon,
	uopf: uopf,
	uparrow: uparrow,
	updownarrow: updownarrow,
	upharpoonleft: upharpoonleft,
	upharpoonright: upharpoonright,
	uplus: uplus,
	upsi: upsi,
	upsih: upsih$1,
	upsilon: upsilon$1,
	upuparrows: upuparrows,
	urcorn: urcorn,
	urcorner: urcorner,
	urcrop: urcrop,
	uring: uring,
	urtri: urtri,
	uscr: uscr,
	utdot: utdot,
	utilde: utilde,
	utri: utri,
	utrif: utrif,
	uuarr: uuarr,
	uum: uum,
	uuml: uuml$1,
	uwangle: uwangle,
	vArr: vArr,
	vBar: vBar,
	vBarv: vBarv,
	vDash: vDash,
	vangrt: vangrt,
	varepsilon: varepsilon,
	varkappa: varkappa,
	varnothing: varnothing,
	varphi: varphi,
	varpi: varpi,
	varpropto: varpropto,
	varr: varr,
	varrho: varrho,
	varsigma: varsigma,
	varsubsetneq: varsubsetneq,
	varsubsetneqq: varsubsetneqq,
	varsupsetneq: varsupsetneq,
	varsupsetneqq: varsupsetneqq,
	vartheta: vartheta,
	vartriangleleft: vartriangleleft,
	vartriangleright: vartriangleright,
	vcy: vcy,
	vdash: vdash,
	vee: vee,
	veebar: veebar,
	veeeq: veeeq,
	vellip: vellip,
	verbar: verbar,
	vert: vert,
	vfr: vfr,
	vltri: vltri,
	vnsub: vnsub,
	vnsup: vnsup,
	vopf: vopf,
	vprop: vprop,
	vrtri: vrtri,
	vscr: vscr,
	vsubnE: vsubnE,
	vsubne: vsubne,
	vsupnE: vsupnE,
	vsupne: vsupne,
	vzigzag: vzigzag,
	wcirc: wcirc,
	wedbar: wedbar,
	wedge: wedge,
	wedgeq: wedgeq,
	weierp: weierp$1,
	wfr: wfr,
	wopf: wopf,
	wp: wp,
	wr: wr,
	wreath: wreath,
	wscr: wscr,
	xcap: xcap,
	xcirc: xcirc,
	xcup: xcup,
	xdtri: xdtri,
	xfr: xfr,
	xhArr: xhArr,
	xharr: xharr,
	xi: xi$1,
	xlArr: xlArr,
	xlarr: xlarr,
	xmap: xmap,
	xnis: xnis,
	xodot: xodot,
	xopf: xopf,
	xoplus: xoplus,
	xotime: xotime,
	xrArr: xrArr,
	xrarr: xrarr,
	xscr: xscr,
	xsqcup: xsqcup,
	xuplus: xuplus,
	xutri: xutri,
	xvee: xvee,
	xwedge: xwedge,
	yacut: yacut,
	yacute: yacute$1,
	yacy: yacy,
	ycirc: ycirc,
	ycy: ycy,
	ye: ye,
	yen: yen$1,
	yfr: yfr,
	yicy: yicy,
	yopf: yopf,
	yscr: yscr,
	yucy: yucy,
	yum: yum,
	yuml: yuml$1,
	zacute: zacute,
	zcaron: zcaron,
	zcy: zcy,
	zdot: zdot,
	zeetrf: zeetrf,
	zeta: zeta$1,
	zfr: zfr,
	zhcy: zhcy,
	zigrarr: zigrarr,
	zopf: zopf,
	zscr: zscr,
	zwj: zwj$1,
	zwnj: zwnj$1
};

var characterEntities$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AEli: AEli,
  AElig: AElig$1,
  AM: AM,
  AMP: AMP$1,
  Aacut: Aacut,
  Aacute: Aacute$1,
  Abreve: Abreve,
  Acir: Acir,
  Acirc: Acirc$1,
  Acy: Acy,
  Afr: Afr,
  Agrav: Agrav,
  Agrave: Agrave$1,
  Alpha: Alpha$1,
  Amacr: Amacr,
  And: And,
  Aogon: Aogon,
  Aopf: Aopf,
  ApplyFunction: ApplyFunction,
  Arin: Arin,
  Aring: Aring$1,
  Ascr: Ascr,
  Assign: Assign,
  Atild: Atild,
  Atilde: Atilde$1,
  Aum: Aum,
  Auml: Auml$1,
  Backslash: Backslash,
  Barv: Barv,
  Barwed: Barwed,
  Bcy: Bcy,
  Because: Because,
  Bernoullis: Bernoullis,
  Beta: Beta$1,
  Bfr: Bfr,
  Bopf: Bopf,
  Breve: Breve,
  Bscr: Bscr,
  Bumpeq: Bumpeq,
  CHcy: CHcy,
  COP: COP,
  COPY: COPY,
  Cacute: Cacute,
  Cap: Cap,
  CapitalDifferentialD: CapitalDifferentialD,
  Cayleys: Cayleys,
  Ccaron: Ccaron,
  Ccedi: Ccedi,
  Ccedil: Ccedil$1,
  Ccirc: Ccirc,
  Cconint: Cconint,
  Cdot: Cdot,
  Cedilla: Cedilla,
  CenterDot: CenterDot,
  Cfr: Cfr,
  Chi: Chi$1,
  CircleDot: CircleDot,
  CircleMinus: CircleMinus,
  CirclePlus: CirclePlus,
  CircleTimes: CircleTimes,
  ClockwiseContourIntegral: ClockwiseContourIntegral,
  CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
  CloseCurlyQuote: CloseCurlyQuote,
  Colon: Colon,
  Colone: Colone,
  Congruent: Congruent,
  Conint: Conint,
  ContourIntegral: ContourIntegral,
  Copf: Copf,
  Coproduct: Coproduct,
  CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
  Cross: Cross,
  Cscr: Cscr,
  Cup: Cup,
  CupCap: CupCap,
  DD: DD,
  DDotrahd: DDotrahd,
  DJcy: DJcy,
  DScy: DScy,
  DZcy: DZcy,
  Dagger: Dagger$1,
  Darr: Darr,
  Dashv: Dashv,
  Dcaron: Dcaron,
  Dcy: Dcy,
  Del: Del,
  Delta: Delta$1,
  Dfr: Dfr,
  DiacriticalAcute: DiacriticalAcute,
  DiacriticalDot: DiacriticalDot,
  DiacriticalDoubleAcute: DiacriticalDoubleAcute,
  DiacriticalGrave: DiacriticalGrave,
  DiacriticalTilde: DiacriticalTilde,
  Diamond: Diamond,
  DifferentialD: DifferentialD,
  Dopf: Dopf,
  Dot: Dot,
  DotDot: DotDot,
  DotEqual: DotEqual,
  DoubleContourIntegral: DoubleContourIntegral,
  DoubleDot: DoubleDot,
  DoubleDownArrow: DoubleDownArrow,
  DoubleLeftArrow: DoubleLeftArrow,
  DoubleLeftRightArrow: DoubleLeftRightArrow,
  DoubleLeftTee: DoubleLeftTee,
  DoubleLongLeftArrow: DoubleLongLeftArrow,
  DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
  DoubleLongRightArrow: DoubleLongRightArrow,
  DoubleRightArrow: DoubleRightArrow,
  DoubleRightTee: DoubleRightTee,
  DoubleUpArrow: DoubleUpArrow,
  DoubleUpDownArrow: DoubleUpDownArrow,
  DoubleVerticalBar: DoubleVerticalBar,
  DownArrow: DownArrow,
  DownArrowBar: DownArrowBar,
  DownArrowUpArrow: DownArrowUpArrow,
  DownBreve: DownBreve,
  DownLeftRightVector: DownLeftRightVector,
  DownLeftTeeVector: DownLeftTeeVector,
  DownLeftVector: DownLeftVector,
  DownLeftVectorBar: DownLeftVectorBar,
  DownRightTeeVector: DownRightTeeVector,
  DownRightVector: DownRightVector,
  DownRightVectorBar: DownRightVectorBar,
  DownTee: DownTee,
  DownTeeArrow: DownTeeArrow,
  Downarrow: Downarrow,
  Dscr: Dscr,
  Dstrok: Dstrok,
  ENG: ENG,
  ET: ET,
  ETH: ETH$1,
  Eacut: Eacut,
  Eacute: Eacute$1,
  Ecaron: Ecaron,
  Ecir: Ecir,
  Ecirc: Ecirc$1,
  Ecy: Ecy,
  Edot: Edot,
  Efr: Efr,
  Egrav: Egrav,
  Egrave: Egrave$1,
  Element: Element,
  Emacr: Emacr,
  EmptySmallSquare: EmptySmallSquare,
  EmptyVerySmallSquare: EmptyVerySmallSquare,
  Eogon: Eogon,
  Eopf: Eopf,
  Epsilon: Epsilon$1,
  Equal: Equal,
  EqualTilde: EqualTilde,
  Equilibrium: Equilibrium,
  Escr: Escr,
  Esim: Esim,
  Eta: Eta$1,
  Eum: Eum,
  Euml: Euml$1,
  Exists: Exists,
  ExponentialE: ExponentialE,
  Fcy: Fcy,
  Ffr: Ffr,
  FilledSmallSquare: FilledSmallSquare,
  FilledVerySmallSquare: FilledVerySmallSquare,
  Fopf: Fopf,
  ForAll: ForAll,
  Fouriertrf: Fouriertrf,
  Fscr: Fscr,
  GJcy: GJcy,
  G: G,
  GT: GT$1,
  Gamma: Gamma$1,
  Gammad: Gammad,
  Gbreve: Gbreve,
  Gcedil: Gcedil,
  Gcirc: Gcirc,
  Gcy: Gcy,
  Gdot: Gdot,
  Gfr: Gfr,
  Gg: Gg,
  Gopf: Gopf,
  GreaterEqual: GreaterEqual,
  GreaterEqualLess: GreaterEqualLess,
  GreaterFullEqual: GreaterFullEqual,
  GreaterGreater: GreaterGreater,
  GreaterLess: GreaterLess,
  GreaterSlantEqual: GreaterSlantEqual,
  GreaterTilde: GreaterTilde,
  Gscr: Gscr,
  Gt: Gt,
  HARDcy: HARDcy,
  Hacek: Hacek,
  Hat: Hat,
  Hcirc: Hcirc,
  Hfr: Hfr,
  HilbertSpace: HilbertSpace,
  Hopf: Hopf,
  HorizontalLine: HorizontalLine,
  Hscr: Hscr,
  Hstrok: Hstrok,
  HumpDownHump: HumpDownHump,
  HumpEqual: HumpEqual,
  IEcy: IEcy,
  IJlig: IJlig,
  IOcy: IOcy,
  Iacut: Iacut,
  Iacute: Iacute$1,
  Icir: Icir,
  Icirc: Icirc$1,
  Icy: Icy,
  Idot: Idot,
  Ifr: Ifr,
  Igrav: Igrav,
  Igrave: Igrave$1,
  Im: Im,
  Imacr: Imacr,
  ImaginaryI: ImaginaryI,
  Implies: Implies,
  Int: Int,
  Integral: Integral,
  Intersection: Intersection,
  InvisibleComma: InvisibleComma,
  InvisibleTimes: InvisibleTimes,
  Iogon: Iogon,
  Iopf: Iopf,
  Iota: Iota$1,
  Iscr: Iscr,
  Itilde: Itilde,
  Iukcy: Iukcy,
  Ium: Ium,
  Iuml: Iuml$1,
  Jcirc: Jcirc,
  Jcy: Jcy,
  Jfr: Jfr,
  Jopf: Jopf,
  Jscr: Jscr,
  Jsercy: Jsercy,
  Jukcy: Jukcy,
  KHcy: KHcy,
  KJcy: KJcy,
  Kappa: Kappa$1,
  Kcedil: Kcedil,
  Kcy: Kcy,
  Kfr: Kfr,
  Kopf: Kopf,
  Kscr: Kscr,
  LJcy: LJcy,
  L: L,
  LT: LT$1,
  Lacute: Lacute,
  Lambda: Lambda$1,
  Lang: Lang,
  Laplacetrf: Laplacetrf,
  Larr: Larr,
  Lcaron: Lcaron,
  Lcedil: Lcedil,
  Lcy: Lcy,
  LeftAngleBracket: LeftAngleBracket,
  LeftArrow: LeftArrow,
  LeftArrowBar: LeftArrowBar,
  LeftArrowRightArrow: LeftArrowRightArrow,
  LeftCeiling: LeftCeiling,
  LeftDoubleBracket: LeftDoubleBracket,
  LeftDownTeeVector: LeftDownTeeVector,
  LeftDownVector: LeftDownVector,
  LeftDownVectorBar: LeftDownVectorBar,
  LeftFloor: LeftFloor,
  LeftRightArrow: LeftRightArrow,
  LeftRightVector: LeftRightVector,
  LeftTee: LeftTee,
  LeftTeeArrow: LeftTeeArrow,
  LeftTeeVector: LeftTeeVector,
  LeftTriangle: LeftTriangle,
  LeftTriangleBar: LeftTriangleBar,
  LeftTriangleEqual: LeftTriangleEqual,
  LeftUpDownVector: LeftUpDownVector,
  LeftUpTeeVector: LeftUpTeeVector,
  LeftUpVector: LeftUpVector,
  LeftUpVectorBar: LeftUpVectorBar,
  LeftVector: LeftVector,
  LeftVectorBar: LeftVectorBar,
  Leftarrow: Leftarrow,
  Leftrightarrow: Leftrightarrow,
  LessEqualGreater: LessEqualGreater,
  LessFullEqual: LessFullEqual,
  LessGreater: LessGreater,
  LessLess: LessLess,
  LessSlantEqual: LessSlantEqual,
  LessTilde: LessTilde,
  Lfr: Lfr,
  Ll: Ll,
  Lleftarrow: Lleftarrow,
  Lmidot: Lmidot,
  LongLeftArrow: LongLeftArrow,
  LongLeftRightArrow: LongLeftRightArrow,
  LongRightArrow: LongRightArrow,
  Longleftarrow: Longleftarrow,
  Longleftrightarrow: Longleftrightarrow,
  Longrightarrow: Longrightarrow,
  Lopf: Lopf,
  LowerLeftArrow: LowerLeftArrow,
  LowerRightArrow: LowerRightArrow,
  Lscr: Lscr,
  Lsh: Lsh,
  Lstrok: Lstrok,
  Lt: Lt,
  Mcy: Mcy,
  MediumSpace: MediumSpace,
  Mellintrf: Mellintrf,
  Mfr: Mfr,
  MinusPlus: MinusPlus,
  Mopf: Mopf,
  Mscr: Mscr,
  Mu: Mu$1,
  NJcy: NJcy,
  Nacute: Nacute,
  Ncaron: Ncaron,
  Ncedil: Ncedil,
  Ncy: Ncy,
  NegativeMediumSpace: NegativeMediumSpace,
  NegativeThickSpace: NegativeThickSpace,
  NegativeThinSpace: NegativeThinSpace,
  NegativeVeryThinSpace: NegativeVeryThinSpace,
  NestedGreaterGreater: NestedGreaterGreater,
  NestedLessLess: NestedLessLess,
  NewLine: NewLine,
  Nfr: Nfr,
  NoBreak: NoBreak,
  NonBreakingSpace: NonBreakingSpace,
  Nopf: Nopf,
  Not: Not,
  NotCongruent: NotCongruent,
  NotCupCap: NotCupCap,
  NotDoubleVerticalBar: NotDoubleVerticalBar,
  NotElement: NotElement,
  NotEqual: NotEqual,
  NotEqualTilde: NotEqualTilde,
  NotExists: NotExists,
  NotGreater: NotGreater,
  NotGreaterEqual: NotGreaterEqual,
  NotGreaterFullEqual: NotGreaterFullEqual,
  NotGreaterGreater: NotGreaterGreater,
  NotGreaterLess: NotGreaterLess,
  NotGreaterSlantEqual: NotGreaterSlantEqual,
  NotGreaterTilde: NotGreaterTilde,
  NotHumpDownHump: NotHumpDownHump,
  NotHumpEqual: NotHumpEqual,
  NotLeftTriangle: NotLeftTriangle,
  NotLeftTriangleBar: NotLeftTriangleBar,
  NotLeftTriangleEqual: NotLeftTriangleEqual,
  NotLess: NotLess,
  NotLessEqual: NotLessEqual,
  NotLessGreater: NotLessGreater,
  NotLessLess: NotLessLess,
  NotLessSlantEqual: NotLessSlantEqual,
  NotLessTilde: NotLessTilde,
  NotNestedGreaterGreater: NotNestedGreaterGreater,
  NotNestedLessLess: NotNestedLessLess,
  NotPrecedes: NotPrecedes,
  NotPrecedesEqual: NotPrecedesEqual,
  NotPrecedesSlantEqual: NotPrecedesSlantEqual,
  NotReverseElement: NotReverseElement,
  NotRightTriangle: NotRightTriangle,
  NotRightTriangleBar: NotRightTriangleBar,
  NotRightTriangleEqual: NotRightTriangleEqual,
  NotSquareSubset: NotSquareSubset,
  NotSquareSubsetEqual: NotSquareSubsetEqual,
  NotSquareSuperset: NotSquareSuperset,
  NotSquareSupersetEqual: NotSquareSupersetEqual,
  NotSubset: NotSubset,
  NotSubsetEqual: NotSubsetEqual,
  NotSucceeds: NotSucceeds,
  NotSucceedsEqual: NotSucceedsEqual,
  NotSucceedsSlantEqual: NotSucceedsSlantEqual,
  NotSucceedsTilde: NotSucceedsTilde,
  NotSuperset: NotSuperset,
  NotSupersetEqual: NotSupersetEqual,
  NotTilde: NotTilde,
  NotTildeEqual: NotTildeEqual,
  NotTildeFullEqual: NotTildeFullEqual,
  NotTildeTilde: NotTildeTilde,
  NotVerticalBar: NotVerticalBar,
  Nscr: Nscr,
  Ntild: Ntild,
  Ntilde: Ntilde$1,
  Nu: Nu$1,
  OElig: OElig$1,
  Oacut: Oacut,
  Oacute: Oacute$1,
  Ocir: Ocir,
  Ocirc: Ocirc$1,
  Ocy: Ocy,
  Odblac: Odblac,
  Ofr: Ofr,
  Ograv: Ograv,
  Ograve: Ograve$1,
  Omacr: Omacr,
  Omega: Omega$1,
  Omicron: Omicron$1,
  Oopf: Oopf,
  OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
  OpenCurlyQuote: OpenCurlyQuote,
  Or: Or,
  Oscr: Oscr,
  Oslas: Oslas,
  Oslash: Oslash$1,
  Otild: Otild,
  Otilde: Otilde$1,
  Otimes: Otimes,
  Oum: Oum,
  Ouml: Ouml$1,
  OverBar: OverBar,
  OverBrace: OverBrace,
  OverBracket: OverBracket,
  OverParenthesis: OverParenthesis,
  PartialD: PartialD,
  Pcy: Pcy,
  Pfr: Pfr,
  Phi: Phi$1,
  Pi: Pi$1,
  PlusMinus: PlusMinus,
  Poincareplane: Poincareplane,
  Popf: Popf,
  Pr: Pr,
  Precedes: Precedes,
  PrecedesEqual: PrecedesEqual,
  PrecedesSlantEqual: PrecedesSlantEqual,
  PrecedesTilde: PrecedesTilde,
  Prime: Prime$1,
  Product: Product,
  Proportion: Proportion,
  Proportional: Proportional,
  Pscr: Pscr,
  Psi: Psi$1,
  QUO: QUO,
  QUOT: QUOT,
  Qfr: Qfr,
  Qopf: Qopf,
  Qscr: Qscr,
  RBarr: RBarr,
  RE: RE,
  REG: REG,
  Racute: Racute,
  Rang: Rang,
  Rarr: Rarr,
  Rarrtl: Rarrtl,
  Rcaron: Rcaron,
  Rcedil: Rcedil,
  Rcy: Rcy,
  Re: Re,
  ReverseElement: ReverseElement,
  ReverseEquilibrium: ReverseEquilibrium,
  ReverseUpEquilibrium: ReverseUpEquilibrium,
  Rfr: Rfr,
  Rho: Rho$1,
  RightAngleBracket: RightAngleBracket,
  RightArrow: RightArrow,
  RightArrowBar: RightArrowBar,
  RightArrowLeftArrow: RightArrowLeftArrow,
  RightCeiling: RightCeiling,
  RightDoubleBracket: RightDoubleBracket,
  RightDownTeeVector: RightDownTeeVector,
  RightDownVector: RightDownVector,
  RightDownVectorBar: RightDownVectorBar,
  RightFloor: RightFloor,
  RightTee: RightTee,
  RightTeeArrow: RightTeeArrow,
  RightTeeVector: RightTeeVector,
  RightTriangle: RightTriangle,
  RightTriangleBar: RightTriangleBar,
  RightTriangleEqual: RightTriangleEqual,
  RightUpDownVector: RightUpDownVector,
  RightUpTeeVector: RightUpTeeVector,
  RightUpVector: RightUpVector,
  RightUpVectorBar: RightUpVectorBar,
  RightVector: RightVector,
  RightVectorBar: RightVectorBar,
  Rightarrow: Rightarrow,
  Ropf: Ropf,
  RoundImplies: RoundImplies,
  Rrightarrow: Rrightarrow,
  Rscr: Rscr,
  Rsh: Rsh,
  RuleDelayed: RuleDelayed,
  SHCHcy: SHCHcy,
  SHcy: SHcy,
  SOFTcy: SOFTcy,
  Sacute: Sacute,
  Sc: Sc,
  Scaron: Scaron$1,
  Scedil: Scedil,
  Scirc: Scirc,
  Scy: Scy,
  Sfr: Sfr,
  ShortDownArrow: ShortDownArrow,
  ShortLeftArrow: ShortLeftArrow,
  ShortRightArrow: ShortRightArrow,
  ShortUpArrow: ShortUpArrow,
  Sigma: Sigma$1,
  SmallCircle: SmallCircle,
  Sopf: Sopf,
  Sqrt: Sqrt,
  Square: Square,
  SquareIntersection: SquareIntersection,
  SquareSubset: SquareSubset,
  SquareSubsetEqual: SquareSubsetEqual,
  SquareSuperset: SquareSuperset,
  SquareSupersetEqual: SquareSupersetEqual,
  SquareUnion: SquareUnion,
  Sscr: Sscr,
  Star: Star,
  Sub: Sub,
  Subset: Subset,
  SubsetEqual: SubsetEqual,
  Succeeds: Succeeds,
  SucceedsEqual: SucceedsEqual,
  SucceedsSlantEqual: SucceedsSlantEqual,
  SucceedsTilde: SucceedsTilde,
  SuchThat: SuchThat,
  Sum: Sum,
  Sup: Sup,
  Superset: Superset,
  SupersetEqual: SupersetEqual,
  Supset: Supset,
  THOR: THOR,
  THORN: THORN$1,
  TRADE: TRADE,
  TSHcy: TSHcy,
  TScy: TScy,
  Tab: Tab,
  Tau: Tau$1,
  Tcaron: Tcaron,
  Tcedil: Tcedil,
  Tcy: Tcy,
  Tfr: Tfr,
  Therefore: Therefore,
  Theta: Theta$1,
  ThickSpace: ThickSpace,
  ThinSpace: ThinSpace,
  Tilde: Tilde,
  TildeEqual: TildeEqual,
  TildeFullEqual: TildeFullEqual,
  TildeTilde: TildeTilde,
  Topf: Topf,
  TripleDot: TripleDot,
  Tscr: Tscr,
  Tstrok: Tstrok,
  Uacut: Uacut,
  Uacute: Uacute$1,
  Uarr: Uarr,
  Uarrocir: Uarrocir,
  Ubrcy: Ubrcy,
  Ubreve: Ubreve,
  Ucir: Ucir,
  Ucirc: Ucirc$1,
  Ucy: Ucy,
  Udblac: Udblac,
  Ufr: Ufr,
  Ugrav: Ugrav,
  Ugrave: Ugrave$1,
  Umacr: Umacr,
  UnderBar: UnderBar,
  UnderBrace: UnderBrace,
  UnderBracket: UnderBracket,
  UnderParenthesis: UnderParenthesis,
  Union: Union,
  UnionPlus: UnionPlus,
  Uogon: Uogon,
  Uopf: Uopf,
  UpArrow: UpArrow,
  UpArrowBar: UpArrowBar,
  UpArrowDownArrow: UpArrowDownArrow,
  UpDownArrow: UpDownArrow,
  UpEquilibrium: UpEquilibrium,
  UpTee: UpTee,
  UpTeeArrow: UpTeeArrow,
  Uparrow: Uparrow,
  Updownarrow: Updownarrow,
  UpperLeftArrow: UpperLeftArrow,
  UpperRightArrow: UpperRightArrow,
  Upsi: Upsi,
  Upsilon: Upsilon$1,
  Uring: Uring,
  Uscr: Uscr,
  Utilde: Utilde,
  Uum: Uum,
  Uuml: Uuml$1,
  VDash: VDash,
  Vbar: Vbar,
  Vcy: Vcy,
  Vdash: Vdash,
  Vdashl: Vdashl,
  Vee: Vee,
  Verbar: Verbar,
  Vert: Vert,
  VerticalBar: VerticalBar,
  VerticalLine: VerticalLine,
  VerticalSeparator: VerticalSeparator,
  VerticalTilde: VerticalTilde,
  VeryThinSpace: VeryThinSpace,
  Vfr: Vfr,
  Vopf: Vopf,
  Vscr: Vscr,
  Vvdash: Vvdash,
  Wcirc: Wcirc,
  Wedge: Wedge,
  Wfr: Wfr,
  Wopf: Wopf,
  Wscr: Wscr,
  Xfr: Xfr,
  Xi: Xi$1,
  Xopf: Xopf,
  Xscr: Xscr,
  YAcy: YAcy,
  YIcy: YIcy,
  YUcy: YUcy,
  Yacut: Yacut,
  Yacute: Yacute$1,
  Ycirc: Ycirc,
  Ycy: Ycy,
  Yfr: Yfr,
  Yopf: Yopf,
  Yscr: Yscr,
  Yuml: Yuml$1,
  ZHcy: ZHcy,
  Zacute: Zacute,
  Zcaron: Zcaron,
  Zcy: Zcy,
  Zdot: Zdot,
  ZeroWidthSpace: ZeroWidthSpace,
  Zeta: Zeta$1,
  Zfr: Zfr,
  Zopf: Zopf,
  Zscr: Zscr,
  aacut: aacut,
  aacute: aacute$1,
  abreve: abreve,
  ac: ac,
  acE: acE,
  acd: acd,
  acir: acir,
  acirc: acirc$1,
  acut: acut,
  acute: acute$1,
  acy: acy,
  aeli: aeli,
  aelig: aelig$1,
  af: af,
  afr: afr,
  agrav: agrav,
  agrave: agrave$1,
  alefsym: alefsym$1,
  aleph: aleph,
  alpha: alpha$1,
  amacr: amacr,
  amalg: amalg,
  am: am,
  amp: amp$1,
  and: and$1,
  andand: andand,
  andd: andd,
  andslope: andslope,
  andv: andv,
  ang: ang$1,
  ange: ange,
  angle: angle,
  angmsd: angmsd,
  angmsdaa: angmsdaa,
  angmsdab: angmsdab,
  angmsdac: angmsdac,
  angmsdad: angmsdad,
  angmsdae: angmsdae,
  angmsdaf: angmsdaf,
  angmsdag: angmsdag,
  angmsdah: angmsdah,
  angrt: angrt,
  angrtvb: angrtvb,
  angrtvbd: angrtvbd,
  angsph: angsph,
  angst: angst,
  angzarr: angzarr,
  aogon: aogon,
  aopf: aopf,
  ap: ap,
  apE: apE,
  apacir: apacir,
  ape: ape,
  apid: apid,
  apos: apos,
  approx: approx,
  approxeq: approxeq,
  arin: arin,
  aring: aring$1,
  ascr: ascr,
  ast: ast,
  asymp: asymp$1,
  asympeq: asympeq,
  atild: atild,
  atilde: atilde$1,
  aum: aum,
  auml: auml$1,
  awconint: awconint,
  awint: awint,
  bNot: bNot,
  backcong: backcong,
  backepsilon: backepsilon,
  backprime: backprime,
  backsim: backsim,
  backsimeq: backsimeq,
  barvee: barvee,
  barwed: barwed,
  barwedge: barwedge,
  bbrk: bbrk,
  bbrktbrk: bbrktbrk,
  bcong: bcong,
  bcy: bcy,
  bdquo: bdquo$1,
  becaus: becaus,
  because: because,
  bemptyv: bemptyv,
  bepsi: bepsi,
  bernou: bernou,
  beta: beta$1,
  beth: beth,
  between: between,
  bfr: bfr,
  bigcap: bigcap,
  bigcirc: bigcirc,
  bigcup: bigcup,
  bigodot: bigodot,
  bigoplus: bigoplus,
  bigotimes: bigotimes,
  bigsqcup: bigsqcup,
  bigstar: bigstar,
  bigtriangledown: bigtriangledown,
  bigtriangleup: bigtriangleup,
  biguplus: biguplus,
  bigvee: bigvee,
  bigwedge: bigwedge,
  bkarow: bkarow,
  blacklozenge: blacklozenge,
  blacksquare: blacksquare,
  blacktriangle: blacktriangle,
  blacktriangledown: blacktriangledown,
  blacktriangleleft: blacktriangleleft,
  blacktriangleright: blacktriangleright,
  blank: blank,
  blk12: blk12,
  blk14: blk14,
  blk34: blk34,
  block: block,
  bne: bne,
  bnequiv: bnequiv,
  bnot: bnot,
  bopf: bopf,
  bot: bot,
  bottom: bottom,
  bowtie: bowtie,
  boxDL: boxDL,
  boxDR: boxDR,
  boxDl: boxDl,
  boxDr: boxDr,
  boxH: boxH,
  boxHD: boxHD,
  boxHU: boxHU,
  boxHd: boxHd,
  boxHu: boxHu,
  boxUL: boxUL,
  boxUR: boxUR,
  boxUl: boxUl,
  boxUr: boxUr,
  boxV: boxV,
  boxVH: boxVH,
  boxVL: boxVL,
  boxVR: boxVR,
  boxVh: boxVh,
  boxVl: boxVl,
  boxVr: boxVr,
  boxbox: boxbox,
  boxdL: boxdL,
  boxdR: boxdR,
  boxdl: boxdl,
  boxdr: boxdr,
  boxh: boxh,
  boxhD: boxhD,
  boxhU: boxhU,
  boxhd: boxhd,
  boxhu: boxhu,
  boxminus: boxminus,
  boxplus: boxplus,
  boxtimes: boxtimes,
  boxuL: boxuL,
  boxuR: boxuR,
  boxul: boxul,
  boxur: boxur,
  boxv: boxv,
  boxvH: boxvH,
  boxvL: boxvL,
  boxvR: boxvR,
  boxvh: boxvh,
  boxvl: boxvl,
  boxvr: boxvr,
  bprime: bprime,
  breve: breve,
  brvba: brvba,
  brvbar: brvbar$1,
  bscr: bscr,
  bsemi: bsemi,
  bsim: bsim,
  bsime: bsime,
  bsol: bsol,
  bsolb: bsolb,
  bsolhsub: bsolhsub,
  bull: bull$1,
  bullet: bullet,
  bump: bump,
  bumpE: bumpE,
  bumpe: bumpe,
  bumpeq: bumpeq,
  cacute: cacute,
  cap: cap$2,
  capand: capand,
  capbrcup: capbrcup,
  capcap: capcap,
  capcup: capcup,
  capdot: capdot,
  caps: caps,
  caret: caret,
  caron: caron,
  ccaps: ccaps,
  ccaron: ccaron,
  ccedi: ccedi,
  ccedil: ccedil$1,
  ccirc: ccirc,
  ccups: ccups,
  ccupssm: ccupssm,
  cdot: cdot,
  cedi: cedi,
  cedil: cedil$1,
  cemptyv: cemptyv,
  cen: cen,
  cent: cent$1,
  centerdot: centerdot,
  cfr: cfr,
  chcy: chcy,
  check: check,
  checkmark: checkmark,
  chi: chi$1,
  cir: cir,
  cirE: cirE,
  circ: circ$1,
  circeq: circeq,
  circlearrowleft: circlearrowleft,
  circlearrowright: circlearrowright,
  circledR: circledR,
  circledS: circledS,
  circledast: circledast,
  circledcirc: circledcirc,
  circleddash: circleddash,
  cire: cire,
  cirfnint: cirfnint,
  cirmid: cirmid,
  cirscir: cirscir,
  clubs: clubs$1,
  clubsuit: clubsuit,
  colon: colon$3,
  colone: colone,
  coloneq: coloneq,
  comma: comma$2,
  commat: commat,
  comp: comp,
  compfn: compfn,
  complement: complement,
  complexes: complexes,
  cong: cong$1,
  congdot: congdot,
  conint: conint,
  copf: copf,
  coprod: coprod,
  cop: cop,
  copy: copy$1,
  copysr: copysr,
  crarr: crarr$1,
  cross: cross,
  cscr: cscr,
  csub: csub,
  csube: csube,
  csup: csup,
  csupe: csupe,
  ctdot: ctdot,
  cudarrl: cudarrl,
  cudarrr: cudarrr,
  cuepr: cuepr,
  cuesc: cuesc,
  cularr: cularr,
  cularrp: cularrp,
  cup: cup$1,
  cupbrcap: cupbrcap,
  cupcap: cupcap,
  cupcup: cupcup,
  cupdot: cupdot,
  cupor: cupor,
  cups: cups,
  curarr: curarr,
  curarrm: curarrm,
  curlyeqprec: curlyeqprec,
  curlyeqsucc: curlyeqsucc,
  curlyvee: curlyvee,
  curlywedge: curlywedge,
  curre: curre,
  curren: curren$1,
  curvearrowleft: curvearrowleft,
  curvearrowright: curvearrowright,
  cuvee: cuvee,
  cuwed: cuwed,
  cwconint: cwconint,
  cwint: cwint,
  cylcty: cylcty,
  dArr: dArr$1,
  dHar: dHar,
  dagger: dagger$1,
  daleth: daleth,
  darr: darr$1,
  dash: dash$8,
  dashv: dashv,
  dbkarow: dbkarow,
  dblac: dblac,
  dcaron: dcaron,
  dcy: dcy,
  dd: dd$1,
  ddagger: ddagger,
  ddarr: ddarr,
  ddotseq: ddotseq,
  de: de,
  deg: deg$1,
  delta: delta$1,
  demptyv: demptyv,
  dfisht: dfisht,
  dfr: dfr,
  dharl: dharl,
  dharr: dharr,
  diam: diam,
  diamond: diamond,
  diamondsuit: diamondsuit,
  diams: diams$1,
  die: die,
  digamma: digamma,
  disin: disin,
  div: div,
  divid: divid,
  divide: divide$1,
  divideontimes: divideontimes,
  divonx: divonx,
  djcy: djcy,
  dlcorn: dlcorn,
  dlcrop: dlcrop,
  dollar: dollar,
  dopf: dopf,
  dot: dot$4,
  doteq: doteq,
  doteqdot: doteqdot,
  dotminus: dotminus,
  dotplus: dotplus,
  dotsquare: dotsquare,
  doublebarwedge: doublebarwedge,
  downarrow: downarrow,
  downdownarrows: downdownarrows,
  downharpoonleft: downharpoonleft,
  downharpoonright: downharpoonright,
  drbkarow: drbkarow,
  drcorn: drcorn,
  drcrop: drcrop,
  dscr: dscr,
  dscy: dscy,
  dsol: dsol,
  dstrok: dstrok,
  dtdot: dtdot,
  dtri: dtri,
  dtrif: dtrif,
  duarr: duarr,
  duhar: duhar,
  dwangle: dwangle,
  dzcy: dzcy,
  dzigrarr: dzigrarr,
  eDDot: eDDot,
  eDot: eDot,
  eacut: eacut,
  eacute: eacute$1,
  easter: easter,
  ecaron: ecaron,
  ecir: ecir,
  ecirc: ecirc$1,
  ecolon: ecolon,
  ecy: ecy,
  edot: edot,
  ee: ee,
  efDot: efDot,
  efr: efr,
  eg: eg,
  egrav: egrav,
  egrave: egrave$1,
  egs: egs,
  egsdot: egsdot,
  el: el,
  elinters: elinters,
  ell: ell,
  els: els,
  elsdot: elsdot,
  emacr: emacr,
  empty: empty$3,
  emptyset: emptyset,
  emptyv: emptyv,
  emsp13: emsp13,
  emsp14: emsp14,
  emsp: emsp$1,
  eng: eng,
  ensp: ensp$1,
  eogon: eogon,
  eopf: eopf,
  epar: epar,
  eparsl: eparsl,
  eplus: eplus,
  epsi: epsi,
  epsilon: epsilon$1,
  epsiv: epsiv,
  eqcirc: eqcirc,
  eqcolon: eqcolon,
  eqsim: eqsim,
  eqslantgtr: eqslantgtr,
  eqslantless: eqslantless,
  equals: equals,
  equest: equest,
  equiv: equiv$1,
  equivDD: equivDD,
  eqvparsl: eqvparsl,
  erDot: erDot,
  erarr: erarr,
  escr: escr,
  esdot: esdot,
  esim: esim,
  eta: eta$1,
  et: et,
  eth: eth$1,
  eum: eum,
  euml: euml$1,
  euro: euro$1,
  excl: excl,
  exist: exist$1,
  expectation: expectation,
  exponentiale: exponentiale,
  fallingdotseq: fallingdotseq,
  fcy: fcy,
  female: female,
  ffilig: ffilig,
  fflig: fflig,
  ffllig: ffllig,
  ffr: ffr,
  filig: filig,
  fjlig: fjlig,
  flat: flat,
  fllig: fllig,
  fltns: fltns,
  fnof: fnof$1,
  fopf: fopf,
  forall: forall$1,
  fork: fork,
  forkv: forkv,
  fpartint: fpartint,
  frac1: frac1,
  frac12: frac12$1,
  frac13: frac13,
  frac14: frac14$1,
  frac15: frac15,
  frac16: frac16,
  frac18: frac18,
  frac23: frac23,
  frac25: frac25,
  frac3: frac3,
  frac34: frac34$1,
  frac35: frac35,
  frac38: frac38,
  frac45: frac45,
  frac56: frac56,
  frac58: frac58,
  frac78: frac78,
  frasl: frasl$1,
  frown: frown,
  fscr: fscr,
  gE: gE,
  gEl: gEl,
  gacute: gacute,
  gamma: gamma$1,
  gammad: gammad,
  gap: gap,
  gbreve: gbreve,
  gcirc: gcirc,
  gcy: gcy,
  gdot: gdot,
  ge: ge$1,
  gel: gel,
  geq: geq,
  geqq: geqq,
  geqslant: geqslant,
  ges: ges,
  gescc: gescc,
  gesdot: gesdot,
  gesdoto: gesdoto,
  gesdotol: gesdotol,
  gesl: gesl,
  gesles: gesles,
  gfr: gfr,
  gg: gg,
  ggg: ggg,
  gimel: gimel,
  gjcy: gjcy,
  gl: gl,
  glE: glE,
  gla: gla,
  glj: glj,
  gnE: gnE,
  gnap: gnap,
  gnapprox: gnapprox,
  gne: gne,
  gneq: gneq,
  gneqq: gneqq,
  gnsim: gnsim,
  gopf: gopf,
  grave: grave,
  gscr: gscr,
  gsim: gsim,
  gsime: gsime,
  gsiml: gsiml,
  g: g,
  gt: gt$1,
  gtcc: gtcc,
  gtcir: gtcir,
  gtdot: gtdot,
  gtlPar: gtlPar,
  gtquest: gtquest,
  gtrapprox: gtrapprox,
  gtrarr: gtrarr,
  gtrdot: gtrdot,
  gtreqless: gtreqless,
  gtreqqless: gtreqqless,
  gtrless: gtrless,
  gtrsim: gtrsim,
  gvertneqq: gvertneqq,
  gvnE: gvnE,
  hArr: hArr$1,
  hairsp: hairsp,
  half: half,
  hamilt: hamilt,
  hardcy: hardcy,
  harr: harr$1,
  harrcir: harrcir,
  harrw: harrw,
  hbar: hbar,
  hcirc: hcirc,
  hearts: hearts$1,
  heartsuit: heartsuit,
  hellip: hellip$1,
  hercon: hercon,
  hfr: hfr,
  hksearow: hksearow,
  hkswarow: hkswarow,
  hoarr: hoarr,
  homtht: homtht,
  hookleftarrow: hookleftarrow,
  hookrightarrow: hookrightarrow,
  hopf: hopf,
  horbar: horbar,
  hscr: hscr,
  hslash: hslash,
  hstrok: hstrok,
  hybull: hybull,
  hyphen: hyphen,
  iacut: iacut,
  iacute: iacute$1,
  ic: ic,
  icir: icir,
  icirc: icirc$1,
  icy: icy,
  iecy: iecy,
  iexc: iexc,
  iexcl: iexcl$1,
  iff: iff,
  ifr: ifr,
  igrav: igrav,
  igrave: igrave$1,
  ii: ii,
  iiiint: iiiint,
  iiint: iiint,
  iinfin: iinfin,
  iiota: iiota,
  ijlig: ijlig,
  imacr: imacr,
  image: image$3,
  imagline: imagline,
  imagpart: imagpart,
  imath: imath,
  imof: imof,
  imped: imped,
  incare: incare,
  infin: infin$1,
  infintie: infintie,
  inodot: inodot,
  int: int$1,
  intcal: intcal,
  integers: integers,
  intercal: intercal,
  intlarhk: intlarhk,
  intprod: intprod,
  iocy: iocy,
  iogon: iogon,
  iopf: iopf,
  iota: iota$1,
  iprod: iprod,
  iques: iques,
  iquest: iquest$1,
  iscr: iscr,
  isin: isin$1,
  isinE: isinE,
  isindot: isindot,
  isins: isins,
  isinsv: isinsv,
  isinv: isinv,
  it: it,
  itilde: itilde,
  iukcy: iukcy,
  ium: ium,
  iuml: iuml$1,
  jcirc: jcirc,
  jcy: jcy,
  jfr: jfr,
  jmath: jmath,
  jopf: jopf,
  jscr: jscr,
  jsercy: jsercy,
  jukcy: jukcy,
  kappa: kappa$1,
  kappav: kappav,
  kcedil: kcedil,
  kcy: kcy,
  kfr: kfr,
  kgreen: kgreen,
  khcy: khcy,
  kjcy: kjcy,
  kopf: kopf,
  kscr: kscr,
  lAarr: lAarr,
  lArr: lArr$1,
  lAtail: lAtail,
  lBarr: lBarr,
  lE: lE,
  lEg: lEg,
  lHar: lHar,
  lacute: lacute,
  laemptyv: laemptyv,
  lagran: lagran,
  lambda: lambda$1,
  lang: lang$1,
  langd: langd,
  langle: langle,
  lap: lap,
  laqu: laqu,
  laquo: laquo$1,
  larr: larr$1,
  larrb: larrb,
  larrbfs: larrbfs,
  larrfs: larrfs,
  larrhk: larrhk,
  larrlp: larrlp,
  larrpl: larrpl,
  larrsim: larrsim,
  larrtl: larrtl,
  lat: lat,
  latail: latail,
  late: late,
  lates: lates,
  lbarr: lbarr,
  lbbrk: lbbrk,
  lbrace: lbrace,
  lbrack: lbrack,
  lbrke: lbrke,
  lbrksld: lbrksld,
  lbrkslu: lbrkslu,
  lcaron: lcaron,
  lcedil: lcedil,
  lceil: lceil$1,
  lcub: lcub,
  lcy: lcy,
  ldca: ldca,
  ldquo: ldquo$1,
  ldquor: ldquor,
  ldrdhar: ldrdhar,
  ldrushar: ldrushar,
  ldsh: ldsh,
  le: le$1,
  leftarrow: leftarrow,
  leftarrowtail: leftarrowtail,
  leftharpoondown: leftharpoondown,
  leftharpoonup: leftharpoonup,
  leftleftarrows: leftleftarrows,
  leftrightarrow: leftrightarrow,
  leftrightarrows: leftrightarrows,
  leftrightharpoons: leftrightharpoons,
  leftrightsquigarrow: leftrightsquigarrow,
  leftthreetimes: leftthreetimes,
  leg: leg,
  leq: leq,
  leqq: leqq,
  leqslant: leqslant,
  les: les,
  lescc: lescc,
  lesdot: lesdot,
  lesdoto: lesdoto,
  lesdotor: lesdotor,
  lesg: lesg,
  lesges: lesges,
  lessapprox: lessapprox,
  lessdot: lessdot,
  lesseqgtr: lesseqgtr,
  lesseqqgtr: lesseqqgtr,
  lessgtr: lessgtr,
  lesssim: lesssim,
  lfisht: lfisht,
  lfloor: lfloor$1,
  lfr: lfr,
  lg: lg,
  lgE: lgE,
  lhard: lhard,
  lharu: lharu,
  lharul: lharul,
  lhblk: lhblk,
  ljcy: ljcy,
  ll: ll,
  llarr: llarr,
  llcorner: llcorner,
  llhard: llhard,
  lltri: lltri,
  lmidot: lmidot,
  lmoust: lmoust,
  lmoustache: lmoustache,
  lnE: lnE,
  lnap: lnap,
  lnapprox: lnapprox,
  lne: lne,
  lneq: lneq,
  lneqq: lneqq,
  lnsim: lnsim,
  loang: loang,
  loarr: loarr,
  lobrk: lobrk,
  longleftarrow: longleftarrow,
  longleftrightarrow: longleftrightarrow,
  longmapsto: longmapsto,
  longrightarrow: longrightarrow,
  looparrowleft: looparrowleft,
  looparrowright: looparrowright,
  lopar: lopar,
  lopf: lopf,
  loplus: loplus,
  lotimes: lotimes,
  lowast: lowast$1,
  lowbar: lowbar,
  loz: loz$1,
  lozenge: lozenge,
  lozf: lozf,
  lpar: lpar,
  lparlt: lparlt,
  lrarr: lrarr,
  lrcorner: lrcorner,
  lrhar: lrhar,
  lrhard: lrhard,
  lrm: lrm$1,
  lrtri: lrtri,
  lsaquo: lsaquo$1,
  lscr: lscr,
  lsh: lsh,
  lsim: lsim,
  lsime: lsime,
  lsimg: lsimg,
  lsqb: lsqb,
  lsquo: lsquo$1,
  lsquor: lsquor,
  lstrok: lstrok,
  l: l,
  lt: lt$1,
  ltcc: ltcc,
  ltcir: ltcir,
  ltdot: ltdot,
  lthree: lthree,
  ltimes: ltimes,
  ltlarr: ltlarr,
  ltquest: ltquest,
  ltrPar: ltrPar,
  ltri: ltri,
  ltrie: ltrie,
  ltrif: ltrif,
  lurdshar: lurdshar,
  luruhar: luruhar,
  lvertneqq: lvertneqq,
  lvnE: lvnE,
  mDDot: mDDot,
  mac: mac,
  macr: macr$1,
  male: male,
  malt: malt,
  maltese: maltese,
  map: map$1,
  mapsto: mapsto,
  mapstodown: mapstodown,
  mapstoleft: mapstoleft,
  mapstoup: mapstoup,
  marker: marker,
  mcomma: mcomma,
  mcy: mcy,
  mdash: mdash$1,
  measuredangle: measuredangle,
  mfr: mfr,
  mho: mho,
  micr: micr,
  micro: micro$1,
  mid: mid,
  midast: midast,
  midcir: midcir,
  middo: middo,
  middot: middot$1,
  minus: minus$1,
  minusb: minusb,
  minusd: minusd,
  minusdu: minusdu,
  mlcp: mlcp,
  mldr: mldr,
  mnplus: mnplus,
  models: models,
  mopf: mopf,
  mp: mp,
  mscr: mscr,
  mstpos: mstpos,
  mu: mu$1,
  multimap: multimap,
  mumap: mumap,
  nGg: nGg,
  nGt: nGt,
  nGtv: nGtv,
  nLeftarrow: nLeftarrow,
  nLeftrightarrow: nLeftrightarrow,
  nLl: nLl,
  nLt: nLt,
  nLtv: nLtv,
  nRightarrow: nRightarrow,
  nVDash: nVDash,
  nVdash: nVdash,
  nabla: nabla$1,
  nacute: nacute,
  nang: nang,
  nap: nap,
  napE: napE,
  napid: napid,
  napos: napos,
  napprox: napprox,
  natur: natur,
  natural: natural,
  naturals: naturals,
  nbs: nbs,
  nbsp: nbsp$1,
  nbump: nbump,
  nbumpe: nbumpe,
  ncap: ncap,
  ncaron: ncaron,
  ncedil: ncedil,
  ncong: ncong,
  ncongdot: ncongdot,
  ncup: ncup,
  ncy: ncy,
  ndash: ndash$1,
  ne: ne$1,
  neArr: neArr,
  nearhk: nearhk,
  nearr: nearr,
  nearrow: nearrow,
  nedot: nedot,
  nequiv: nequiv,
  nesear: nesear,
  nesim: nesim,
  nexist: nexist,
  nexists: nexists,
  nfr: nfr,
  ngE: ngE,
  nge: nge,
  ngeq: ngeq,
  ngeqq: ngeqq,
  ngeqslant: ngeqslant,
  nges: nges,
  ngsim: ngsim,
  ngt: ngt,
  ngtr: ngtr,
  nhArr: nhArr,
  nharr: nharr,
  nhpar: nhpar,
  ni: ni$1,
  nis: nis,
  nisd: nisd,
  niv: niv,
  njcy: njcy,
  nlArr: nlArr,
  nlE: nlE,
  nlarr: nlarr,
  nldr: nldr,
  nle: nle,
  nleftarrow: nleftarrow,
  nleftrightarrow: nleftrightarrow,
  nleq: nleq,
  nleqq: nleqq,
  nleqslant: nleqslant,
  nles: nles,
  nless: nless,
  nlsim: nlsim,
  nlt: nlt,
  nltri: nltri,
  nltrie: nltrie,
  nmid: nmid,
  nopf: nopf,
  no: no,
  not: not$1,
  notin: notin$1,
  notinE: notinE,
  notindot: notindot,
  notinva: notinva,
  notinvb: notinvb,
  notinvc: notinvc,
  notni: notni,
  notniva: notniva,
  notnivb: notnivb,
  notnivc: notnivc,
  npar: npar,
  nparallel: nparallel,
  nparsl: nparsl,
  npart: npart,
  npolint: npolint,
  npr: npr,
  nprcue: nprcue,
  npre: npre,
  nprec: nprec,
  npreceq: npreceq,
  nrArr: nrArr,
  nrarr: nrarr,
  nrarrc: nrarrc,
  nrarrw: nrarrw,
  nrightarrow: nrightarrow,
  nrtri: nrtri,
  nrtrie: nrtrie,
  nsc: nsc,
  nsccue: nsccue,
  nsce: nsce,
  nscr: nscr,
  nshortmid: nshortmid,
  nshortparallel: nshortparallel,
  nsim: nsim,
  nsime: nsime,
  nsimeq: nsimeq,
  nsmid: nsmid,
  nspar: nspar,
  nsqsube: nsqsube,
  nsqsupe: nsqsupe,
  nsub: nsub$1,
  nsubE: nsubE,
  nsube: nsube,
  nsubset: nsubset,
  nsubseteq: nsubseteq,
  nsubseteqq: nsubseteqq,
  nsucc: nsucc,
  nsucceq: nsucceq,
  nsup: nsup,
  nsupE: nsupE,
  nsupe: nsupe,
  nsupset: nsupset,
  nsupseteq: nsupseteq,
  nsupseteqq: nsupseteqq,
  ntgl: ntgl,
  ntild: ntild,
  ntilde: ntilde$1,
  ntlg: ntlg,
  ntriangleleft: ntriangleleft,
  ntrianglelefteq: ntrianglelefteq,
  ntriangleright: ntriangleright,
  ntrianglerighteq: ntrianglerighteq,
  nu: nu$1,
  num: num,
  numero: numero,
  numsp: numsp,
  nvDash: nvDash,
  nvHarr: nvHarr,
  nvap: nvap,
  nvdash: nvdash,
  nvge: nvge,
  nvgt: nvgt,
  nvinfin: nvinfin,
  nvlArr: nvlArr,
  nvle: nvle,
  nvlt: nvlt,
  nvltrie: nvltrie,
  nvrArr: nvrArr,
  nvrtrie: nvrtrie,
  nvsim: nvsim,
  nwArr: nwArr,
  nwarhk: nwarhk,
  nwarr: nwarr,
  nwarrow: nwarrow,
  nwnear: nwnear,
  oS: oS,
  oacut: oacut,
  oacute: oacute$1,
  oast: oast,
  ocir: ocir,
  ocirc: ocirc$1,
  ocy: ocy,
  odash: odash,
  odblac: odblac,
  odiv: odiv,
  odot: odot,
  odsold: odsold,
  oelig: oelig$1,
  ofcir: ofcir,
  ofr: ofr,
  ogon: ogon,
  ograv: ograv,
  ograve: ograve$1,
  ogt: ogt,
  ohbar: ohbar,
  ohm: ohm,
  oint: oint,
  olarr: olarr,
  olcir: olcir,
  olcross: olcross,
  oline: oline$1,
  olt: olt,
  omacr: omacr,
  omega: omega$1,
  omicron: omicron$1,
  omid: omid,
  ominus: ominus,
  oopf: oopf,
  opar: opar,
  operp: operp,
  oplus: oplus$1,
  or: or$1,
  orarr: orarr,
  ord: ord,
  order: order,
  orderof: orderof,
  ordf: ordf$1,
  ordm: ordm$1,
  origof: origof,
  oror: oror,
  orslope: orslope,
  orv: orv,
  oscr: oscr,
  oslas: oslas,
  oslash: oslash$1,
  osol: osol,
  otild: otild,
  otilde: otilde$1,
  otimes: otimes$1,
  otimesas: otimesas,
  oum: oum,
  ouml: ouml$1,
  ovbar: ovbar,
  par: par,
  para: para$1,
  parallel: parallel,
  parsim: parsim,
  parsl: parsl,
  part: part$1,
  pcy: pcy,
  percnt: percnt,
  period: period,
  permil: permil$1,
  perp: perp$1,
  pertenk: pertenk,
  pfr: pfr,
  phi: phi$1,
  phiv: phiv,
  phmmat: phmmat,
  phone: phone,
  pi: pi$1,
  pitchfork: pitchfork,
  piv: piv$1,
  planck: planck,
  planckh: planckh,
  plankv: plankv,
  plus: plus,
  plusacir: plusacir,
  plusb: plusb,
  pluscir: pluscir,
  plusdo: plusdo,
  plusdu: plusdu,
  pluse: pluse,
  plusm: plusm,
  plusmn: plusmn$1,
  plussim: plussim,
  plustwo: plustwo,
  pm: pm,
  pointint: pointint,
  popf: popf,
  poun: poun,
  pound: pound$1,
  pr: pr,
  prE: prE,
  prap: prap,
  prcue: prcue,
  pre: pre,
  prec: prec,
  precapprox: precapprox,
  preccurlyeq: preccurlyeq,
  preceq: preceq,
  precnapprox: precnapprox,
  precneqq: precneqq,
  precnsim: precnsim,
  precsim: precsim,
  prime: prime$1,
  primes: primes,
  prnE: prnE,
  prnap: prnap,
  prnsim: prnsim,
  prod: prod$1,
  profalar: profalar,
  profline: profline,
  profsurf: profsurf,
  prop: prop$1,
  propto: propto,
  prsim: prsim,
  prurel: prurel,
  pscr: pscr,
  psi: psi$1,
  puncsp: puncsp,
  qfr: qfr,
  qint: qint,
  qopf: qopf,
  qprime: qprime,
  qscr: qscr,
  quaternions: quaternions,
  quatint: quatint,
  quest: quest,
  questeq: questeq,
  quo: quo,
  quot: quot$1,
  rAarr: rAarr,
  rArr: rArr$1,
  rAtail: rAtail,
  rBarr: rBarr,
  rHar: rHar,
  race: race,
  racute: racute,
  radic: radic$1,
  raemptyv: raemptyv,
  rang: rang$1,
  rangd: rangd,
  range: range,
  rangle: rangle,
  raqu: raqu,
  raquo: raquo$1,
  rarr: rarr$1,
  rarrap: rarrap,
  rarrb: rarrb,
  rarrbfs: rarrbfs,
  rarrc: rarrc,
  rarrfs: rarrfs,
  rarrhk: rarrhk,
  rarrlp: rarrlp,
  rarrpl: rarrpl,
  rarrsim: rarrsim,
  rarrtl: rarrtl,
  rarrw: rarrw,
  ratail: ratail,
  ratio: ratio,
  rationals: rationals,
  rbarr: rbarr,
  rbbrk: rbbrk,
  rbrace: rbrace,
  rbrack: rbrack,
  rbrke: rbrke,
  rbrksld: rbrksld,
  rbrkslu: rbrkslu,
  rcaron: rcaron,
  rcedil: rcedil,
  rceil: rceil$1,
  rcub: rcub,
  rcy: rcy,
  rdca: rdca,
  rdldhar: rdldhar,
  rdquo: rdquo$1,
  rdquor: rdquor,
  rdsh: rdsh,
  real: real$1,
  realine: realine,
  realpart: realpart,
  reals: reals,
  rect: rect,
  re: re$3,
  reg: reg$1,
  rfisht: rfisht,
  rfloor: rfloor$1,
  rfr: rfr,
  rhard: rhard,
  rharu: rharu,
  rharul: rharul,
  rho: rho$1,
  rhov: rhov,
  rightarrow: rightarrow,
  rightarrowtail: rightarrowtail,
  rightharpoondown: rightharpoondown,
  rightharpoonup: rightharpoonup,
  rightleftarrows: rightleftarrows,
  rightleftharpoons: rightleftharpoons,
  rightrightarrows: rightrightarrows,
  rightsquigarrow: rightsquigarrow,
  rightthreetimes: rightthreetimes,
  ring: ring,
  risingdotseq: risingdotseq,
  rlarr: rlarr,
  rlhar: rlhar,
  rlm: rlm$1,
  rmoust: rmoust,
  rmoustache: rmoustache,
  rnmid: rnmid,
  roang: roang,
  roarr: roarr,
  robrk: robrk,
  ropar: ropar,
  ropf: ropf,
  roplus: roplus,
  rotimes: rotimes,
  rpar: rpar,
  rpargt: rpargt,
  rppolint: rppolint,
  rrarr: rrarr,
  rsaquo: rsaquo$1,
  rscr: rscr,
  rsh: rsh,
  rsqb: rsqb,
  rsquo: rsquo$1,
  rsquor: rsquor,
  rthree: rthree,
  rtimes: rtimes,
  rtri: rtri,
  rtrie: rtrie,
  rtrif: rtrif,
  rtriltri: rtriltri,
  ruluhar: ruluhar,
  rx: rx,
  sacute: sacute,
  sbquo: sbquo$1,
  sc: sc,
  scE: scE,
  scap: scap,
  scaron: scaron$1,
  sccue: sccue,
  sce: sce,
  scedil: scedil,
  scirc: scirc,
  scnE: scnE,
  scnap: scnap,
  scnsim: scnsim,
  scpolint: scpolint,
  scsim: scsim,
  scy: scy,
  sdot: sdot$1,
  sdotb: sdotb,
  sdote: sdote,
  seArr: seArr,
  searhk: searhk,
  searr: searr,
  searrow: searrow,
  sec: sec,
  sect: sect$1,
  semi: semi,
  seswar: seswar,
  setminus: setminus,
  setmn: setmn,
  sext: sext,
  sfr: sfr,
  sfrown: sfrown,
  sharp: sharp,
  shchcy: shchcy,
  shcy: shcy,
  shortmid: shortmid,
  shortparallel: shortparallel,
  sh: sh,
  shy: shy$1,
  sigma: sigma$1,
  sigmaf: sigmaf$1,
  sigmav: sigmav,
  sim: sim$1,
  simdot: simdot,
  sime: sime,
  simeq: simeq,
  simg: simg,
  simgE: simgE,
  siml: siml,
  simlE: simlE,
  simne: simne,
  simplus: simplus,
  simrarr: simrarr,
  slarr: slarr,
  smallsetminus: smallsetminus,
  smashp: smashp,
  smeparsl: smeparsl,
  smid: smid,
  smile: smile,
  smt: smt,
  smte: smte,
  smtes: smtes,
  softcy: softcy,
  sol: sol,
  solb: solb,
  solbar: solbar,
  sopf: sopf,
  spades: spades$1,
  spadesuit: spadesuit,
  spar: spar,
  sqcap: sqcap,
  sqcaps: sqcaps,
  sqcup: sqcup,
  sqcups: sqcups,
  sqsub: sqsub,
  sqsube: sqsube,
  sqsubset: sqsubset,
  sqsubseteq: sqsubseteq,
  sqsup: sqsup,
  sqsupe: sqsupe,
  sqsupset: sqsupset,
  sqsupseteq: sqsupseteq,
  squ: squ,
  square: square,
  squarf: squarf,
  squf: squf,
  srarr: srarr,
  sscr: sscr,
  ssetmn: ssetmn,
  ssmile: ssmile,
  sstarf: sstarf,
  star: star,
  starf: starf,
  straightepsilon: straightepsilon,
  straightphi: straightphi,
  strns: strns,
  sub: sub$1,
  subE: subE,
  subdot: subdot,
  sube: sube$1,
  subedot: subedot,
  submult: submult,
  subnE: subnE,
  subne: subne,
  subplus: subplus,
  subrarr: subrarr,
  subset: subset,
  subseteq: subseteq,
  subseteqq: subseteqq,
  subsetneq: subsetneq,
  subsetneqq: subsetneqq,
  subsim: subsim,
  subsub: subsub,
  subsup: subsup,
  succ: succ,
  succapprox: succapprox,
  succcurlyeq: succcurlyeq,
  succeq: succeq,
  succnapprox: succnapprox,
  succneqq: succneqq,
  succnsim: succnsim,
  succsim: succsim,
  sum: sum$1,
  sung: sung,
  sup: sup$1,
  sup1: sup1$1,
  sup2: sup2$1,
  sup3: sup3$1,
  supE: supE,
  supdot: supdot,
  supdsub: supdsub,
  supe: supe$1,
  supedot: supedot,
  suphsol: suphsol,
  suphsub: suphsub,
  suplarr: suplarr,
  supmult: supmult,
  supnE: supnE,
  supne: supne,
  supplus: supplus,
  supset: supset,
  supseteq: supseteq,
  supseteqq: supseteqq,
  supsetneq: supsetneq,
  supsetneqq: supsetneqq,
  supsim: supsim,
  supsub: supsub,
  supsup: supsup,
  swArr: swArr,
  swarhk: swarhk,
  swarr: swarr,
  swarrow: swarrow,
  swnwar: swnwar,
  szli: szli,
  szlig: szlig$1,
  target: target,
  tau: tau$1,
  tbrk: tbrk,
  tcaron: tcaron,
  tcedil: tcedil,
  tcy: tcy,
  tdot: tdot,
  telrec: telrec,
  tfr: tfr,
  there4: there4$1,
  therefore: therefore,
  theta: theta$1,
  thetasym: thetasym$1,
  thetav: thetav,
  thickapprox: thickapprox,
  thicksim: thicksim,
  thinsp: thinsp$1,
  thkap: thkap,
  thksim: thksim,
  thor: thor,
  thorn: thorn$1,
  tilde: tilde$4,
  time: time,
  times: times$1,
  timesb: timesb,
  timesbar: timesbar,
  timesd: timesd,
  tint: tint,
  toea: toea,
  top: top,
  topbot: topbot,
  topcir: topcir,
  topf: topf,
  topfork: topfork,
  tosa: tosa,
  tprime: tprime,
  trade: trade$1,
  triangle: triangle,
  triangledown: triangledown,
  triangleleft: triangleleft,
  trianglelefteq: trianglelefteq,
  triangleq: triangleq,
  triangleright: triangleright,
  trianglerighteq: trianglerighteq,
  tridot: tridot,
  trie: trie,
  triminus: triminus,
  triplus: triplus,
  trisb: trisb,
  tritime: tritime,
  trpezium: trpezium,
  tscr: tscr,
  tscy: tscy,
  tshcy: tshcy,
  tstrok: tstrok,
  twixt: twixt,
  twoheadleftarrow: twoheadleftarrow,
  twoheadrightarrow: twoheadrightarrow,
  uArr: uArr$1,
  uHar: uHar,
  uacut: uacut,
  uacute: uacute$1,
  uarr: uarr$1,
  ubrcy: ubrcy,
  ubreve: ubreve,
  ucir: ucir,
  ucirc: ucirc$1,
  ucy: ucy,
  udarr: udarr,
  udblac: udblac,
  udhar: udhar,
  ufisht: ufisht,
  ufr: ufr,
  ugrav: ugrav,
  ugrave: ugrave$1,
  uharl: uharl,
  uharr: uharr,
  uhblk: uhblk,
  ulcorn: ulcorn,
  ulcorner: ulcorner,
  ulcrop: ulcrop,
  ultri: ultri,
  umacr: umacr,
  um: um,
  uml: uml$1,
  uogon: uogon,
  uopf: uopf,
  uparrow: uparrow,
  updownarrow: updownarrow,
  upharpoonleft: upharpoonleft,
  upharpoonright: upharpoonright,
  uplus: uplus,
  upsi: upsi,
  upsih: upsih$1,
  upsilon: upsilon$1,
  upuparrows: upuparrows,
  urcorn: urcorn,
  urcorner: urcorner,
  urcrop: urcrop,
  uring: uring,
  urtri: urtri,
  uscr: uscr,
  utdot: utdot,
  utilde: utilde,
  utri: utri,
  utrif: utrif,
  uuarr: uuarr,
  uum: uum,
  uuml: uuml$1,
  uwangle: uwangle,
  vArr: vArr,
  vBar: vBar,
  vBarv: vBarv,
  vDash: vDash,
  vangrt: vangrt,
  varepsilon: varepsilon,
  varkappa: varkappa,
  varnothing: varnothing,
  varphi: varphi,
  varpi: varpi,
  varpropto: varpropto,
  varr: varr,
  varrho: varrho,
  varsigma: varsigma,
  varsubsetneq: varsubsetneq,
  varsubsetneqq: varsubsetneqq,
  varsupsetneq: varsupsetneq,
  varsupsetneqq: varsupsetneqq,
  vartheta: vartheta,
  vartriangleleft: vartriangleleft,
  vartriangleright: vartriangleright,
  vcy: vcy,
  vdash: vdash,
  vee: vee,
  veebar: veebar,
  veeeq: veeeq,
  vellip: vellip,
  verbar: verbar,
  vert: vert,
  vfr: vfr,
  vltri: vltri,
  vnsub: vnsub,
  vnsup: vnsup,
  vopf: vopf,
  vprop: vprop,
  vrtri: vrtri,
  vscr: vscr,
  vsubnE: vsubnE,
  vsubne: vsubne,
  vsupnE: vsupnE,
  vsupne: vsupne,
  vzigzag: vzigzag,
  wcirc: wcirc,
  wedbar: wedbar,
  wedge: wedge,
  wedgeq: wedgeq,
  weierp: weierp$1,
  wfr: wfr,
  wopf: wopf,
  wp: wp,
  wr: wr,
  wreath: wreath,
  wscr: wscr,
  xcap: xcap,
  xcirc: xcirc,
  xcup: xcup,
  xdtri: xdtri,
  xfr: xfr,
  xhArr: xhArr,
  xharr: xharr,
  xi: xi$1,
  xlArr: xlArr,
  xlarr: xlarr,
  xmap: xmap,
  xnis: xnis,
  xodot: xodot,
  xopf: xopf,
  xoplus: xoplus,
  xotime: xotime,
  xrArr: xrArr,
  xrarr: xrarr,
  xscr: xscr,
  xsqcup: xsqcup,
  xuplus: xuplus,
  xutri: xutri,
  xvee: xvee,
  xwedge: xwedge,
  yacut: yacut,
  yacute: yacute$1,
  yacy: yacy,
  ycirc: ycirc,
  ycy: ycy,
  ye: ye,
  yen: yen$1,
  yfr: yfr,
  yicy: yicy,
  yopf: yopf,
  yscr: yscr,
  yucy: yucy,
  yum: yum,
  yuml: yuml$1,
  zacute: zacute,
  zcaron: zcaron,
  zcy: zcy,
  zdot: zdot,
  zeetrf: zeetrf,
  zeta: zeta$1,
  zfr: zfr,
  zhcy: zhcy,
  zigrarr: zigrarr,
  zopf: zopf,
  zscr: zscr,
  zwj: zwj$1,
  zwnj: zwnj$1,
  'default': index$3
});

var characterEntities = getCjsExportFromNamespace(characterEntities$1);

var decodeEntity_1 = decodeEntity;

var own$c = {}.hasOwnProperty;

function decodeEntity(characters) {
  return own$c.call(characterEntities, characters)
    ? characterEntities[characters]
    : false
}

var legacy = getCjsExportFromNamespace(characterEntitiesLegacy);

var invalid = getCjsExportFromNamespace(characterReferenceInvalid);

var parseEntities_1 = parseEntities;

var own$b = {}.hasOwnProperty;
var fromCharCode = String.fromCharCode;
var noop = Function.prototype;

// Default settings.
var defaults$3 = {
  warning: null,
  reference: null,
  text: null,
  warningContext: null,
  referenceContext: null,
  textContext: null,
  position: {},
  additional: null,
  attribute: false,
  nonTerminated: true
};

// Characters.
var tab$e = 9; // '\t'
var lineFeed$j = 10; // '\n'
var formFeed = 12; // '\f'
var space$j = 32; // ' '
var ampersand$1 = 38; // '&'
var semicolon$1 = 59; // ';'
var lessThan$8 = 60; // '<'
var equalsTo$2 = 61; // '='
var numberSign$1 = 35; // '#'
var uppercaseX = 88; // 'X'
var lowercaseX$1 = 120; // 'x'
var replacementCharacter = 65533; // '�'

// Reference types.
var name$1 = 'named';
var hexa = 'hexadecimal';
var deci = 'decimal';

// Map of bases.
var bases = {};

bases[hexa] = 16;
bases[deci] = 10;

// Map of types to tests.
// Each type of character reference accepts different characters.
// This test is used to detect whether a reference has ended (as the semicolon
// is not strictly needed).
var tests = {};

tests[name$1] = isAlphanumerical;
tests[deci] = isDecimal;
tests[hexa] = isHexadecimal;

// Warning types.
var namedNotTerminated = 1;
var numericNotTerminated = 2;
var namedEmpty = 3;
var numericEmpty = 4;
var namedUnknown = 5;
var numericDisallowed = 6;
var numericProhibited = 7;

// Warning messages.
var messages = {};

messages[namedNotTerminated] =
  'Named character references must be terminated by a semicolon';
messages[numericNotTerminated] =
  'Numeric character references must be terminated by a semicolon';
messages[namedEmpty] = 'Named character references cannot be empty';
messages[numericEmpty] = 'Numeric character references cannot be empty';
messages[namedUnknown] = 'Named character references must be known';
messages[numericDisallowed] =
  'Numeric character references cannot be disallowed';
messages[numericProhibited] =
  'Numeric character references cannot be outside the permissible Unicode range';

// Wrap to ensure clean parameters are given to `parse`.
function parseEntities(value, options) {
  var settings = {};
  var option;
  var key;

  if (!options) {
    options = {};
  }

  for (key in defaults$3) {
    option = options[key];
    settings[key] =
      option === null || option === undefined ? defaults$3[key] : option;
  }

  if (settings.position.indent || settings.position.start) {
    settings.indent = settings.position.indent || [];
    settings.position = settings.position.start;
  }

  return parse$7(value, settings)
}

// Parse entities.
// eslint-disable-next-line complexity
function parse$7(value, settings) {
  var additional = settings.additional;
  var nonTerminated = settings.nonTerminated;
  var handleText = settings.text;
  var handleReference = settings.reference;
  var handleWarning = settings.warning;
  var textContext = settings.textContext;
  var referenceContext = settings.referenceContext;
  var warningContext = settings.warningContext;
  var pos = settings.position;
  var indent = settings.indent || [];
  var length = value.length;
  var index = 0;
  var lines = -1;
  var column = pos.column || 1;
  var line = pos.line || 1;
  var queue = '';
  var result = [];
  var entityCharacters;
  var namedEntity;
  var terminated;
  var characters;
  var character;
  var reference;
  var following;
  var warning;
  var reason;
  var output;
  var entity;
  var begin;
  var start;
  var type;
  var test;
  var prev;
  var next;
  var diff;
  var end;

  if (typeof additional === 'string') {
    additional = additional.charCodeAt(0);
  }

  // Cache the current point.
  prev = now();

  // Wrap `handleWarning`.
  warning = handleWarning ? parseError : noop;

  // Ensure the algorithm walks over the first character and the end
  // (inclusive).
  index--;
  length++;

  while (++index < length) {
    // If the previous character was a newline.
    if (character === lineFeed$j) {
      column = indent[lines] || 1;
    }

    character = value.charCodeAt(index);

    if (character === ampersand$1) {
      following = value.charCodeAt(index + 1);

      // The behaviour depends on the identity of the next character.
      if (
        following === tab$e ||
        following === lineFeed$j ||
        following === formFeed ||
        following === space$j ||
        following === ampersand$1 ||
        following === lessThan$8 ||
        following !== following ||
        (additional && following === additional)
      ) {
        // Not a character reference.
        // No characters are consumed, and nothing is returned.
        // This is not an error, either.
        queue += fromCharCode(character);
        column++;

        continue
      }

      start = index + 1;
      begin = start;
      end = start;

      if (following === numberSign$1) {
        // Numerical entity.
        end = ++begin;

        // The behaviour further depends on the next character.
        following = value.charCodeAt(end);

        if (following === uppercaseX || following === lowercaseX$1) {
          // ASCII hex digits.
          type = hexa;
          end = ++begin;
        } else {
          // ASCII digits.
          type = deci;
        }
      } else {
        // Named entity.
        type = name$1;
      }

      entityCharacters = '';
      entity = '';
      characters = '';
      test = tests[type];
      end--;

      while (++end < length) {
        following = value.charCodeAt(end);

        if (!test(following)) {
          break
        }

        characters += fromCharCode(following);

        // Check if we can match a legacy named reference.
        // If so, we cache that as the last viable named reference.
        // This ensures we do not need to walk backwards later.
        if (type === name$1 && own$b.call(legacy, characters)) {
          entityCharacters = characters;
          entity = legacy[characters];
        }
      }

      terminated = value.charCodeAt(end) === semicolon$1;

      if (terminated) {
        end++;

        namedEntity = type === name$1 ? decodeEntity_1(characters) : false;

        if (namedEntity) {
          entityCharacters = characters;
          entity = namedEntity;
        }
      }

      diff = 1 + end - start;

      if (!terminated && !nonTerminated) ; else if (!characters) {
        // An empty (possible) entity is valid, unless it’s numeric (thus an
        // ampersand followed by an octothorp).
        if (type !== name$1) {
          warning(numericEmpty, diff);
        }
      } else if (type === name$1) {
        // An ampersand followed by anything unknown, and not terminated, is
        // invalid.
        if (terminated && !entity) {
          warning(namedUnknown, 1);
        } else {
          // If theres something after an entity name which is not known, cap
          // the reference.
          if (entityCharacters !== characters) {
            end = begin + entityCharacters.length;
            diff = 1 + end - begin;
            terminated = false;
          }

          // If the reference is not terminated, warn.
          if (!terminated) {
            reason = entityCharacters ? namedNotTerminated : namedEmpty;

            if (settings.attribute) {
              following = value.charCodeAt(end);

              if (following === equalsTo$2) {
                warning(reason, diff);
                entity = null;
              } else if (isAlphanumerical(following)) {
                entity = null;
              } else {
                warning(reason, diff);
              }
            } else {
              warning(reason, diff);
            }
          }
        }

        reference = entity;
      } else {
        if (!terminated) {
          // All non-terminated numeric entities are not rendered, and trigger a
          // warning.
          warning(numericNotTerminated, diff);
        }

        // When terminated and number, parse as either hexadecimal or decimal.
        reference = parseInt(characters, bases[type]);

        // Trigger a warning when the parsed number is prohibited, and replace
        // with replacement character.
        if (prohibited(reference)) {
          warning(numericProhibited, diff);
          reference = fromCharCode(replacementCharacter);
        } else if (reference in invalid) {
          // Trigger a warning when the parsed number is disallowed, and replace
          // by an alternative.
          warning(numericDisallowed, diff);
          reference = invalid[reference];
        } else {
          // Parse the number.
          output = '';

          // Trigger a warning when the parsed number should not be used.
          if (disallowed(reference)) {
            warning(numericDisallowed, diff);
          }

          // Stringify the number.
          if (reference > 0xffff) {
            reference -= 0x10000;
            output += fromCharCode((reference >>> (10 & 0x3ff)) | 0xd800);
            reference = 0xdc00 | (reference & 0x3ff);
          }

          reference = output + fromCharCode(reference);
        }
      }

      // Found it!
      // First eat the queued characters as normal text, then eat an entity.
      if (reference) {
        flush();

        prev = now();
        index = end - 1;
        column += end - start + 1;
        result.push(reference);
        next = now();
        next.offset++;

        if (handleReference) {
          handleReference.call(
            referenceContext,
            reference,
            {start: prev, end: next},
            value.slice(start - 1, end)
          );
        }

        prev = next;
      } else {
        // If we could not find a reference, queue the checked characters (as
        // normal characters), and move the pointer to their end.
        // This is possible because we can be certain neither newlines nor
        // ampersands are included.
        characters = value.slice(start - 1, end);
        queue += characters;
        column += characters.length;
        index = end - 1;
      }
    } else {
      // Handle anything other than an ampersand, including newlines and EOF.
      if (
        character === 10 // Line feed
      ) {
        line++;
        lines++;
        column = 0;
      }

      if (character === character) {
        queue += fromCharCode(character);
        column++;
      } else {
        flush();
      }
    }
  }

  // Return the reduced nodes.
  return result.join('')

  // Get current position.
  function now() {
    return {
      line: line,
      column: column,
      offset: index + (pos.offset || 0)
    }
  }

  // “Throw” a parse-error: a warning.
  function parseError(code, offset) {
    var position = now();

    position.column += offset;
    position.offset += offset;

    handleWarning.call(warningContext, messages[code], position, code);
  }

  // Flush `queue` (normal text).
  // Macro invoked before each entity and at the end of `value`.
  // Does nothing when `queue` is empty.
  function flush() {
    if (queue) {
      result.push(queue);

      if (handleText) {
        handleText.call(textContext, queue, {start: prev, end: now()});
      }

      queue = '';
    }
  }
}

// Check if `character` is outside the permissible unicode range.
function prohibited(code) {
  return (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff
}

// Check if `character` is disallowed.
function disallowed(code) {
  return (
    (code >= 0x0001 && code <= 0x0008) ||
    code === 0x000b ||
    (code >= 0x000d && code <= 0x001f) ||
    (code >= 0x007f && code <= 0x009f) ||
    (code >= 0xfdd0 && code <= 0xfdef) ||
    (code & 0xffff) === 0xffff ||
    (code & 0xffff) === 0xfffe
  )
}

var decode = factory$3;

// Factory to create an entity decoder.
function factory$3(ctx) {
  decoder.raw = decodeRaw;

  return decoder

  // Normalize `position` to add an `indent`.
  function normalize(position) {
    var offsets = ctx.offset;
    var line = position.line;
    var result = [];

    while (++line) {
      if (!(line in offsets)) {
        break
      }

      result.push((offsets[line] || 0) + 1);
    }

    return {start: position, indent: result}
  }

  // Decode `value` (at `position`) into text-nodes.
  function decoder(value, position, handler) {
    parseEntities_1(value, {
      position: normalize(position),
      warning: handleWarning,
      text: handler,
      reference: handler,
      textContext: ctx,
      referenceContext: ctx
    });
  }

  // Decode `value` (at `position`) into a string.
  function decodeRaw(value, position, options) {
    return parseEntities_1(
      value,
      immutable(options, {position: normalize(position), warning: handleWarning})
    )
  }

  // Handle a warning.
  // See <https://github.com/wooorm/parse-entities> for the warnings.
  function handleWarning(reason, position, code) {
    if (code !== 3) {
      ctx.file.message(reason, position);
    }
  }
}

var tokenizer$1 = factory$2;

// Construct a tokenizer.  This creates both `tokenizeInline` and `tokenizeBlock`.
function factory$2(type) {
  return tokenize

  // Tokenizer for a bound `type`.
  function tokenize(value, location) {
    var self = this;
    var offset = self.offset;
    var tokens = [];
    var methods = self[type + 'Methods'];
    var tokenizers = self[type + 'Tokenizers'];
    var line = location.line;
    var column = location.column;
    var index;
    var length;
    var method;
    var name;
    var matched;
    var valueLength;

    // Trim white space only lines.
    if (!value) {
      return tokens
    }

    // Expose on `eat`.
    eat.now = now;
    eat.file = self.file;

    // Sync initial offset.
    updatePosition('');

    // Iterate over `value`, and iterate over all tokenizers.  When one eats
    // something, re-iterate with the remaining value.  If no tokenizer eats,
    // something failed (should not happen) and an exception is thrown.
    while (value) {
      index = -1;
      length = methods.length;
      matched = false;

      while (++index < length) {
        name = methods[index];
        method = tokenizers[name];

        // Previously, we had constructs such as footnotes and YAML that used
        // these properties.
        // Those are now external (plus there are userland extensions), that may
        // still use them.
        if (
          method &&
          /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) &&
          /* istanbul ignore next */ (!method.notInList || !self.inList) &&
          /* istanbul ignore next */ (!method.notInBlock || !self.inBlock) &&
          (!method.notInLink || !self.inLink)
        ) {
          valueLength = value.length;

          method.apply(self, [eat, value]);

          matched = valueLength !== value.length;

          if (matched) {
            break
          }
        }
      }

      /* istanbul ignore if */
      if (!matched) {
        self.file.fail(new Error('Infinite loop'), eat.now());
      }
    }

    self.eof = now();

    return tokens

    // Update line, column, and offset based on `value`.
    function updatePosition(subvalue) {
      var lastIndex = -1;
      var index = subvalue.indexOf('\n');

      while (index !== -1) {
        line++;
        lastIndex = index;
        index = subvalue.indexOf('\n', index + 1);
      }

      if (lastIndex === -1) {
        column += subvalue.length;
      } else {
        column = subvalue.length - lastIndex;
      }

      if (line in offset) {
        if (lastIndex !== -1) {
          column += offset[line];
        } else if (column <= offset[line]) {
          column = offset[line] + 1;
        }
      }
    }

    // Get offset.  Called before the first character is eaten to retrieve the
    // range’s offsets.
    function getOffset() {
      var indentation = [];
      var pos = line + 1;

      // Done.  Called when the last character is eaten to retrieve the range’s
      // offsets.
      return function () {
        var last = line + 1;

        while (pos < last) {
          indentation.push((offset[pos] || 0) + 1);

          pos++;
        }

        return indentation
      }
    }

    // Get the current position.
    function now() {
      var pos = {line: line, column: column};

      pos.offset = self.toOffset(pos);

      return pos
    }

    // Store position information for a node.
    function Position(start) {
      this.start = start;
      this.end = now();
    }

    // Throw when a value is incorrectly eaten.  This shouldn’t happen but will
    // throw on new, incorrect rules.
    function validateEat(subvalue) {
      /* istanbul ignore if */
      if (value.slice(0, subvalue.length) !== subvalue) {
        // Capture stack-trace.
        self.file.fail(
          new Error(
            'Incorrectly eaten value: please report this warning on https://git.io/vg5Ft'
          ),
          now()
        );
      }
    }

    // Mark position and patch `node.position`.
    function position() {
      var before = now();

      return update

      // Add the position to a node.
      function update(node, indent) {
        var previous = node.position;
        var start = previous ? previous.start : before;
        var combined = [];
        var n = previous && previous.end.line;
        var l = before.line;

        node.position = new Position(start);

        // If there was already a `position`, this node was merged.  Fixing
        // `start` wasn’t hard, but the indent is different.  Especially
        // because some information, the indent between `n` and `l` wasn’t
        // tracked.  Luckily, that space is (should be?) empty, so we can
        // safely check for it now.
        if (previous && indent && previous.indent) {
          combined = previous.indent;

          if (n < l) {
            while (++n < l) {
              combined.push((offset[n] || 0) + 1);
            }

            combined.push(before.column);
          }

          indent = combined.concat(indent);
        }

        node.position.indent = indent || [];

        return node
      }
    }

    // Add `node` to `parent`s children or to `tokens`.  Performs merges where
    // possible.
    function add(node, parent) {
      var children = parent ? parent.children : tokens;
      var previous = children[children.length - 1];
      var fn;

      if (
        previous &&
        node.type === previous.type &&
        (node.type === 'text' || node.type === 'blockquote') &&
        mergeable(previous) &&
        mergeable(node)
      ) {
        fn = node.type === 'text' ? mergeText : mergeBlockquote;
        node = fn.call(self, previous, node);
      }

      if (node !== previous) {
        children.push(node);
      }

      if (self.atStart && tokens.length !== 0) {
        self.exitStart();
      }

      return node
    }

    // Remove `subvalue` from `value`.  `subvalue` must be at the start of
    // `value`.
    function eat(subvalue) {
      var indent = getOffset();
      var pos = position();
      var current = now();

      validateEat(subvalue);

      apply.reset = reset;
      reset.test = test;
      apply.test = test;

      value = value.slice(subvalue.length);

      updatePosition(subvalue);

      indent = indent();

      return apply

      // Add the given arguments, add `position` to the returned node, and
      // return the node.
      function apply(node, parent) {
        return pos(add(pos(node), parent), indent)
      }

      // Functions just like apply, but resets the content: the line and
      // column are reversed, and the eaten value is re-added.   This is
      // useful for nodes with a single type of content, such as lists and
      // tables.  See `apply` above for what parameters are expected.
      function reset() {
        var node = apply.apply(null, arguments);

        line = current.line;
        column = current.column;
        value = subvalue + value;

        return node
      }

      // Test the position, after eating, and reverse to a not-eaten state.
      function test() {
        var result = pos({});

        line = current.line;
        column = current.column;
        value = subvalue + value;

        return result.position
      }
    }
  }
}

// Check whether a node is mergeable with adjacent nodes.
function mergeable(node) {
  var start;
  var end;

  if (node.type !== 'text' || !node.position) {
    return true
  }

  start = node.position.start;
  end = node.position.end;

  // Only merge nodes which occupy the same size as their `value`.
  return (
    start.line !== end.line || end.column - start.column === node.value.length
  )
}

// Merge two text nodes: `node` into `prev`.
function mergeText(previous, node) {
  previous.value += node.value;

  return previous
}

// Merge two blockquotes: `node` into `prev`, unless in CommonMark or gfm modes.
function mergeBlockquote(previous, node) {
  if (this.options.commonmark || this.options.gfm) {
    return node
  }

  previous.children = previous.children.concat(node.children);

  return previous
}

var markdownEscapes = escapes$1;

var defaults$2 = [
  '\\',
  '`',
  '*',
  '{',
  '}',
  '[',
  ']',
  '(',
  ')',
  '#',
  '+',
  '-',
  '.',
  '!',
  '_',
  '>'
];

var gfm = defaults$2.concat(['~', '|']);

var commonmark = gfm.concat([
  '\n',
  '"',
  '$',
  '%',
  '&',
  "'",
  ',',
  '/',
  ':',
  ';',
  '<',
  '=',
  '?',
  '@',
  '^'
]);

escapes$1.default = defaults$2;
escapes$1.gfm = gfm;
escapes$1.commonmark = commonmark;

// Get markdown escapes.
function escapes$1(options) {
  var settings = options || {};

  if (settings.commonmark) {
    return commonmark
  }

  return settings.gfm ? gfm : defaults$2
}

var blockElements = [
  'address',
  'article',
  'aside',
  'base',
  'basefont',
  'blockquote',
  'body',
  'caption',
  'center',
  'col',
  'colgroup',
  'dd',
  'details',
  'dialog',
  'dir',
  'div',
  'dl',
  'dt',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'frame',
  'frameset',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'head',
  'header',
  'hgroup',
  'hr',
  'html',
  'iframe',
  'legend',
  'li',
  'link',
  'main',
  'menu',
  'menuitem',
  'meta',
  'nav',
  'noframes',
  'ol',
  'optgroup',
  'option',
  'p',
  'param',
  'pre',
  'section',
  'source',
  'title',
  'summary',
  'table',
  'tbody',
  'td',
  'tfoot',
  'th',
  'thead',
  'title',
  'tr',
  'track',
  'ul'
];

var defaults$1 = {
  position: true,
  gfm: true,
  commonmark: false,
  pedantic: false,
  blocks: blockElements
};

var setOptions_1 = setOptions;

function setOptions(options) {
  var self = this;
  var current = self.options;
  var key;
  var value;

  if (options == null) {
    options = {};
  } else if (typeof options === 'object') {
    options = immutable(options);
  } else {
    throw new Error('Invalid value `' + options + '` for setting `options`')
  }

  for (key in defaults$1) {
    value = options[key];

    if (value == null) {
      value = current[key];
    }

    if (
      (key !== 'blocks' && typeof value !== 'boolean') ||
      (key === 'blocks' && typeof value !== 'object')
    ) {
      throw new Error(
        'Invalid value `' + value + '` for setting `options.' + key + '`'
      )
    }

    options[key] = value;
  }

  self.options = options;
  self.escape = markdownEscapes(options);

  return self
}

var convert_1 = convert$1;

function convert$1(test) {
  if (test == null) {
    return ok$1
  }

  if (typeof test === 'string') {
    return typeFactory$1(test)
  }

  if (typeof test === 'object') {
    return 'length' in test ? anyFactory$1(test) : allFactory(test)
  }

  if (typeof test === 'function') {
    return test
  }

  throw new Error('Expected function, string, or object as test')
}

// Utility assert each property in `test` is represented in `node`, and each
// values are strictly equal.
function allFactory(test) {
  return all

  function all(node) {
    var key;

    for (key in test) {
      if (node[key] !== test[key]) return false
    }

    return true
  }
}

function anyFactory$1(tests) {
  var checks = [];
  var index = -1;

  while (++index < tests.length) {
    checks[index] = convert$1(tests[index]);
  }

  return any

  function any() {
    var index = -1;

    while (++index < checks.length) {
      if (checks[index].apply(this, arguments)) {
        return true
      }
    }

    return false
  }
}

// Utility to convert a string into a function which checks a given node’s type
// for said string.
function typeFactory$1(test) {
  return type

  function type(node) {
    return Boolean(node && node.type === test)
  }
}

// Utility to return true.
function ok$1() {
  return true
}

var color_1 = color;
function color(d) {
  return '\u001B[33m' + d + '\u001B[39m'
}

var unistUtilVisitParents = visitParents;




var CONTINUE$1 = true;
var SKIP$1 = 'skip';
var EXIT$1 = false;

visitParents.CONTINUE = CONTINUE$1;
visitParents.SKIP = SKIP$1;
visitParents.EXIT = EXIT$1;

function visitParents(tree, test, visitor, reverse) {
  var step;
  var is;

  if (typeof test === 'function' && typeof visitor !== 'function') {
    reverse = visitor;
    visitor = test;
    test = null;
  }

  is = convert_1(test);
  step = reverse ? -1 : 1;

  factory(tree, null, [])();

  function factory(node, index, parents) {
    var value = typeof node === 'object' && node !== null ? node : {};
    var name;

    if (typeof value.type === 'string') {
      name =
        typeof value.tagName === 'string'
          ? value.tagName
          : typeof value.name === 'string'
          ? value.name
          : undefined;

      visit.displayName =
        'node (' + color_1(value.type + (name ? '<' + name + '>' : '')) + ')';
    }

    return visit

    function visit() {
      var grandparents = parents.concat(node);
      var result = [];
      var subresult;
      var offset;

      if (!test || is(node, index, parents[parents.length - 1] || null)) {
        result = toResult(visitor(node, parents));

        if (result[0] === EXIT$1) {
          return result
        }
      }

      if (node.children && result[0] !== SKIP$1) {
        offset = (reverse ? node.children.length : -1) + step;

        while (offset > -1 && offset < node.children.length) {
          subresult = factory(node.children[offset], offset, grandparents)();

          if (subresult[0] === EXIT$1) {
            return subresult
          }

          offset =
            typeof subresult[1] === 'number' ? subresult[1] : offset + step;
        }
      }

      return result
    }
  }
}

function toResult(value) {
  if (value !== null && typeof value === 'object' && 'length' in value) {
    return value
  }

  if (typeof value === 'number') {
    return [CONTINUE$1, value]
  }

  return [value]
}

var unistUtilVisit = visit;



var CONTINUE = unistUtilVisitParents.CONTINUE;
var SKIP = unistUtilVisitParents.SKIP;
var EXIT = unistUtilVisitParents.EXIT;

visit.CONTINUE = CONTINUE;
visit.SKIP = SKIP;
visit.EXIT = EXIT;

function visit(tree, test, visitor, reverse) {
  if (typeof test === 'function' && typeof visitor !== 'function') {
    reverse = visitor;
    visitor = test;
    test = null;
  }

  unistUtilVisitParents(tree, test, overload, reverse);

  function overload(node, parents) {
    var parent = parents[parents.length - 1];
    var index = parent ? parent.children.indexOf(node) : null;
    return visitor(node, index, parent)
  }
}

var unistUtilRemovePosition = removePosition;

function removePosition(node, force) {
  unistUtilVisit(node, force ? hard : soft);
  return node
}

function hard(node) {
  delete node.position;
}

function soft(node) {
  node.position = undefined;
}

var parse_1$2 = parse$6;

var lineFeed$i = '\n';
var lineBreaksExpression = /\r\n|\r/g;

// Parse the bound file.
function parse$6() {
  var self = this;
  var value = String(self.file);
  var start = {line: 1, column: 1, offset: 0};
  var content = immutable(start);
  var node;

  // Clean non-unix newlines: `\r\n` and `\r` are all changed to `\n`.
  // This should not affect positional information.
  value = value.replace(lineBreaksExpression, lineFeed$i);

  // BOM.
  if (value.charCodeAt(0) === 0xfeff) {
    value = value.slice(1);

    content.column++;
    content.offset++;
  }

  node = {
    type: 'root',
    children: self.tokenizeBlock(value, content),
    position: {start: start, end: self.eof || immutable(start)}
  };

  if (!self.options.position) {
    unistUtilRemovePosition(node, true);
  }

  return node
}

// A line containing no characters, or a line containing only spaces (U+0020) or
// tabs (U+0009), is called a blank line.
// See <https://spec.commonmark.org/0.29/#blank-line>.
var reBlankLine = /^[ \t]*(\n|$)/;

// Note that though blank lines play a special role in lists to determine
// whether the list is tight or loose
// (<https://spec.commonmark.org/0.29/#blank-lines>), it’s done by the list
// tokenizer and this blank line tokenizer does not have to be responsible for
// that.
// Therefore, configs such as `blankLine.notInList` do not have to be set here.
var blankLine_1 = blankLine;

function blankLine(eat, value, silent) {
  var match;
  var subvalue = '';
  var index = 0;
  var length = value.length;

  while (index < length) {
    match = reBlankLine.exec(value.slice(index));

    if (match == null) {
      break
    }

    index += match[0].length;
    subvalue += match[0];
  }

  if (subvalue === '') {
    return
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true
  }

  eat(subvalue);
}

/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

/**
 * Results cache
 */

var res = '';
var cache;

/**
 * Expose `repeat`
 */

var repeatString = repeat$1;

/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */

function repeat$1(str, num) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  // cover common, quick use cases
  if (num === 1) return str;
  if (num === 2) return str + str;

  var max = str.length * num;
  if (cache !== str || typeof cache === 'undefined') {
    cache = str;
    res = '';
  } else if (res.length >= max) {
    return res.substr(0, max);
  }

  while (max > res.length && num > 1) {
    if (num & 1) {
      res += str;
    }

    num >>= 1;
    str += str;
  }

  res += str;
  res = res.substr(0, max);
  return res;
}

var trimTrailingLines_1 = trimTrailingLines;

var line = '\n';

// Remove final newline characters from `value`.
function trimTrailingLines(value) {
  var val = String(value);
  var index = val.length;

  while (val.charAt(--index) === line) {
    // Empty
  }

  return val.slice(0, index + 1)
}

var codeIndented = indentedCode$1;

var lineFeed$h = '\n';
var tab$d = '\t';
var space$i = ' ';

var tabSize$4 = 4;
var codeIndent = repeatString(space$i, tabSize$4);

function indentedCode$1(eat, value, silent) {
  var index = -1;
  var length = value.length;
  var subvalue = '';
  var content = '';
  var subvalueQueue = '';
  var contentQueue = '';
  var character;
  var blankQueue;
  var indent;

  while (++index < length) {
    character = value.charAt(index);

    if (indent) {
      indent = false;

      subvalue += subvalueQueue;
      content += contentQueue;
      subvalueQueue = '';
      contentQueue = '';

      if (character === lineFeed$h) {
        subvalueQueue = character;
        contentQueue = character;
      } else {
        subvalue += character;
        content += character;

        while (++index < length) {
          character = value.charAt(index);

          if (!character || character === lineFeed$h) {
            contentQueue = character;
            subvalueQueue = character;
            break
          }

          subvalue += character;
          content += character;
        }
      }
    } else if (
      character === space$i &&
      value.charAt(index + 1) === character &&
      value.charAt(index + 2) === character &&
      value.charAt(index + 3) === character
    ) {
      subvalueQueue += codeIndent;
      index += 3;
      indent = true;
    } else if (character === tab$d) {
      subvalueQueue += character;
      indent = true;
    } else {
      blankQueue = '';

      while (character === tab$d || character === space$i) {
        blankQueue += character;
        character = value.charAt(++index);
      }

      if (character !== lineFeed$h) {
        break
      }

      subvalueQueue += blankQueue + character;
      contentQueue += character;
    }
  }

  if (content) {
    if (silent) {
      return true
    }

    return eat(subvalue)({
      type: 'code',
      lang: null,
      meta: null,
      value: trimTrailingLines_1(content)
    })
  }
}

var codeFenced = fencedCode;

var lineFeed$g = '\n';
var tab$c = '\t';
var space$h = ' ';
var tilde$3 = '~';
var graveAccent$2 = '`';

var minFenceCount = 3;
var tabSize$3 = 4;

function fencedCode(eat, value, silent) {
  var self = this;
  var gfm = self.options.gfm;
  var length = value.length + 1;
  var index = 0;
  var subvalue = '';
  var fenceCount;
  var marker;
  var character;
  var flag;
  var lang;
  var meta;
  var queue;
  var content;
  var exdentedContent;
  var closing;
  var exdentedClosing;
  var indent;
  var now;

  if (!gfm) {
    return
  }

  // Eat initial spacing.
  while (index < length) {
    character = value.charAt(index);

    if (character !== space$h && character !== tab$c) {
      break
    }

    subvalue += character;
    index++;
  }

  indent = index;

  // Eat the fence.
  character = value.charAt(index);

  if (character !== tilde$3 && character !== graveAccent$2) {
    return
  }

  index++;
  marker = character;
  fenceCount = 1;
  subvalue += character;

  while (index < length) {
    character = value.charAt(index);

    if (character !== marker) {
      break
    }

    subvalue += character;
    fenceCount++;
    index++;
  }

  if (fenceCount < minFenceCount) {
    return
  }

  // Eat spacing before flag.
  while (index < length) {
    character = value.charAt(index);

    if (character !== space$h && character !== tab$c) {
      break
    }

    subvalue += character;
    index++;
  }

  // Eat flag.
  flag = '';
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (
      character === lineFeed$g ||
      (marker === graveAccent$2 && character === marker)
    ) {
      break
    }

    if (character === space$h || character === tab$c) {
      queue += character;
    } else {
      flag += queue + character;
      queue = '';
    }

    index++;
  }

  character = value.charAt(index);

  if (character && character !== lineFeed$g) {
    return
  }

  if (silent) {
    return true
  }

  now = eat.now();
  now.column += subvalue.length;
  now.offset += subvalue.length;

  subvalue += flag;
  flag = self.decode.raw(self.unescape(flag), now);

  if (queue) {
    subvalue += queue;
  }

  queue = '';
  closing = '';
  exdentedClosing = '';
  content = '';
  exdentedContent = '';
  var skip = true;

  // Eat content.
  while (index < length) {
    character = value.charAt(index);
    content += closing;
    exdentedContent += exdentedClosing;
    closing = '';
    exdentedClosing = '';

    if (character !== lineFeed$g) {
      content += character;
      exdentedClosing += character;
      index++;
      continue
    }

    // The first line feed is ignored. Others aren’t.
    if (skip) {
      subvalue += character;
      skip = false;
    } else {
      closing += character;
      exdentedClosing += character;
    }

    queue = '';
    index++;

    while (index < length) {
      character = value.charAt(index);

      if (character !== space$h) {
        break
      }

      queue += character;
      index++;
    }

    closing += queue;
    exdentedClosing += queue.slice(indent);

    if (queue.length >= tabSize$3) {
      continue
    }

    queue = '';

    while (index < length) {
      character = value.charAt(index);

      if (character !== marker) {
        break
      }

      queue += character;
      index++;
    }

    closing += queue;
    exdentedClosing += queue;

    if (queue.length < fenceCount) {
      continue
    }

    queue = '';

    while (index < length) {
      character = value.charAt(index);

      if (character !== space$h && character !== tab$c) {
        break
      }

      closing += character;
      exdentedClosing += character;
      index++;
    }

    if (!character || character === lineFeed$g) {
      break
    }
  }

  subvalue += content + closing;

  // Get lang and meta from the flag.
  index = -1;
  length = flag.length;

  while (++index < length) {
    character = flag.charAt(index);

    if (character === space$h || character === tab$c) {
      if (!lang) {
        lang = flag.slice(0, index);
      }
    } else if (lang) {
      meta = flag.slice(index);
      break
    }
  }

  return eat(subvalue)({
    type: 'code',
    lang: lang || flag || null,
    meta: meta || null,
    value: exdentedContent
  })
}

var trim_1 = createCommonjsModule(function (module, exports) {
exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};
});
trim_1.left;
trim_1.right;

var interrupt_1 = interrupt;

function interrupt(interruptors, tokenizers, ctx, parameters) {
  var length = interruptors.length;
  var index = -1;
  var interruptor;
  var config;

  while (++index < length) {
    interruptor = interruptors[index];
    config = interruptor[1] || {};

    if (
      config.pedantic !== undefined &&
      config.pedantic !== ctx.options.pedantic
    ) {
      continue
    }

    if (
      config.commonmark !== undefined &&
      config.commonmark !== ctx.options.commonmark
    ) {
      continue
    }

    if (tokenizers[interruptor[0]].apply(ctx, parameters)) {
      return true
    }
  }

  return false
}

var blockquote_1$1 = blockquote$1;

var lineFeed$f = '\n';
var tab$b = '\t';
var space$g = ' ';
var greaterThan$4 = '>';

function blockquote$1(eat, value, silent) {
  var self = this;
  var offsets = self.offset;
  var tokenizers = self.blockTokenizers;
  var interruptors = self.interruptBlockquote;
  var now = eat.now();
  var currentLine = now.line;
  var length = value.length;
  var values = [];
  var contents = [];
  var indents = [];
  var add;
  var index = 0;
  var character;
  var rest;
  var nextIndex;
  var content;
  var line;
  var startIndex;
  var prefixed;
  var exit;

  while (index < length) {
    character = value.charAt(index);

    if (character !== space$g && character !== tab$b) {
      break
    }

    index++;
  }

  if (value.charAt(index) !== greaterThan$4) {
    return
  }

  if (silent) {
    return true
  }

  index = 0;

  while (index < length) {
    nextIndex = value.indexOf(lineFeed$f, index);
    startIndex = index;
    prefixed = false;

    if (nextIndex === -1) {
      nextIndex = length;
    }

    while (index < length) {
      character = value.charAt(index);

      if (character !== space$g && character !== tab$b) {
        break
      }

      index++;
    }

    if (value.charAt(index) === greaterThan$4) {
      index++;
      prefixed = true;

      if (value.charAt(index) === space$g) {
        index++;
      }
    } else {
      index = startIndex;
    }

    content = value.slice(index, nextIndex);

    if (!prefixed && !trim_1(content)) {
      index = startIndex;
      break
    }

    if (!prefixed) {
      rest = value.slice(index);

      // Check if the following code contains a possible block.
      if (interrupt_1(interruptors, tokenizers, self, [eat, rest, true])) {
        break
      }
    }

    line = startIndex === index ? content : value.slice(startIndex, nextIndex);

    indents.push(index - startIndex);
    values.push(line);
    contents.push(content);

    index = nextIndex + 1;
  }

  index = -1;
  length = indents.length;
  add = eat(values.join(lineFeed$f));

  while (++index < length) {
    offsets[currentLine] = (offsets[currentLine] || 0) + indents[index];
    currentLine++;
  }

  exit = self.enterBlock();
  contents = self.tokenizeBlock(contents.join(lineFeed$f), now);
  exit();

  return add({type: 'blockquote', children: contents})
}

var headingAtx = atxHeading;

var lineFeed$e = '\n';
var tab$a = '\t';
var space$f = ' ';
var numberSign = '#';

var maxFenceCount = 6;

function atxHeading(eat, value, silent) {
  var self = this;
  var pedantic = self.options.pedantic;
  var length = value.length + 1;
  var index = -1;
  var now = eat.now();
  var subvalue = '';
  var content = '';
  var character;
  var queue;
  var depth;

  // Eat initial spacing.
  while (++index < length) {
    character = value.charAt(index);

    if (character !== space$f && character !== tab$a) {
      index--;
      break
    }

    subvalue += character;
  }

  // Eat hashes.
  depth = 0;

  while (++index <= length) {
    character = value.charAt(index);

    if (character !== numberSign) {
      index--;
      break
    }

    subvalue += character;
    depth++;
  }

  if (depth > maxFenceCount) {
    return
  }

  if (!depth || (!pedantic && value.charAt(index + 1) === numberSign)) {
    return
  }

  length = value.length + 1;

  // Eat intermediate white-space.
  queue = '';

  while (++index < length) {
    character = value.charAt(index);

    if (character !== space$f && character !== tab$a) {
      index--;
      break
    }

    queue += character;
  }

  // Exit when not in pedantic mode without spacing.
  if (!pedantic && queue.length === 0 && character && character !== lineFeed$e) {
    return
  }

  if (silent) {
    return true
  }

  // Eat content.
  subvalue += queue;
  queue = '';
  content = '';

  while (++index < length) {
    character = value.charAt(index);

    if (!character || character === lineFeed$e) {
      break
    }

    if (character !== space$f && character !== tab$a && character !== numberSign) {
      content += queue + character;
      queue = '';
      continue
    }

    while (character === space$f || character === tab$a) {
      queue += character;
      character = value.charAt(++index);
    }

    // `#` without a queue is part of the content.
    if (!pedantic && content && !queue && character === numberSign) {
      content += character;
      continue
    }

    while (character === numberSign) {
      queue += character;
      character = value.charAt(++index);
    }

    while (character === space$f || character === tab$a) {
      queue += character;
      character = value.charAt(++index);
    }

    index--;
  }

  now.column += subvalue.length;
  now.offset += subvalue.length;
  subvalue += content + queue;

  return eat(subvalue)({
    type: 'heading',
    depth: depth,
    children: self.tokenizeInline(content, now)
  })
}

var thematicBreak_1$1 = thematicBreak$1;

var tab$9 = '\t';
var lineFeed$d = '\n';
var space$e = ' ';
var asterisk$4 = '*';
var dash$7 = '-';
var underscore$6 = '_';

var maxCount = 3;

function thematicBreak$1(eat, value, silent) {
  var index = -1;
  var length = value.length + 1;
  var subvalue = '';
  var character;
  var marker;
  var markerCount;
  var queue;

  while (++index < length) {
    character = value.charAt(index);

    if (character !== tab$9 && character !== space$e) {
      break
    }

    subvalue += character;
  }

  if (
    character !== asterisk$4 &&
    character !== dash$7 &&
    character !== underscore$6
  ) {
    return
  }

  marker = character;
  subvalue += character;
  markerCount = 1;
  queue = '';

  while (++index < length) {
    character = value.charAt(index);

    if (character === marker) {
      markerCount++;
      subvalue += queue + marker;
      queue = '';
    } else if (character === space$e) {
      queue += character;
    } else if (
      markerCount >= maxCount &&
      (!character || character === lineFeed$d)
    ) {
      subvalue += queue;

      if (silent) {
        return true
      }

      return eat(subvalue)({type: 'thematicBreak'})
    } else {
      return
    }
  }
}

var getIndentation = indentation$1;

var tab$8 = '\t';
var space$d = ' ';

var spaceSize = 1;
var tabSize$2 = 4;

// Gets indentation information for a line.
function indentation$1(value) {
  var index = 0;
  var indent = 0;
  var character = value.charAt(index);
  var stops = {};
  var size;
  var lastIndent = 0;

  while (character === tab$8 || character === space$d) {
    size = character === tab$8 ? tabSize$2 : spaceSize;

    indent += size;

    if (size > 1) {
      indent = Math.floor(indent / size) * size;
    }

    while (lastIndent < indent) {
      stops[++lastIndent] = index;
    }

    character = value.charAt(++index);
  }

  return {indent: indent, stops: stops}
}

var removeIndentation = indentation;

var lineFeed$c = '\n';
var space$c = ' ';
var exclamationMark$4 = '!';

// Remove the minimum indent from every line in `value`.  Supports both tab,
// spaced, and mixed indentation (as well as possible).
function indentation(value, maximum) {
  var values = value.split(lineFeed$c);
  var position = values.length + 1;
  var minIndent = Infinity;
  var matrix = [];
  var index;
  var indentation;
  var stops;

  values.unshift(repeatString(space$c, maximum) + exclamationMark$4);

  while (position--) {
    indentation = getIndentation(values[position]);

    matrix[position] = indentation.stops;

    if (trim_1(values[position]).length === 0) {
      continue
    }

    if (indentation.indent) {
      if (indentation.indent > 0 && indentation.indent < minIndent) {
        minIndent = indentation.indent;
      }
    } else {
      minIndent = Infinity;

      break
    }
  }

  if (minIndent !== Infinity) {
    position = values.length;

    while (position--) {
      stops = matrix[position];
      index = minIndent;

      while (index && !(index in stops)) {
        index--;
      }

      values[position] = values[position].slice(stops[index] + 1);
    }
  }

  values.shift();

  return values.join(lineFeed$c)
}

var list_1$1 = list$1;

var asterisk$3 = '*';
var underscore$5 = '_';
var plusSign$2 = '+';
var dash$6 = '-';
var dot$3 = '.';
var space$b = ' ';
var lineFeed$b = '\n';
var tab$7 = '\t';
var rightParenthesis$3 = ')';
var lowercaseX = 'x';

var tabSize$1 = 4;
var looseListItemExpression = /\n\n(?!\s*$)/;
var taskItemExpression = /^\[([ X\tx])][ \t]/;
var bulletExpression = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
var pedanticBulletExpression = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
var initialIndentExpression = /^( {1,4}|\t)?/gm;

function list$1(eat, value, silent) {
  var self = this;
  var commonmark = self.options.commonmark;
  var pedantic = self.options.pedantic;
  var tokenizers = self.blockTokenizers;
  var interuptors = self.interruptList;
  var index = 0;
  var length = value.length;
  var start = null;
  var size;
  var queue;
  var ordered;
  var character;
  var marker;
  var nextIndex;
  var startIndex;
  var prefixed;
  var currentMarker;
  var content;
  var line;
  var previousEmpty;
  var empty;
  var items;
  var allLines;
  var emptyLines;
  var item;
  var enterTop;
  var exitBlockquote;
  var spread = false;
  var node;
  var now;
  var end;
  var indented;

  while (index < length) {
    character = value.charAt(index);

    if (character !== tab$7 && character !== space$b) {
      break
    }

    index++;
  }

  character = value.charAt(index);

  if (character === asterisk$3 || character === plusSign$2 || character === dash$6) {
    marker = character;
    ordered = false;
  } else {
    ordered = true;
    queue = '';

    while (index < length) {
      character = value.charAt(index);

      if (!isDecimal(character)) {
        break
      }

      queue += character;
      index++;
    }

    character = value.charAt(index);

    if (
      !queue ||
      !(character === dot$3 || (commonmark && character === rightParenthesis$3))
    ) {
      return
    }

    /* Slightly abusing `silent` mode, whose goal is to make interrupting
     * paragraphs work.
     * Well, that’s exactly what we want to do here: don’t interrupt:
     * 2. here, because the “list” doesn’t start with `1`. */
    if (silent && queue !== '1') {
      return
    }

    start = parseInt(queue, 10);
    marker = character;
  }

  character = value.charAt(++index);

  if (
    character !== space$b &&
    character !== tab$7 &&
    (pedantic || (character !== lineFeed$b && character !== ''))
  ) {
    return
  }

  if (silent) {
    return true
  }

  index = 0;
  items = [];
  allLines = [];
  emptyLines = [];

  while (index < length) {
    nextIndex = value.indexOf(lineFeed$b, index);
    startIndex = index;
    prefixed = false;
    indented = false;

    if (nextIndex === -1) {
      nextIndex = length;
    }

    size = 0;

    while (index < length) {
      character = value.charAt(index);

      if (character === tab$7) {
        size += tabSize$1 - (size % tabSize$1);
      } else if (character === space$b) {
        size++;
      } else {
        break
      }

      index++;
    }

    if (item && size >= item.indent) {
      indented = true;
    }

    character = value.charAt(index);
    currentMarker = null;

    if (!indented) {
      if (
        character === asterisk$3 ||
        character === plusSign$2 ||
        character === dash$6
      ) {
        currentMarker = character;
        index++;
        size++;
      } else {
        queue = '';

        while (index < length) {
          character = value.charAt(index);

          if (!isDecimal(character)) {
            break
          }

          queue += character;
          index++;
        }

        character = value.charAt(index);
        index++;

        if (
          queue &&
          (character === dot$3 || (commonmark && character === rightParenthesis$3))
        ) {
          currentMarker = character;
          size += queue.length + 1;
        }
      }

      if (currentMarker) {
        character = value.charAt(index);

        if (character === tab$7) {
          size += tabSize$1 - (size % tabSize$1);
          index++;
        } else if (character === space$b) {
          end = index + tabSize$1;

          while (index < end) {
            if (value.charAt(index) !== space$b) {
              break
            }

            index++;
            size++;
          }

          if (index === end && value.charAt(index) === space$b) {
            index -= tabSize$1 - 1;
            size -= tabSize$1 - 1;
          }
        } else if (character !== lineFeed$b && character !== '') {
          currentMarker = null;
        }
      }
    }

    if (currentMarker) {
      if (!pedantic && marker !== currentMarker) {
        break
      }

      prefixed = true;
    } else {
      if (!commonmark && !indented && value.charAt(startIndex) === space$b) {
        indented = true;
      } else if (commonmark && item) {
        indented = size >= item.indent || size > tabSize$1;
      }

      prefixed = false;
      index = startIndex;
    }

    line = value.slice(startIndex, nextIndex);
    content = startIndex === index ? line : value.slice(index, nextIndex);

    if (
      currentMarker === asterisk$3 ||
      currentMarker === underscore$5 ||
      currentMarker === dash$6
    ) {
      if (tokenizers.thematicBreak.call(self, eat, line, true)) {
        break
      }
    }

    previousEmpty = empty;
    empty = !prefixed && !trim_1(content).length;

    if (indented && item) {
      item.value = item.value.concat(emptyLines, line);
      allLines = allLines.concat(emptyLines, line);
      emptyLines = [];
    } else if (prefixed) {
      if (emptyLines.length !== 0) {
        spread = true;
        item.value.push('');
        item.trail = emptyLines.concat();
      }

      item = {
        value: [line],
        indent: size,
        trail: []
      };

      items.push(item);
      allLines = allLines.concat(emptyLines, line);
      emptyLines = [];
    } else if (empty) {
      if (previousEmpty && !commonmark) {
        break
      }

      emptyLines.push(line);
    } else {
      if (previousEmpty) {
        break
      }

      if (interrupt_1(interuptors, tokenizers, self, [eat, line, true])) {
        break
      }

      item.value = item.value.concat(emptyLines, line);
      allLines = allLines.concat(emptyLines, line);
      emptyLines = [];
    }

    index = nextIndex + 1;
  }

  node = eat(allLines.join(lineFeed$b)).reset({
    type: 'list',
    ordered: ordered,
    start: start,
    spread: spread,
    children: []
  });

  enterTop = self.enterList();
  exitBlockquote = self.enterBlock();
  index = -1;
  length = items.length;

  while (++index < length) {
    item = items[index].value.join(lineFeed$b);
    now = eat.now();

    eat(item)(listItem$2(self, item, now), node);

    item = items[index].trail.join(lineFeed$b);

    if (index !== length - 1) {
      item += lineFeed$b;
    }

    eat(item);
  }

  enterTop();
  exitBlockquote();

  return node
}

function listItem$2(ctx, value, position) {
  var offsets = ctx.offset;
  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;
  var checked = null;
  var task;
  var indent;

  value = fn.apply(null, arguments);

  if (ctx.options.gfm) {
    task = value.match(taskItemExpression);

    if (task) {
      indent = task[0].length;
      checked = task[1].toLowerCase() === lowercaseX;
      offsets[position.line] += indent;
      value = value.slice(indent);
    }
  }

  return {
    type: 'listItem',
    spread: looseListItemExpression.test(value),
    checked: checked,
    children: ctx.tokenizeBlock(value, position)
  }
}

// Create a list-item using overly simple mechanics.
function pedanticListItem(ctx, value, position) {
  var offsets = ctx.offset;
  var line = position.line;

  // Remove the list-item’s bullet.
  value = value.replace(pedanticBulletExpression, replacer);

  // The initial line was also matched by the below, so we reset the `line`.
  line = position.line;

  return value.replace(initialIndentExpression, replacer)

  // A simple replacer which removed all matches, and adds their length to
  // `offset`.
  function replacer($0) {
    offsets[line] = (offsets[line] || 0) + $0.length;
    line++;

    return ''
  }
}

// Create a list-item using sane mechanics.
function normalListItem(ctx, value, position) {
  var offsets = ctx.offset;
  var line = position.line;
  var max;
  var bullet;
  var rest;
  var lines;
  var trimmedLines;
  var index;
  var length;

  // Remove the list-item’s bullet.
  value = value.replace(bulletExpression, replacer);

  lines = value.split(lineFeed$b);

  trimmedLines = removeIndentation(value, getIndentation(max).indent).split(lineFeed$b);

  // We replaced the initial bullet with something else above, which was used
  // to trick `removeIndentation` into removing some more characters when
  // possible.  However, that could result in the initial line to be stripped
  // more than it should be.
  trimmedLines[0] = rest;

  offsets[line] = (offsets[line] || 0) + bullet.length;
  line++;

  index = 0;
  length = lines.length;

  while (++index < length) {
    offsets[line] =
      (offsets[line] || 0) + lines[index].length - trimmedLines[index].length;
    line++;
  }

  return trimmedLines.join(lineFeed$b)

  /* eslint-disable-next-line max-params */
  function replacer($0, $1, $2, $3, $4) {
    bullet = $1 + $2 + $3;
    rest = $4;

    // Make sure that the first nine numbered list items can indent with an
    // extra space.  That is, when the bullet did not receive an extra final
    // space.
    if (Number($2) < 10 && bullet.length % 2 === 1) {
      $2 = space$b + $2;
    }

    max = $1 + repeatString(space$b, $2.length) + $3;

    return max + rest
  }
}

var headingSetext = setextHeading;

var lineFeed$a = '\n';
var tab$6 = '\t';
var space$a = ' ';
var equalsTo$1 = '=';
var dash$5 = '-';

var maxIndent = 3;

var equalsToDepth = 1;
var dashDepth = 2;

function setextHeading(eat, value, silent) {
  var self = this;
  var now = eat.now();
  var length = value.length;
  var index = -1;
  var subvalue = '';
  var content;
  var queue;
  var character;
  var marker;
  var depth;

  // Eat initial indentation.
  while (++index < length) {
    character = value.charAt(index);

    if (character !== space$a || index >= maxIndent) {
      index--;
      break
    }

    subvalue += character;
  }

  // Eat content.
  content = '';
  queue = '';

  while (++index < length) {
    character = value.charAt(index);

    if (character === lineFeed$a) {
      index--;
      break
    }

    if (character === space$a || character === tab$6) {
      queue += character;
    } else {
      content += queue + character;
      queue = '';
    }
  }

  now.column += subvalue.length;
  now.offset += subvalue.length;
  subvalue += content + queue;

  // Ensure the content is followed by a newline and a valid marker.
  character = value.charAt(++index);
  marker = value.charAt(++index);

  if (character !== lineFeed$a || (marker !== equalsTo$1 && marker !== dash$5)) {
    return
  }

  subvalue += character;

  // Eat Setext-line.
  queue = marker;
  depth = marker === equalsTo$1 ? equalsToDepth : dashDepth;

  while (++index < length) {
    character = value.charAt(index);

    if (character !== marker) {
      if (character !== lineFeed$a) {
        return
      }

      index--;
      break
    }

    queue += character;
  }

  if (silent) {
    return true
  }

  return eat(subvalue + queue)({
    type: 'heading',
    depth: depth,
    children: self.tokenizeInline(content, now)
  })
}

var attributeName$2 = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
var unquoted$2 = '[^"\'=<>`\\u0000-\\u0020]+';
var singleQuoted$2 = "'[^']*'";
var doubleQuoted$2 = '"[^"]*"';
var attributeValue$2 =
  '(?:' + unquoted$2 + '|' + singleQuoted$2 + '|' + doubleQuoted$2 + ')';
var attribute$2 =
  '(?:\\s+' + attributeName$2 + '(?:\\s*=\\s*' + attributeValue$2 + ')?)';
var openTag$1 = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute$2 + '*\\s*\\/?>';
var closeTag$1 = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment$1 = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?].*?[?]>';
var declaration = '<![A-Za-z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var openCloseTag$2 = new RegExp('^(?:' + openTag$1 + '|' + closeTag$1 + ')');

var tag$2 = new RegExp(
  '^(?:' +
    openTag$1 +
    '|' +
    closeTag$1 +
    '|' +
    comment$1 +
    '|' +
    processing +
    '|' +
    declaration +
    '|' +
    cdata +
    ')'
);

var html$4 = {
	openCloseTag: openCloseTag$2,
	tag: tag$2
};

var openCloseTag$1 = html$4.openCloseTag;

var htmlBlock = blockHtml$1;

var tab$5 = '\t';
var space$9 = ' ';
var lineFeed$9 = '\n';
var lessThan$7 = '<';

var rawOpenExpression$1 = /^<(script|pre|style)(?=(\s|>|$))/i;
var rawCloseExpression$1 = /<\/(script|pre|style)>/i;
var commentOpenExpression$1 = /^<!--/;
var commentCloseExpression$1 = /-->/;
var instructionOpenExpression$1 = /^<\?/;
var instructionCloseExpression$1 = /\?>/;
var directiveOpenExpression$1 = /^<![A-Za-z]/;
var directiveCloseExpression$1 = />/;
var cdataOpenExpression$1 = /^<!\[CDATA\[/;
var cdataCloseExpression$1 = /]]>/;
var elementCloseExpression$1 = /^$/;
var otherElementOpenExpression$1 = new RegExp(openCloseTag$1.source + '\\s*$');

function blockHtml$1(eat, value, silent) {
  var self = this;
  var blocks = self.options.blocks.join('|');
  var elementOpenExpression = new RegExp(
    '^</?(' + blocks + ')(?=(\\s|/?>|$))',
    'i'
  );
  var length = value.length;
  var index = 0;
  var next;
  var line;
  var offset;
  var character;
  var count;
  var sequence;
  var subvalue;

  var sequences = [
    [rawOpenExpression$1, rawCloseExpression$1, true],
    [commentOpenExpression$1, commentCloseExpression$1, true],
    [instructionOpenExpression$1, instructionCloseExpression$1, true],
    [directiveOpenExpression$1, directiveCloseExpression$1, true],
    [cdataOpenExpression$1, cdataCloseExpression$1, true],
    [elementOpenExpression, elementCloseExpression$1, true],
    [otherElementOpenExpression$1, elementCloseExpression$1, false]
  ];

  // Eat initial spacing.
  while (index < length) {
    character = value.charAt(index);

    if (character !== tab$5 && character !== space$9) {
      break
    }

    index++;
  }

  if (value.charAt(index) !== lessThan$7) {
    return
  }

  next = value.indexOf(lineFeed$9, index + 1);
  next = next === -1 ? length : next;
  line = value.slice(index, next);
  offset = -1;
  count = sequences.length;

  while (++offset < count) {
    if (sequences[offset][0].test(line)) {
      sequence = sequences[offset];
      break
    }
  }

  if (!sequence) {
    return
  }

  if (silent) {
    return sequence[2]
  }

  index = next;

  if (!sequence[1].test(line)) {
    while (index < length) {
      next = value.indexOf(lineFeed$9, index + 1);
      next = next === -1 ? length : next;
      line = value.slice(index + 1, next);

      if (sequence[1].test(line)) {
        if (line) {
          index = next;
        }

        break
      }

      index = next;
    }
  }

  subvalue = value.slice(0, index);

  return eat(subvalue)({type: 'html', value: subvalue})
}

var isWhitespaceCharacter = whitespace$1;

var fromCode$1 = String.fromCharCode;
var re$2 = /\s/;

// Check if the given character code, or the character code at the first
// character, is a whitespace character.
function whitespace$1(character) {
  return re$2.test(
    typeof character === 'number' ? fromCode$1(character) : character.charAt(0)
  )
}

var collapseWhiteSpace = collapse;

// `collapse(' \t\nbar \nbaz\t') // ' bar baz '`
function collapse(value) {
  return String(value).replace(/\s+/g, ' ')
}

var normalize_1$1 = normalize$1;

// Normalize an identifier.  Collapses multiple white space characters into a
// single space, and removes casing.
function normalize$1(value) {
  return collapseWhiteSpace(value).toLowerCase()
}

var definition_1 = definition;

var quotationMark$2 = '"';
var apostrophe$3 = "'";
var backslash$6 = '\\';
var lineFeed$8 = '\n';
var tab$4 = '\t';
var space$8 = ' ';
var leftSquareBracket$2 = '[';
var rightSquareBracket$2 = ']';
var leftParenthesis$1 = '(';
var rightParenthesis$2 = ')';
var colon$2 = ':';
var lessThan$6 = '<';
var greaterThan$3 = '>';

function definition(eat, value, silent) {
  var self = this;
  var commonmark = self.options.commonmark;
  var index = 0;
  var length = value.length;
  var subvalue = '';
  var beforeURL;
  var beforeTitle;
  var queue;
  var character;
  var test;
  var identifier;
  var url;
  var title;

  while (index < length) {
    character = value.charAt(index);

    if (character !== space$8 && character !== tab$4) {
      break
    }

    subvalue += character;
    index++;
  }

  character = value.charAt(index);

  if (character !== leftSquareBracket$2) {
    return
  }

  index++;
  subvalue += character;
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (character === rightSquareBracket$2) {
      break
    } else if (character === backslash$6) {
      queue += character;
      index++;
      character = value.charAt(index);
    }

    queue += character;
    index++;
  }

  if (
    !queue ||
    value.charAt(index) !== rightSquareBracket$2 ||
    value.charAt(index + 1) !== colon$2
  ) {
    return
  }

  identifier = queue;
  subvalue += queue + rightSquareBracket$2 + colon$2;
  index = subvalue.length;
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (character !== tab$4 && character !== space$8 && character !== lineFeed$8) {
      break
    }

    subvalue += character;
    index++;
  }

  character = value.charAt(index);
  queue = '';
  beforeURL = subvalue;

  if (character === lessThan$6) {
    index++;

    while (index < length) {
      character = value.charAt(index);

      if (!isEnclosedURLCharacter(character)) {
        break
      }

      queue += character;
      index++;
    }

    character = value.charAt(index);

    if (character === isEnclosedURLCharacter.delimiter) {
      subvalue += lessThan$6 + queue + character;
      index++;
    } else {
      if (commonmark) {
        return
      }

      index -= queue.length + 1;
      queue = '';
    }
  }

  if (!queue) {
    while (index < length) {
      character = value.charAt(index);

      if (!isUnclosedURLCharacter(character)) {
        break
      }

      queue += character;
      index++;
    }

    subvalue += queue;
  }

  if (!queue) {
    return
  }

  url = queue;
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (character !== tab$4 && character !== space$8 && character !== lineFeed$8) {
      break
    }

    queue += character;
    index++;
  }

  character = value.charAt(index);
  test = null;

  if (character === quotationMark$2) {
    test = quotationMark$2;
  } else if (character === apostrophe$3) {
    test = apostrophe$3;
  } else if (character === leftParenthesis$1) {
    test = rightParenthesis$2;
  }

  if (!test) {
    queue = '';
    index = subvalue.length;
  } else if (queue) {
    subvalue += queue + character;
    index = subvalue.length;
    queue = '';

    while (index < length) {
      character = value.charAt(index);

      if (character === test) {
        break
      }

      if (character === lineFeed$8) {
        index++;
        character = value.charAt(index);

        if (character === lineFeed$8 || character === test) {
          return
        }

        queue += lineFeed$8;
      }

      queue += character;
      index++;
    }

    character = value.charAt(index);

    if (character !== test) {
      return
    }

    beforeTitle = subvalue;
    subvalue += queue + character;
    index++;
    title = queue;
    queue = '';
  } else {
    return
  }

  while (index < length) {
    character = value.charAt(index);

    if (character !== tab$4 && character !== space$8) {
      break
    }

    subvalue += character;
    index++;
  }

  character = value.charAt(index);

  if (!character || character === lineFeed$8) {
    if (silent) {
      return true
    }

    beforeURL = eat(beforeURL).test().end;
    url = self.decode.raw(self.unescape(url), beforeURL, {nonTerminated: false});

    if (title) {
      beforeTitle = eat(beforeTitle).test().end;
      title = self.decode.raw(self.unescape(title), beforeTitle);
    }

    return eat(subvalue)({
      type: 'definition',
      identifier: normalize_1$1(identifier),
      label: identifier,
      title: title || null,
      url: url
    })
  }
}

// Check if `character` can be inside an enclosed URI.
function isEnclosedURLCharacter(character) {
  return (
    character !== greaterThan$3 &&
    character !== leftSquareBracket$2 &&
    character !== rightSquareBracket$2
  )
}

isEnclosedURLCharacter.delimiter = greaterThan$3;

// Check if `character` can be inside an unclosed URI.
function isUnclosedURLCharacter(character) {
  return (
    character !== leftSquareBracket$2 &&
    character !== rightSquareBracket$2 &&
    !isWhitespaceCharacter(character)
  )
}

var table_1$1 = table$1;

var tab$3 = '\t';
var lineFeed$7 = '\n';
var space$7 = ' ';
var dash$4 = '-';
var colon$1 = ':';
var backslash$5 = '\\';
var verticalBar = '|';

var minColumns = 1;
var minRows = 2;

var left = 'left';
var center = 'center';
var right = 'right';

function table$1(eat, value, silent) {
  var self = this;
  var index;
  var alignments;
  var alignment;
  var subvalue;
  var row;
  var length;
  var lines;
  var queue;
  var character;
  var hasDash;
  var align;
  var cell;
  var preamble;
  var now;
  var position;
  var lineCount;
  var line;
  var rows;
  var table;
  var lineIndex;
  var pipeIndex;
  var first;

  // Exit when not in gfm-mode.
  if (!self.options.gfm) {
    return
  }

  // Get the rows.
  // Detecting tables soon is hard, so there are some checks for performance
  // here, such as the minimum number of rows, and allowed characters in the
  // alignment row.
  index = 0;
  lineCount = 0;
  length = value.length + 1;
  lines = [];

  while (index < length) {
    lineIndex = value.indexOf(lineFeed$7, index);
    pipeIndex = value.indexOf(verticalBar, index + 1);

    if (lineIndex === -1) {
      lineIndex = value.length;
    }

    if (pipeIndex === -1 || pipeIndex > lineIndex) {
      if (lineCount < minRows) {
        return
      }

      break
    }

    lines.push(value.slice(index, lineIndex));
    lineCount++;
    index = lineIndex + 1;
  }

  // Parse the alignment row.
  subvalue = lines.join(lineFeed$7);
  alignments = lines.splice(1, 1)[0] || [];
  index = 0;
  length = alignments.length;
  lineCount--;
  alignment = false;
  align = [];

  while (index < length) {
    character = alignments.charAt(index);

    if (character === verticalBar) {
      hasDash = null;

      if (alignment === false) {
        if (first === false) {
          return
        }
      } else {
        align.push(alignment);
        alignment = false;
      }

      first = false;
    } else if (character === dash$4) {
      hasDash = true;
      alignment = alignment || null;
    } else if (character === colon$1) {
      if (alignment === left) {
        alignment = center;
      } else if (hasDash && alignment === null) {
        alignment = right;
      } else {
        alignment = left;
      }
    } else if (!isWhitespaceCharacter(character)) {
      return
    }

    index++;
  }

  if (alignment !== false) {
    align.push(alignment);
  }

  // Exit when without enough columns.
  if (align.length < minColumns) {
    return
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true
  }

  // Parse the rows.
  position = -1;
  rows = [];

  table = eat(subvalue).reset({type: 'table', align: align, children: rows});

  while (++position < lineCount) {
    line = lines[position];
    row = {type: 'tableRow', children: []};

    // Eat a newline character when this is not the first row.
    if (position) {
      eat(lineFeed$7);
    }

    // Eat the row.
    eat(line).reset(row, table);

    length = line.length + 1;
    index = 0;
    queue = '';
    cell = '';
    preamble = true;

    while (index < length) {
      character = line.charAt(index);

      if (character === tab$3 || character === space$7) {
        if (cell) {
          queue += character;
        } else {
          eat(character);
        }

        index++;
        continue
      }

      if (character === '' || character === verticalBar) {
        if (preamble) {
          eat(character);
        } else {
          if ((cell || character) && !preamble) {
            subvalue = cell;

            if (queue.length > 1) {
              if (character) {
                subvalue += queue.slice(0, -1);
                queue = queue.charAt(queue.length - 1);
              } else {
                subvalue += queue;
                queue = '';
              }
            }

            now = eat.now();

            eat(subvalue)(
              {type: 'tableCell', children: self.tokenizeInline(cell, now)},
              row
            );
          }

          eat(queue + character);

          queue = '';
          cell = '';
        }
      } else {
        if (queue) {
          cell += queue;
          queue = '';
        }

        cell += character;

        if (character === backslash$5 && index !== length - 2) {
          cell += line.charAt(index + 1);
          index++;
        }
      }

      preamble = false;
      index++;
    }

    // Eat the alignment row.
    if (!position) {
      eat(lineFeed$7 + alignments);
    }
  }

  return table
}

var paragraph_1$1 = paragraph$1;

var tab$2 = '\t';
var lineFeed$6 = '\n';
var space$6 = ' ';

var tabSize = 4;

// Tokenise paragraph.
function paragraph$1(eat, value, silent) {
  var self = this;
  var settings = self.options;
  var commonmark = settings.commonmark;
  var tokenizers = self.blockTokenizers;
  var interruptors = self.interruptParagraph;
  var index = value.indexOf(lineFeed$6);
  var length = value.length;
  var position;
  var subvalue;
  var character;
  var size;
  var now;

  while (index < length) {
    // Eat everything if there’s no following newline.
    if (index === -1) {
      index = length;
      break
    }

    // Stop if the next character is NEWLINE.
    if (value.charAt(index + 1) === lineFeed$6) {
      break
    }

    // In commonmark-mode, following indented lines are part of the paragraph.
    if (commonmark) {
      size = 0;
      position = index + 1;

      while (position < length) {
        character = value.charAt(position);

        if (character === tab$2) {
          size = tabSize;
          break
        } else if (character === space$6) {
          size++;
        } else {
          break
        }

        position++;
      }

      if (size >= tabSize && character !== lineFeed$6) {
        index = value.indexOf(lineFeed$6, index + 1);
        continue
      }
    }

    subvalue = value.slice(index + 1);

    // Check if the following code contains a possible block.
    if (interrupt_1(interruptors, tokenizers, self, [eat, subvalue, true])) {
      break
    }

    position = index;
    index = value.indexOf(lineFeed$6, index + 1);

    if (index !== -1 && trim_1(value.slice(position, index)) === '') {
      index = position;
      break
    }
  }

  subvalue = value.slice(0, index);

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true
  }

  now = eat.now();
  subvalue = trimTrailingLines_1(subvalue);

  return eat(subvalue)({
    type: 'paragraph',
    children: self.tokenizeInline(subvalue, now)
  })
}

var _escape$1 = locate$9;

function locate$9(value, fromIndex) {
  return value.indexOf('\\', fromIndex)
}

var _escape = escape$1;
escape$1.locator = _escape$1;

var lineFeed$5 = '\n';
var backslash$4 = '\\';

function escape$1(eat, value, silent) {
  var self = this;
  var character;
  var node;

  if (value.charAt(0) === backslash$4) {
    character = value.charAt(1);

    if (self.escape.indexOf(character) !== -1) {
      /* istanbul ignore if - never used (yet) */
      if (silent) {
        return true
      }

      if (character === lineFeed$5) {
        node = {type: 'break'};
      } else {
        node = {type: 'text', value: character};
      }

      return eat(backslash$4 + character)(node)
    }
  }
}

var tag$1 = locate$8;

function locate$8(value, fromIndex) {
  return value.indexOf('<', fromIndex)
}

var autoLink_1 = autoLink;
autoLink.locator = tag$1;
autoLink.notInLink = true;

var lessThan$5 = '<';
var greaterThan$2 = '>';
var atSign$1 = '@';
var slash$3 = '/';
var mailto = 'mailto:';
var mailtoLength = mailto.length;

function autoLink(eat, value, silent) {
  var self = this;
  var subvalue = '';
  var length = value.length;
  var index = 0;
  var queue = '';
  var hasAtCharacter = false;
  var link = '';
  var character;
  var now;
  var content;
  var tokenizers;
  var exit;

  if (value.charAt(0) !== lessThan$5) {
    return
  }

  index++;
  subvalue = lessThan$5;

  while (index < length) {
    character = value.charAt(index);

    if (
      isWhitespaceCharacter(character) ||
      character === greaterThan$2 ||
      character === atSign$1 ||
      (character === ':' && value.charAt(index + 1) === slash$3)
    ) {
      break
    }

    queue += character;
    index++;
  }

  if (!queue) {
    return
  }

  link += queue;
  queue = '';

  character = value.charAt(index);
  link += character;
  index++;

  if (character === atSign$1) {
    hasAtCharacter = true;
  } else {
    if (character !== ':' || value.charAt(index + 1) !== slash$3) {
      return
    }

    link += slash$3;
    index++;
  }

  while (index < length) {
    character = value.charAt(index);

    if (isWhitespaceCharacter(character) || character === greaterThan$2) {
      break
    }

    queue += character;
    index++;
  }

  character = value.charAt(index);

  if (!queue || character !== greaterThan$2) {
    return
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true
  }

  link += queue;
  content = link;
  subvalue += link + character;
  now = eat.now();
  now.column++;
  now.offset++;

  if (hasAtCharacter) {
    if (link.slice(0, mailtoLength).toLowerCase() === mailto) {
      content = content.slice(mailtoLength);
      now.column += mailtoLength;
      now.offset += mailtoLength;
    } else {
      link = mailto + link;
    }
  }

  // Temporarily remove all tokenizers except text in autolinks.
  tokenizers = self.inlineTokenizers;
  self.inlineTokenizers = {text: tokenizers.text};

  exit = self.enterLink();

  content = self.tokenizeInline(content, now);

  self.inlineTokenizers = tokenizers;
  exit();

  return eat(subvalue)({
    type: 'link',
    title: null,
    url: parseEntities_1(link, {nonTerminated: false}),
    children: content
  })
}

var ccount_1 = ccount;

function ccount(value, character) {
  var val = String(value);
  var count = 0;
  var index;

  if (typeof character !== 'string' || character.length !== 1) {
    throw new Error('Expected character')
  }

  index = val.indexOf(character);

  while (index !== -1) {
    count++;
    index = val.indexOf(character, index + 1);
  }

  return count
}

var url$1 = locate$7;

var values = ['www.', 'http://', 'https://'];

function locate$7(value, fromIndex) {
  var min = -1;
  var index;
  var length;
  var position;

  if (!this.options.gfm) {
    return min
  }

  length = values.length;
  index = -1;

  while (++index < length) {
    position = value.indexOf(values[index], fromIndex);

    if (position !== -1 && (min === -1 || position < min)) {
      min = position;
    }
  }

  return min
}

var url_1 = url;
url.locator = url$1;
url.notInLink = true;

var exclamationMark$3 = 33; // '!'
var ampersand = 38; // '&'
var rightParenthesis$1 = 41; // ')'
var asterisk$2 = 42; // '*'
var comma$1 = 44; // ','
var dash$3 = 45; // '-'
var dot$2 = 46; // '.'
var colon = 58; // ':'
var semicolon = 59; // ';'
var questionMark$1 = 63; // '?'
var lessThan$4 = 60; // '<'
var underscore$4 = 95; // '_'
var tilde$2 = 126; // '~'

var leftParenthesisCharacter = '(';
var rightParenthesisCharacter = ')';

function url(eat, value, silent) {
  var self = this;
  var gfm = self.options.gfm;
  var tokenizers = self.inlineTokenizers;
  var length = value.length;
  var previousDot = -1;
  var protocolless = false;
  var dots;
  var lastTwoPartsStart;
  var start;
  var index;
  var pathStart;
  var path;
  var code;
  var end;
  var leftCount;
  var rightCount;
  var content;
  var children;
  var url;
  var exit;

  if (!gfm) {
    return
  }

  // `WWW.` doesn’t work.
  if (value.slice(0, 4) === 'www.') {
    protocolless = true;
    index = 4;
  } else if (value.slice(0, 7).toLowerCase() === 'http://') {
    index = 7;
  } else if (value.slice(0, 8).toLowerCase() === 'https://') {
    index = 8;
  } else {
    return
  }

  // Act as if the starting boundary is a dot.
  previousDot = index - 1;

  // Parse a valid domain.
  start = index;
  dots = [];

  while (index < length) {
    code = value.charCodeAt(index);

    if (code === dot$2) {
      // Dots may not appear after each other.
      if (previousDot === index - 1) {
        break
      }

      dots.push(index);
      previousDot = index;
      index++;
      continue
    }

    if (
      isDecimal(code) ||
      isAlphabetical(code) ||
      code === dash$3 ||
      code === underscore$4
    ) {
      index++;
      continue
    }

    break
  }

  // Ignore a final dot:
  if (code === dot$2) {
    dots.pop();
    index--;
  }

  // If there are not dots, exit.
  if (dots[0] === undefined) {
    return
  }

  // If there is an underscore in the last two domain parts, exit:
  // `www.example.c_m` and `www.ex_ample.com` are not OK, but
  // `www.sub_domain.example.com` is.
  lastTwoPartsStart = dots.length < 2 ? start : dots[dots.length - 2] + 1;

  if (value.slice(lastTwoPartsStart, index).indexOf('_') !== -1) {
    return
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true
  }

  end = index;
  pathStart = index;

  // Parse a path.
  while (index < length) {
    code = value.charCodeAt(index);

    if (isWhitespaceCharacter(code) || code === lessThan$4) {
      break
    }

    index++;

    if (
      code === exclamationMark$3 ||
      code === asterisk$2 ||
      code === comma$1 ||
      code === dot$2 ||
      code === colon ||
      code === questionMark$1 ||
      code === underscore$4 ||
      code === tilde$2
    ) ; else {
      end = index;
    }
  }

  index = end;

  // If the path ends in a closing paren, and the count of closing parens is
  // higher than the opening count, then remove the supefluous closing parens.
  if (value.charCodeAt(index - 1) === rightParenthesis$1) {
    path = value.slice(pathStart, index);
    leftCount = ccount_1(path, leftParenthesisCharacter);
    rightCount = ccount_1(path, rightParenthesisCharacter);

    while (rightCount > leftCount) {
      index = pathStart + path.lastIndexOf(rightParenthesisCharacter);
      path = value.slice(pathStart, index);
      rightCount--;
    }
  }

  if (value.charCodeAt(index - 1) === semicolon) {
    // GitHub doesn’t document this, but final semicolons aren’t paret of the
    // URL either.
    index--;

    // // If the path ends in what looks like an entity, it’s not part of the path.
    if (isAlphabetical(value.charCodeAt(index - 1))) {
      end = index - 2;

      while (isAlphabetical(value.charCodeAt(end))) {
        end--;
      }

      if (value.charCodeAt(end) === ampersand) {
        index = end;
      }
    }
  }

  content = value.slice(0, index);
  url = parseEntities_1(content, {nonTerminated: false});

  if (protocolless) {
    url = 'http://' + url;
  }

  exit = self.enterLink();

  // Temporarily remove all tokenizers except text in url.
  self.inlineTokenizers = {text: tokenizers.text};
  children = self.tokenizeInline(content, eat.now());
  self.inlineTokenizers = tokenizers;

  exit();

  return eat(content)({type: 'link', title: null, url: url, children: children})
}

var plusSign$1 = 43; // '+'
var dash$2 = 45; // '-'
var dot$1 = 46; // '.'
var underscore$3 = 95; // '_'

var email$1 = locate$6;

// See: <https://github.github.com/gfm/#extended-email-autolink>
function locate$6(value, fromIndex) {
  var self = this;
  var at;
  var position;

  if (!this.options.gfm) {
    return -1
  }

  at = value.indexOf('@', fromIndex);

  if (at === -1) {
    return -1
  }

  position = at;

  if (position === fromIndex || !isGfmAtext(value.charCodeAt(position - 1))) {
    return locate$6.call(self, value, at + 1)
  }

  while (position > fromIndex && isGfmAtext(value.charCodeAt(position - 1))) {
    position--;
  }

  return position
}

function isGfmAtext(code) {
  return (
    isDecimal(code) ||
    isAlphabetical(code) ||
    code === plusSign$1 ||
    code === dash$2 ||
    code === dot$1 ||
    code === underscore$3
  )
}

var email_1 = email;
email.locator = email$1;
email.notInLink = true;

var plusSign = 43; // '+'
var dash$1 = 45; // '-'
var dot = 46; // '.'
var atSign = 64; // '@'
var underscore$2 = 95; // '_'

function email(eat, value, silent) {
  var self = this;
  var gfm = self.options.gfm;
  var tokenizers = self.inlineTokenizers;
  var index = 0;
  var length = value.length;
  var firstDot = -1;
  var code;
  var content;
  var children;
  var exit;

  if (!gfm) {
    return
  }

  code = value.charCodeAt(index);

  while (
    isDecimal(code) ||
    isAlphabetical(code) ||
    code === plusSign ||
    code === dash$1 ||
    code === dot ||
    code === underscore$2
  ) {
    code = value.charCodeAt(++index);
  }

  if (index === 0) {
    return
  }

  if (code !== atSign) {
    return
  }

  index++;

  while (index < length) {
    code = value.charCodeAt(index);

    if (
      isDecimal(code) ||
      isAlphabetical(code) ||
      code === dash$1 ||
      code === dot ||
      code === underscore$2
    ) {
      index++;

      if (firstDot === -1 && code === dot) {
        firstDot = index;
      }

      continue
    }

    break
  }

  if (
    firstDot === -1 ||
    firstDot === index ||
    code === dash$1 ||
    code === underscore$2
  ) {
    return
  }

  if (code === dot) {
    index--;
  }

  content = value.slice(0, index);

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true
  }

  exit = self.enterLink();

  // Temporarily remove all tokenizers except text in url.
  self.inlineTokenizers = {text: tokenizers.text};
  children = self.tokenizeInline(content, eat.now());
  self.inlineTokenizers = tokenizers;

  exit();

  return eat(content)({
    type: 'link',
    title: null,
    url: 'mailto:' + parseEntities_1(content, {nonTerminated: false}),
    children: children
  })
}

var tag = html$4.tag;

var htmlInline = inlineHTML;
inlineHTML.locator = tag$1;

var lessThan$3 = '<';
var questionMark = '?';
var exclamationMark$2 = '!';
var slash$2 = '/';

var htmlLinkOpenExpression = /^<a /i;
var htmlLinkCloseExpression = /^<\/a>/i;

function inlineHTML(eat, value, silent) {
  var self = this;
  var length = value.length;
  var character;
  var subvalue;

  if (value.charAt(0) !== lessThan$3 || length < 3) {
    return
  }

  character = value.charAt(1);

  if (
    !isAlphabetical(character) &&
    character !== questionMark &&
    character !== exclamationMark$2 &&
    character !== slash$2
  ) {
    return
  }

  subvalue = value.match(tag);

  if (!subvalue) {
    return
  }

  /* istanbul ignore if - not used yet. */
  if (silent) {
    return true
  }

  subvalue = subvalue[0];

  if (!self.inLink && htmlLinkOpenExpression.test(subvalue)) {
    self.inLink = true;
  } else if (self.inLink && htmlLinkCloseExpression.test(subvalue)) {
    self.inLink = false;
  }

  return eat(subvalue)({type: 'html', value: subvalue})
}

var link$3 = locate$5;

function locate$5(value, fromIndex) {
  var link = value.indexOf('[', fromIndex);
  var image = value.indexOf('![', fromIndex);

  if (image === -1) {
    return link
  }

  // Link can never be `-1` if an image is found, so we don’t need to check
  // for that :)
  return link < image ? link : image
}

var link_1$1 = link$2;
link$2.locator = link$3;

var lineFeed$4 = '\n';
var exclamationMark$1 = '!';
var quotationMark$1 = '"';
var apostrophe$2 = "'";
var leftParenthesis = '(';
var rightParenthesis = ')';
var lessThan$2 = '<';
var greaterThan$1 = '>';
var leftSquareBracket$1 = '[';
var backslash$3 = '\\';
var rightSquareBracket$1 = ']';
var graveAccent$1 = '`';

function link$2(eat, value, silent) {
  var self = this;
  var subvalue = '';
  var index = 0;
  var character = value.charAt(0);
  var pedantic = self.options.pedantic;
  var commonmark = self.options.commonmark;
  var gfm = self.options.gfm;
  var closed;
  var count;
  var opening;
  var beforeURL;
  var beforeTitle;
  var subqueue;
  var hasMarker;
  var isImage;
  var content;
  var marker;
  var length;
  var title;
  var depth;
  var queue;
  var url;
  var now;
  var exit;
  var node;

  // Detect whether this is an image.
  if (character === exclamationMark$1) {
    isImage = true;
    subvalue = character;
    character = value.charAt(++index);
  }

  // Eat the opening.
  if (character !== leftSquareBracket$1) {
    return
  }

  // Exit when this is a link and we’re already inside a link.
  if (!isImage && self.inLink) {
    return
  }

  subvalue += character;
  queue = '';
  index++;

  // Eat the content.
  length = value.length;
  now = eat.now();
  depth = 0;

  now.column += index;
  now.offset += index;

  while (index < length) {
    character = value.charAt(index);
    subqueue = character;

    if (character === graveAccent$1) {
      // Inline-code in link content.
      count = 1;

      while (value.charAt(index + 1) === graveAccent$1) {
        subqueue += character;
        index++;
        count++;
      }

      if (!opening) {
        opening = count;
      } else if (count >= opening) {
        opening = 0;
      }
    } else if (character === backslash$3) {
      // Allow brackets to be escaped.
      index++;
      subqueue += value.charAt(index);
    } else if ((!opening || gfm) && character === leftSquareBracket$1) {
      // In GFM mode, brackets in code still count.  In all other modes,
      // they don’t.
      depth++;
    } else if ((!opening || gfm) && character === rightSquareBracket$1) {
      if (depth) {
        depth--;
      } else {
        if (value.charAt(index + 1) !== leftParenthesis) {
          return
        }

        subqueue += leftParenthesis;
        closed = true;
        index++;

        break
      }
    }

    queue += subqueue;
    subqueue = '';
    index++;
  }

  // Eat the content closing.
  if (!closed) {
    return
  }

  content = queue;
  subvalue += queue + subqueue;
  index++;

  // Eat white-space.
  while (index < length) {
    character = value.charAt(index);

    if (!isWhitespaceCharacter(character)) {
      break
    }

    subvalue += character;
    index++;
  }

  // Eat the URL.
  character = value.charAt(index);
  queue = '';
  beforeURL = subvalue;

  if (character === lessThan$2) {
    index++;
    beforeURL += lessThan$2;

    while (index < length) {
      character = value.charAt(index);

      if (character === greaterThan$1) {
        break
      }

      if (commonmark && character === lineFeed$4) {
        return
      }

      queue += character;
      index++;
    }

    if (value.charAt(index) !== greaterThan$1) {
      return
    }

    subvalue += lessThan$2 + queue + greaterThan$1;
    url = queue;
    index++;
  } else {
    character = null;
    subqueue = '';

    while (index < length) {
      character = value.charAt(index);

      if (
        subqueue &&
        (character === quotationMark$1 ||
          character === apostrophe$2 ||
          (commonmark && character === leftParenthesis))
      ) {
        break
      }

      if (isWhitespaceCharacter(character)) {
        if (!pedantic) {
          break
        }

        subqueue += character;
      } else {
        if (character === leftParenthesis) {
          depth++;
        } else if (character === rightParenthesis) {
          if (depth === 0) {
            break
          }

          depth--;
        }

        queue += subqueue;
        subqueue = '';

        if (character === backslash$3) {
          queue += backslash$3;
          character = value.charAt(++index);
        }

        queue += character;
      }

      index++;
    }

    subvalue += queue;
    url = queue;
    index = subvalue.length;
  }

  // Eat white-space.
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (!isWhitespaceCharacter(character)) {
      break
    }

    queue += character;
    index++;
  }

  character = value.charAt(index);
  subvalue += queue;

  // Eat the title.
  if (
    queue &&
    (character === quotationMark$1 ||
      character === apostrophe$2 ||
      (commonmark && character === leftParenthesis))
  ) {
    index++;
    subvalue += character;
    queue = '';
    marker = character === leftParenthesis ? rightParenthesis : character;
    beforeTitle = subvalue;

    // In commonmark-mode, things are pretty easy: the marker cannot occur
    // inside the title.  Non-commonmark does, however, support nested
    // delimiters.
    if (commonmark) {
      while (index < length) {
        character = value.charAt(index);

        if (character === marker) {
          break
        }

        if (character === backslash$3) {
          queue += backslash$3;
          character = value.charAt(++index);
        }

        index++;
        queue += character;
      }

      character = value.charAt(index);

      if (character !== marker) {
        return
      }

      title = queue;
      subvalue += queue + character;
      index++;

      while (index < length) {
        character = value.charAt(index);

        if (!isWhitespaceCharacter(character)) {
          break
        }

        subvalue += character;
        index++;
      }
    } else {
      subqueue = '';

      while (index < length) {
        character = value.charAt(index);

        if (character === marker) {
          if (hasMarker) {
            queue += marker + subqueue;
            subqueue = '';
          }

          hasMarker = true;
        } else if (!hasMarker) {
          queue += character;
        } else if (character === rightParenthesis) {
          subvalue += queue + marker + subqueue;
          title = queue;
          break
        } else if (isWhitespaceCharacter(character)) {
          subqueue += character;
        } else {
          queue += marker + subqueue + character;
          subqueue = '';
          hasMarker = false;
        }

        index++;
      }
    }
  }

  if (value.charAt(index) !== rightParenthesis) {
    return
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true
  }

  subvalue += rightParenthesis;

  url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end, {
    nonTerminated: false
  });

  if (title) {
    beforeTitle = eat(beforeTitle).test().end;
    title = self.decode.raw(self.unescape(title), beforeTitle);
  }

  node = {
    type: isImage ? 'image' : 'link',
    title: title || null,
    url: url
  };

  if (isImage) {
    node.alt = self.decode.raw(self.unescape(content), now) || null;
  } else {
    exit = self.enterLink();
    node.children = self.tokenizeInline(content, now);
    exit();
  }

  return eat(subvalue)(node)
}

var reference_1 = reference;
reference.locator = link$3;

var link$1 = 'link';
var image$2 = 'image';
var shortcut = 'shortcut';
var collapsed = 'collapsed';
var full = 'full';
var exclamationMark = '!';
var leftSquareBracket = '[';
var backslash$2 = '\\';
var rightSquareBracket = ']';

function reference(eat, value, silent) {
  var self = this;
  var commonmark = self.options.commonmark;
  var character = value.charAt(0);
  var index = 0;
  var length = value.length;
  var subvalue = '';
  var intro = '';
  var type = link$1;
  var referenceType = shortcut;
  var content;
  var identifier;
  var now;
  var node;
  var exit;
  var queue;
  var bracketed;
  var depth;

  // Check whether we’re eating an image.
  if (character === exclamationMark) {
    type = image$2;
    intro = character;
    character = value.charAt(++index);
  }

  if (character !== leftSquareBracket) {
    return
  }

  index++;
  intro += character;
  queue = '';

  // Eat the text.
  depth = 0;

  while (index < length) {
    character = value.charAt(index);

    if (character === leftSquareBracket) {
      bracketed = true;
      depth++;
    } else if (character === rightSquareBracket) {
      if (!depth) {
        break
      }

      depth--;
    }

    if (character === backslash$2) {
      queue += backslash$2;
      character = value.charAt(++index);
    }

    queue += character;
    index++;
  }

  subvalue = queue;
  content = queue;
  character = value.charAt(index);

  if (character !== rightSquareBracket) {
    return
  }

  index++;
  subvalue += character;
  queue = '';

  if (!commonmark) {
    // The original markdown syntax definition explicitly allows for whitespace
    // between the link text and link label; commonmark departs from this, in
    // part to improve support for shortcut reference links
    while (index < length) {
      character = value.charAt(index);

      if (!isWhitespaceCharacter(character)) {
        break
      }

      queue += character;
      index++;
    }
  }

  character = value.charAt(index);

  if (character === leftSquareBracket) {
    identifier = '';
    queue += character;
    index++;

    while (index < length) {
      character = value.charAt(index);

      if (character === leftSquareBracket || character === rightSquareBracket) {
        break
      }

      if (character === backslash$2) {
        identifier += backslash$2;
        character = value.charAt(++index);
      }

      identifier += character;
      index++;
    }

    character = value.charAt(index);

    if (character === rightSquareBracket) {
      referenceType = identifier ? full : collapsed;
      queue += identifier + character;
      index++;
    } else {
      identifier = '';
    }

    subvalue += queue;
    queue = '';
  } else {
    if (!content) {
      return
    }

    identifier = content;
  }

  // Brackets cannot be inside the identifier.
  if (referenceType !== full && bracketed) {
    return
  }

  subvalue = intro + subvalue;

  if (type === link$1 && self.inLink) {
    return null
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true
  }

  now = eat.now();
  now.column += intro.length;
  now.offset += intro.length;
  identifier = referenceType === full ? identifier : content;

  node = {
    type: type + 'Reference',
    identifier: normalize_1$1(identifier),
    label: identifier,
    referenceType: referenceType
  };

  if (type === link$1) {
    exit = self.enterLink();
    node.children = self.tokenizeInline(content, now);
    exit();
  } else {
    node.alt = self.decode.raw(self.unescape(content), now) || null;
  }

  return eat(subvalue)(node)
}

var strong$2 = locate$4;

function locate$4(value, fromIndex) {
  var asterisk = value.indexOf('**', fromIndex);
  var underscore = value.indexOf('__', fromIndex);

  if (underscore === -1) {
    return asterisk
  }

  if (asterisk === -1) {
    return underscore
  }

  return underscore < asterisk ? underscore : asterisk
}

var strong_1$1 = strong$1;
strong$1.locator = strong$2;

var backslash$1 = '\\';
var asterisk$1 = '*';
var underscore$1 = '_';

function strong$1(eat, value, silent) {
  var self = this;
  var index = 0;
  var character = value.charAt(index);
  var now;
  var pedantic;
  var marker;
  var queue;
  var subvalue;
  var length;
  var previous;

  if (
    (character !== asterisk$1 && character !== underscore$1) ||
    value.charAt(++index) !== character
  ) {
    return
  }

  pedantic = self.options.pedantic;
  marker = character;
  subvalue = marker + marker;
  length = value.length;
  index++;
  queue = '';
  character = '';

  if (pedantic && isWhitespaceCharacter(value.charAt(index))) {
    return
  }

  while (index < length) {
    previous = character;
    character = value.charAt(index);

    if (
      character === marker &&
      value.charAt(index + 1) === marker &&
      (!pedantic || !isWhitespaceCharacter(previous))
    ) {
      character = value.charAt(index + 2);

      if (character !== marker) {
        if (!trim_1(queue)) {
          return
        }

        /* istanbul ignore if - never used (yet) */
        if (silent) {
          return true
        }

        now = eat.now();
        now.column += 2;
        now.offset += 2;

        return eat(subvalue + queue + subvalue)({
          type: 'strong',
          children: self.tokenizeInline(queue, now)
        })
      }
    }

    if (!pedantic && character === backslash$1) {
      queue += character;
      character = value.charAt(++index);
    }

    queue += character;
    index++;
  }
}

var isWordCharacter = wordCharacter;

var fromCode = String.fromCharCode;
var re$1 = /\w/;

// Check if the given character code, or the character code at the first
// character, is a word character.
function wordCharacter(character) {
  return re$1.test(
    typeof character === 'number' ? fromCode(character) : character.charAt(0)
  )
}

var emphasis$2 = locate$3;

function locate$3(value, fromIndex) {
  var asterisk = value.indexOf('*', fromIndex);
  var underscore = value.indexOf('_', fromIndex);

  if (underscore === -1) {
    return asterisk
  }

  if (asterisk === -1) {
    return underscore
  }

  return underscore < asterisk ? underscore : asterisk
}

var emphasis_1$1 = emphasis$1;
emphasis$1.locator = emphasis$2;

var asterisk = '*';
var underscore = '_';
var backslash = '\\';

function emphasis$1(eat, value, silent) {
  var self = this;
  var index = 0;
  var character = value.charAt(index);
  var now;
  var pedantic;
  var marker;
  var queue;
  var subvalue;
  var length;
  var previous;

  if (character !== asterisk && character !== underscore) {
    return
  }

  pedantic = self.options.pedantic;
  subvalue = character;
  marker = character;
  length = value.length;
  index++;
  queue = '';
  character = '';

  if (pedantic && isWhitespaceCharacter(value.charAt(index))) {
    return
  }

  while (index < length) {
    previous = character;
    character = value.charAt(index);

    if (character === marker && (!pedantic || !isWhitespaceCharacter(previous))) {
      character = value.charAt(++index);

      if (character !== marker) {
        if (!trim_1(queue) || previous === marker) {
          return
        }

        if (!pedantic && marker === underscore && isWordCharacter(character)) {
          queue += marker;
          continue
        }

        /* istanbul ignore if - never used (yet) */
        if (silent) {
          return true
        }

        now = eat.now();
        now.column++;
        now.offset++;

        return eat(subvalue + queue + marker)({
          type: 'emphasis',
          children: self.tokenizeInline(queue, now)
        })
      }

      queue += marker;
    }

    if (!pedantic && character === backslash) {
      queue += character;
      character = value.charAt(++index);
    }

    queue += character;
    index++;
  }
}

var _delete$2 = locate$2;

function locate$2(value, fromIndex) {
  return value.indexOf('~~', fromIndex)
}

var _delete$1 = strikethrough$1;
strikethrough$1.locator = _delete$2;

var tilde$1 = '~';
var fence$1 = '~~';

function strikethrough$1(eat, value, silent) {
  var self = this;
  var character = '';
  var previous = '';
  var preceding = '';
  var subvalue = '';
  var index;
  var length;
  var now;

  if (
    !self.options.gfm ||
    value.charAt(0) !== tilde$1 ||
    value.charAt(1) !== tilde$1 ||
    isWhitespaceCharacter(value.charAt(2))
  ) {
    return
  }

  index = 1;
  length = value.length;
  now = eat.now();
  now.column += 2;
  now.offset += 2;

  while (++index < length) {
    character = value.charAt(index);

    if (
      character === tilde$1 &&
      previous === tilde$1 &&
      (!preceding || !isWhitespaceCharacter(preceding))
    ) {
      /* istanbul ignore if - never used (yet) */
      if (silent) {
        return true
      }

      return eat(fence$1 + subvalue + fence$1)({
        type: 'delete',
        children: self.tokenizeInline(subvalue, now)
      })
    }

    subvalue += previous;
    preceding = previous;
    previous = character;
  }
}

var codeInline$1 = locate$1;

function locate$1(value, fromIndex) {
  return value.indexOf('`', fromIndex)
}

var codeInline = inlineCode$1;
inlineCode$1.locator = codeInline$1;

var lineFeed$3 = 10; //  '\n'
var space$5 = 32; // ' '
var graveAccent = 96; //  '`'

function inlineCode$1(eat, value, silent) {
  var length = value.length;
  var index = 0;
  var openingFenceEnd;
  var closingFenceStart;
  var closingFenceEnd;
  var code;
  var next;
  var found;

  while (index < length) {
    if (value.charCodeAt(index) !== graveAccent) {
      break
    }

    index++;
  }

  if (index === 0 || index === length) {
    return
  }

  openingFenceEnd = index;
  next = value.charCodeAt(index);

  while (index < length) {
    code = next;
    next = value.charCodeAt(index + 1);

    if (code === graveAccent) {
      if (closingFenceStart === undefined) {
        closingFenceStart = index;
      }

      closingFenceEnd = index + 1;

      if (
        next !== graveAccent &&
        closingFenceEnd - closingFenceStart === openingFenceEnd
      ) {
        found = true;
        break
      }
    } else if (closingFenceStart !== undefined) {
      closingFenceStart = undefined;
      closingFenceEnd = undefined;
    }

    index++;
  }

  if (!found) {
    return
  }

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true
  }

  // Remove the initial and final space (or line feed), iff they exist and there
  // are non-space characters in the content.
  index = openingFenceEnd;
  length = closingFenceStart;
  code = value.charCodeAt(index);
  next = value.charCodeAt(length - 1);
  found = false;

  if (
    length - index > 2 &&
    (code === space$5 || code === lineFeed$3) &&
    (next === space$5 || next === lineFeed$3)
  ) {
    index++;
    length--;

    while (index < length) {
      code = value.charCodeAt(index);

      if (code !== space$5 && code !== lineFeed$3) {
        found = true;
        break
      }

      index++;
    }

    if (found === true) {
      openingFenceEnd++;
      closingFenceStart--;
    }
  }

  return eat(value.slice(0, closingFenceEnd))({
    type: 'inlineCode',
    value: value.slice(openingFenceEnd, closingFenceStart)
  })
}

var _break$2 = locate;

function locate(value, fromIndex) {
  var index = value.indexOf('\n', fromIndex);

  while (index > fromIndex) {
    if (value.charAt(index - 1) !== ' ') {
      break
    }

    index--;
  }

  return index
}

var _break$1 = hardBreak$1;
hardBreak$1.locator = _break$2;

var space$4 = ' ';
var lineFeed$2 = '\n';
var minBreakLength = 2;

function hardBreak$1(eat, value, silent) {
  var length = value.length;
  var index = -1;
  var queue = '';
  var character;

  while (++index < length) {
    character = value.charAt(index);

    if (character === lineFeed$2) {
      if (index < minBreakLength) {
        return
      }

      /* istanbul ignore if - never used (yet) */
      if (silent) {
        return true
      }

      queue += character;

      return eat(queue)({type: 'break'})
    }

    if (character !== space$4) {
      return
    }

    queue += character;
  }
}

var text_1$2 = text$3;

function text$3(eat, value, silent) {
  var self = this;
  var methods;
  var tokenizers;
  var index;
  var length;
  var subvalue;
  var position;
  var tokenizer;
  var name;
  var min;
  var now;

  /* istanbul ignore if - never used (yet) */
  if (silent) {
    return true
  }

  methods = self.inlineMethods;
  length = methods.length;
  tokenizers = self.inlineTokenizers;
  index = -1;
  min = value.length;

  while (++index < length) {
    name = methods[index];

    if (name === 'text' || !tokenizers[name]) {
      continue
    }

    tokenizer = tokenizers[name].locator;

    if (!tokenizer) {
      eat.file.fail('Missing locator: `' + name + '`');
    }

    position = tokenizer.call(self, value, 1);

    if (position !== -1 && position < min) {
      min = position;
    }
  }

  subvalue = value.slice(0, min);
  now = eat.now();

  self.decode(subvalue, now, handler);

  function handler(content, position, source) {
    eat(source || content)({type: 'text', value: content});
  }
}

var parser$1 = Parser;

function Parser(doc, file) {
  this.file = file;
  this.offset = {};
  this.options = immutable(this.options);
  this.setOptions({});

  this.inList = false;
  this.inBlock = false;
  this.inLink = false;
  this.atStart = true;

  this.toOffset = vfileLocation(file).toOffset;
  this.unescape = _unescape(this, 'escape');
  this.decode = decode(this);
}

var proto$3 = Parser.prototype;

// Expose core.
proto$3.setOptions = setOptions_1;
proto$3.parse = parse_1$2;

// Expose `defaults`.
proto$3.options = defaults$1;

// Enter and exit helpers.
proto$3.exitStart = stateToggle('atStart', true);
proto$3.enterList = stateToggle('inList', false);
proto$3.enterLink = stateToggle('inLink', false);
proto$3.enterBlock = stateToggle('inBlock', false);

// Nodes that can interupt a paragraph:
//
// ```markdown
// A paragraph, followed by a thematic break.
// ___
// ```
//
// In the above example, the thematic break “interupts” the paragraph.
proto$3.interruptParagraph = [
  ['thematicBreak'],
  ['list'],
  ['atxHeading'],
  ['fencedCode'],
  ['blockquote'],
  ['html'],
  ['setextHeading', {commonmark: false}],
  ['definition', {commonmark: false}]
];

// Nodes that can interupt a list:
//
// ```markdown
// - One
// ___
// ```
//
// In the above example, the thematic break “interupts” the list.
proto$3.interruptList = [
  ['atxHeading', {pedantic: false}],
  ['fencedCode', {pedantic: false}],
  ['thematicBreak', {pedantic: false}],
  ['definition', {commonmark: false}]
];

// Nodes that can interupt a blockquote:
//
// ```markdown
// > A paragraph.
// ___
// ```
//
// In the above example, the thematic break “interupts” the blockquote.
proto$3.interruptBlockquote = [
  ['indentedCode', {commonmark: true}],
  ['fencedCode', {commonmark: true}],
  ['atxHeading', {commonmark: true}],
  ['setextHeading', {commonmark: true}],
  ['thematicBreak', {commonmark: true}],
  ['html', {commonmark: true}],
  ['list', {commonmark: true}],
  ['definition', {commonmark: false}]
];

// Handlers.
proto$3.blockTokenizers = {
  blankLine: blankLine_1,
  indentedCode: codeIndented,
  fencedCode: codeFenced,
  blockquote: blockquote_1$1,
  atxHeading: headingAtx,
  thematicBreak: thematicBreak_1$1,
  list: list_1$1,
  setextHeading: headingSetext,
  html: htmlBlock,
  definition: definition_1,
  table: table_1$1,
  paragraph: paragraph_1$1
};

proto$3.inlineTokenizers = {
  escape: _escape,
  autoLink: autoLink_1,
  url: url_1,
  email: email_1,
  html: htmlInline,
  link: link_1$1,
  reference: reference_1,
  strong: strong_1$1,
  emphasis: emphasis_1$1,
  deletion: _delete$1,
  code: codeInline,
  break: _break$1,
  text: text_1$2
};

// Expose precedence.
proto$3.blockMethods = keys$1(proto$3.blockTokenizers);
proto$3.inlineMethods = keys$1(proto$3.inlineTokenizers);

// Tokenizers.
proto$3.tokenizeBlock = tokenizer$1('block');
proto$3.tokenizeInline = tokenizer$1('inline');
proto$3.tokenizeFactory = tokenizer$1;

// Get all keys in `value`.
function keys$1(value) {
  var result = [];
  var key;

  for (key in value) {
    result.push(key);
  }

  return result
}

var remarkParse = parse$5;
parse$5.Parser = parser$1;

function parse$5(options) {
  var settings = this.data('settings');
  var Local = unherit_1(parser$1);

  Local.prototype.options = immutable(Local.prototype.options, settings, options);

  this.Parser = Local;
}

var mdastUtilDefinitions$1 = getDefinitionFactory$1;

var own$a = {}.hasOwnProperty;

// Get a definition in `node` by `identifier`.
function getDefinitionFactory$1(node, options) {
  return getterFactory$1(gather$1(node, options))
}

// Gather all definitions in `node`
function gather$1(node, options) {
  var cache = {};

  if (!node || !node.type) {
    throw new Error('mdast-util-definitions expected node')
  }

  unistUtilVisit(node, 'definition', options && options.commonmark ? commonmark : normal);

  return cache

  function commonmark(definition) {
    var id = normalise$1(definition.identifier);
    if (!own$a.call(cache, id)) {
      cache[id] = definition;
    }
  }

  function normal(definition) {
    cache[normalise$1(definition.identifier)] = definition;
  }
}

// Factory to get a node from the given definition-cache.
function getterFactory$1(cache) {
  return getter

  // Get a node from the bound definition-cache.
  function getter(identifier) {
    var id = identifier && normalise$1(identifier);
    return id && own$a.call(cache, id) ? cache[id] : null
  }
}

function normalise$1(identifier) {
  return identifier.toUpperCase()
}

var parse_1$1 = parse$4;
var stringify_1$1 = stringify$3;

var empty$2 = '';
var space$3 = ' ';
var whiteSpace$1 = /[ \t\n\r\f]+/g;

function parse$4(value) {
  var input = String(value || empty$2).trim();
  return input === empty$2 ? [] : input.split(whiteSpace$1)
}

function stringify$3(values) {
  return values.join(space$3).trim()
}

var spaceSeparatedTokens = {
	parse: parse_1$1,
	stringify: stringify_1$1
};

var isAbsoluteUrl = url => {
	if (typeof url !== 'string') {
		throw new TypeError(`Expected a \`string\`, got \`${typeof url}\``);
	}

	// Don't match Windows paths `c:\`
	if (/^[a-zA-Z]:\\/.test(url)) {
		return false;
	}

	// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
	// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
	return /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(url);
};

var spaceSeparated$4 = spaceSeparatedTokens.parse;



var remarkExternalLinks = externalLinks;

var defaultTarget = '_blank';
var defaultRel = ['nofollow', 'noopener', 'noreferrer'];
var defaultProtocols = ['http', 'https'];

function externalLinks(options) {
  var settings = options || {};
  var target = settings.target;
  var rel = settings.rel;
  var protocols = settings.protocols || defaultProtocols;
  var content = settings.content;
  var contentProperties = settings.contentProperties || {};

  if (typeof rel === 'string') {
    rel = spaceSeparated$4(rel);
  }

  if (content && typeof content === 'object' && !('length' in content)) {
    content = [content];
  }

  return transform

  function transform(tree) {
    var definition = mdastUtilDefinitions$1(tree);

    unistUtilVisit(tree, ['link', 'linkReference'], visitor);

    function visitor(node) {
      var ctx = node.type === 'link' ? node : definition(node.identifier);
      var protocol;
      var data;
      var props;

      if (!ctx) return

      protocol = ctx.url.slice(0, ctx.url.indexOf(':'));

      if (isAbsoluteUrl(ctx.url) && protocols.indexOf(protocol) !== -1) {
        data = node.data || (node.data = {});
        props = data.hProperties || (data.hProperties = {});

        if (target !== false) {
          props.target = target || defaultTarget;
        }

        if (rel !== false) {
          props.rel = (rel || defaultRel).concat();
        }

        if (content) {
          // `fragment` is not a known mdast node, but unknown nodes with
          // children are handled as elements by `mdast-util-to-hast`:
          // See: <https://github.com/syntax-tree/mdast-util-to-hast#notes>.
          node.children.push({
            type: 'fragment',
            children: [],
            data: {
              hName: 'span',
              hProperties: extend$2(true, contentProperties),
              hChildren: extend$2(true, content)
            }
          });
        }
      }
    }
  }
}

var format = createCommonjsModule(function (module) {
(function() {

  //// Export the API
  var namespace;

  // CommonJS / Node module
  {
    namespace = module.exports = format;
  }

  namespace.format = format;
  namespace.vsprintf = vsprintf;

  if (typeof console !== 'undefined' && typeof console.log === 'function') {
    namespace.printf = printf;
  }

  function printf(/* ... */) {
    console.log(format.apply(null, arguments));
  }

  function vsprintf(fmt, replacements) {
    return format.apply(null, [fmt].concat(replacements));
  }

  function format(fmt) {
    var argIndex = 1 // skip initial format argument
      , args = [].slice.call(arguments)
      , i = 0
      , n = fmt.length
      , result = ''
      , c
      , escaped = false
      , arg
      , tmp
      , leadingZero = false
      , precision
      , nextArg = function() { return args[argIndex++]; }
      , slurpNumber = function() {
          var digits = '';
          while (/\d/.test(fmt[i])) {
            digits += fmt[i++];
            c = fmt[i];
          }
          return digits.length > 0 ? parseInt(digits) : null;
        }
      ;
    for (; i < n; ++i) {
      c = fmt[i];
      if (escaped) {
        escaped = false;
        if (c == '.') {
          leadingZero = false;
          c = fmt[++i];
        }
        else if (c == '0' && fmt[i + 1] == '.') {
          leadingZero = true;
          i += 2;
          c = fmt[i];
        }
        else {
          leadingZero = true;
        }
        precision = slurpNumber();
        switch (c) {
        case 'b': // number in binary
          result += parseInt(nextArg(), 10).toString(2);
          break;
        case 'c': // character
          arg = nextArg();
          if (typeof arg === 'string' || arg instanceof String)
            result += arg;
          else
            result += String.fromCharCode(parseInt(arg, 10));
          break;
        case 'd': // number in decimal
          result += parseInt(nextArg(), 10);
          break;
        case 'f': // floating point number
          tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
          result += leadingZero ? tmp : tmp.replace(/^0/, '');
          break;
        case 'j': // JSON
          result += JSON.stringify(nextArg());
          break;
        case 'o': // number in octal
          result += '0' + parseInt(nextArg(), 10).toString(8);
          break;
        case 's': // string
          result += nextArg();
          break;
        case 'x': // lowercase hexadecimal
          result += '0x' + parseInt(nextArg(), 10).toString(16);
          break;
        case 'X': // uppercase hexadecimal
          result += '0x' + parseInt(nextArg(), 10).toString(16).toUpperCase();
          break;
        default:
          result += c;
          break;
        }
      } else if (c === '%') {
        escaped = true;
      } else {
        result += c;
      }
    }
    return result;
  }

}());
});

var fault = create$3(Error);

var fault_1 = fault;

fault.eval = create$3(EvalError);
fault.range = create$3(RangeError);
fault.reference = create$3(ReferenceError);
fault.syntax = create$3(SyntaxError);
fault.type = create$3(TypeError);
fault.uri = create$3(URIError);

fault.create = create$3;

// Create a new `EConstructor`, with the formatted `format` as a first argument.
function create$3(EConstructor) {
  FormattedError.displayName = EConstructor.displayName || EConstructor.name;

  return FormattedError

  function FormattedError(format$1) {
    if (format$1) {
      format$1 = format.apply(null, arguments);
    }

    return new EConstructor(format$1)
  }
}

var matters_1 = matters;

var own$9 = {}.hasOwnProperty;

var markers = {
  yaml: '-',
  toml: '+'
};

function matters(options) {
  var results = [];
  var index = -1;
  var length;

  // One preset or matter.
  if (typeof options === 'string' || !('length' in options)) {
    options = [options];
  }

  length = options.length;

  while (++index < length) {
    results[index] = matter(options[index]);
  }

  return results
}

function matter(option) {
  var result = option;

  if (typeof result === 'string') {
    if (!own$9.call(markers, result)) {
      throw fault_1('Missing matter definition for `%s`', result)
    }

    result = {type: result, marker: markers[result]};
  } else if (typeof result !== 'object') {
    throw fault_1('Expected matter to be an object, not `%j`', result)
  }

  if (!own$9.call(result, 'type')) {
    throw fault_1('Missing `type` in matter `%j`', result)
  }

  if (!own$9.call(result, 'fence') && !own$9.call(result, 'marker')) {
    throw fault_1('Missing `marker` or `fence` in matter `%j`', result)
  }

  return result
}

var fence_1 = fence;

function fence(matter, prop) {
  var marker;

  if (matter.marker) {
    marker = pick(matter.marker, prop);
    return marker + marker + marker
  }

  return pick(matter.fence, prop)
}

function pick(schema, prop) {
  return typeof schema === 'string' ? schema : schema[prop]
}

var parse$3 = create$2;

function create$2(matter) {
  var name = matter.type + 'FrontMatter';
  var open = fence_1(matter, 'open');
  var close = fence_1(matter, 'close');
  var newline = '\n';
  var anywhere = matter.anywhere;

  frontmatter.displayName = name;
  frontmatter.onlyAtStart = typeof anywhere === 'boolean' ? !anywhere : true;

  return [name, frontmatter]

  function frontmatter(eat, value, silent) {
    var index = open.length;
    var offset;

    if (value.slice(0, index) !== open || value.charAt(index) !== newline) {
      return
    }

    offset = value.indexOf(close, index);

    while (offset !== -1 && value.charAt(offset - 1) !== newline) {
      index = offset + close.length;
      offset = value.indexOf(close, index);
    }

    if (offset !== -1) {
      /* istanbul ignore if - never used (yet) */
      if (silent) {
        return true
      }

      return eat(value.slice(0, offset + close.length))({
        type: matter.type,
        value: value.slice(open.length + 1, offset - 1)
      })
    }
  }
}

var compile = create$1;

function create$1(matter) {
  var type = matter.type;
  var open = fence_1(matter, 'open');
  var close = fence_1(matter, 'close');

  frontmatter.displayName = type + 'FrontMatter';

  return [type, frontmatter]

  function frontmatter(node) {
    return open + (node.value ? '\n' + node.value : '') + '\n' + close
  }
}

var remarkFrontmatter = frontmatter;

function frontmatter(options) {
  var parser = this.Parser;
  var compiler = this.Compiler;
  var config = matters_1(options || ['yaml']);

  if (isRemarkParser(parser)) {
    attachParser(parser, config);
  }

  if (isRemarkCompiler(compiler)) {
    attachCompiler(compiler, config);
  }
}

function attachParser(parser, matters) {
  var proto = parser.prototype;
  var tokenizers = wrap$1(parse$3, matters);
  var names = [];
  var key;

  for (key in tokenizers) {
    names.push(key);
  }

  proto.blockMethods = names.concat(proto.blockMethods);
  proto.blockTokenizers = Object.assign({}, tokenizers, proto.blockTokenizers);
}

function attachCompiler(compiler, matters) {
  var proto = compiler.prototype;
  proto.visitors = Object.assign({}, wrap$1(compile, matters), proto.visitors);
}

function wrap$1(func, matters) {
  var result = {};
  var length = matters.length;
  var index = -1;
  var tuple;

  while (++index < length) {
    tuple = func(matters[index]);
    result[tuple[0]] = tuple[1];
  }

  return result
}

function isRemarkParser(parser) {
  return Boolean(parser && parser.prototype && parser.prototype.blockTokenizers)
}

function isRemarkCompiler(compiler) {
  return Boolean(compiler && compiler.prototype && compiler.prototype.visitors)
}

var unistBuilder = u;

function u(type, props, value) {
  var node;

  if (
    (value === null || value === undefined) &&
    (typeof props !== 'object' || Array.isArray(props))
  ) {
    value = props;
    props = {};
  }

  node = Object.assign({type: String(type)}, props);

  if (Array.isArray(value)) {
    node.children = value;
  } else if (value !== null && value !== undefined) {
    node.value = String(value);
  }

  return node
}

var start = factory$1('start');
var end = factory$1('end');

var unistUtilPosition = position;

position.start = start;
position.end = end;

function position(node) {
  return {start: start(node), end: end(node)}
}

function factory$1(type) {
  point.displayName = type;

  return point

  function point(node) {
    var point = (node && node.position && node.position[type]) || {};

    return {
      line: point.line || null,
      column: point.column || null,
      offset: isNaN(point.offset) ? null : point.offset
    }
  }
}

var unistUtilGenerated = generated;

function generated(node) {
  var position = optional(optional(node).position);
  var start = optional(position.start);
  var end = optional(position.end);

  return !start.line || !start.column || !end.line || !end.column
}

function optional(value) {
  return value && typeof value === 'object' ? value : {}
}

var mdastUtilDefinitions = getDefinitionFactory;

var own$8 = {}.hasOwnProperty;

// Get a definition in `node` by `identifier`.
function getDefinitionFactory(node, options) {
  return getterFactory(gather(node, options))
}

// Gather all definitions in `node`
function gather(node, options) {
  var cache = {};

  if (!node || !node.type) {
    throw new Error('mdast-util-definitions expected node')
  }

  unistUtilVisit(node, 'definition', options && options.commonmark ? commonmark : normal);

  return cache

  function commonmark(definition) {
    var id = normalise(definition.identifier);
    if (!own$8.call(cache, id)) {
      cache[id] = definition;
    }
  }

  function normal(definition) {
    cache[normalise(definition.identifier)] = definition;
  }
}

// Factory to get a node from the given definition-cache.
function getterFactory(cache) {
  return getter

  // Get a node from the bound definition-cache.
  function getter(identifier) {
    var id = identifier && normalise(identifier);
    return id && own$8.call(cache, id) ? cache[id] : null
  }
}

function normalise(identifier) {
  return identifier.toUpperCase()
}

var all_1$1 = all$2;



function all$2(h, parent) {
  var nodes = parent.children || [];
  var length = nodes.length;
  var values = [];
  var index = -1;
  var result;
  var head;

  while (++index < length) {
    result = one_1$1(h, nodes[index], parent);

    if (result) {
      if (index && nodes[index - 1].type === 'break') {
        if (result.value) {
          result.value = result.value.replace(/^\s+/, '');
        }

        head = result.children && result.children[0];

        if (head && head.value) {
          head.value = head.value.replace(/^\s+/, '');
        }
      }

      values = values.concat(result);
    }
  }

  return values
}

var one_1$1 = one$2;




var own$7 = {}.hasOwnProperty;

// Transform an unknown node.
function unknown(h, node) {
  if (text$2(node)) {
    return h.augment(node, unistBuilder('text', node.value))
  }

  return h(node, 'div', all_1$1(h, node))
}

// Visit a node.
function one$2(h, node, parent) {
  var type = node && node.type;
  var fn = own$7.call(h.handlers, type) ? h.handlers[type] : h.unknownHandler;

  // Fail on non-nodes.
  if (!type) {
    throw new Error('Expected node, got `' + node + '`')
  }

  return (typeof fn === 'function' ? fn : unknown)(h, node, parent)
}

// Check if the node should be renderered as a text node.
function text$2(node) {
  var data = node.data || {};

  if (
    own$7.call(data, 'hName') ||
    own$7.call(data, 'hProperties') ||
    own$7.call(data, 'hChildren')
  ) {
    return false
  }

  return 'value' in node
}

var thematicBreak_1 = thematicBreak;

function thematicBreak(h, node) {
  return h(node, 'hr')
}

var wrap_1 = wrap;



// Wrap `nodes` with line feeds between each entry.
// Optionally adds line feeds at the start and end.
function wrap(nodes, loose) {
  var result = [];
  var index = -1;
  var length = nodes.length;

  if (loose) {
    result.push(unistBuilder('text', '\n'));
  }

  while (++index < length) {
    if (index) {
      result.push(unistBuilder('text', '\n'));
    }

    result.push(nodes[index]);
  }

  if (loose && nodes.length !== 0) {
    result.push(unistBuilder('text', '\n'));
  }

  return result
}

var list_1 = list;




function list(h, node) {
  var props = {};
  var name = node.ordered ? 'ol' : 'ul';
  var items;
  var index = -1;
  var length;

  if (typeof node.start === 'number' && node.start !== 1) {
    props.start = node.start;
  }

  items = all_1$1(h, node);
  length = items.length;

  // Like GitHub, add a class for custom styling.
  while (++index < length) {
    if (
      items[index].properties.className &&
      items[index].properties.className.indexOf('task-list-item') !== -1
    ) {
      props.className = ['contains-task-list'];
      break
    }
  }

  return h(node, name, props, wrap_1(items, true))
}

var footer = generateFootnotes;





function generateFootnotes(h) {
  var footnoteById = h.footnoteById;
  var footnoteOrder = h.footnoteOrder;
  var length = footnoteOrder.length;
  var index = -1;
  var listItems = [];
  var def;
  var backReference;
  var content;
  var tail;

  while (++index < length) {
    def = footnoteById[footnoteOrder[index].toUpperCase()];

    if (!def) {
      continue
    }

    content = def.children.concat();
    tail = content[content.length - 1];
    backReference = {
      type: 'link',
      url: '#fnref-' + def.identifier,
      data: {hProperties: {className: ['footnote-backref']}},
      children: [{type: 'text', value: '↩'}]
    };

    if (!tail || tail.type !== 'paragraph') {
      tail = {type: 'paragraph', children: []};
      content.push(tail);
    }

    tail.children.push(backReference);

    listItems.push({
      type: 'listItem',
      data: {hProperties: {id: 'fn-' + def.identifier}},
      children: content,
      position: def.position
    });
  }

  if (listItems.length === 0) {
    return null
  }

  return h(
    null,
    'div',
    {className: ['footnotes']},
    wrap_1(
      [
        thematicBreak_1(h),
        list_1(h, {type: 'list', ordered: true, children: listItems})
      ],
      true
    )
  )
}

var blockquote_1 = blockquote;




function blockquote(h, node) {
  return h(node, 'blockquote', wrap_1(all_1$1(h, node), true))
}

var _break = hardBreak;



function hardBreak(h, node) {
  return [h(node, 'br'), unistBuilder('text', '\n')]
}

var detab_1 = detab;



var tab$1 = 0x09;
var lineFeed$1 = 0x0a;
var carriageReturn = 0x0d;

// Replace tabs with spaces, being smart about which column the tab is at and
// which size should be used.
function detab(value, size) {
  var string = typeof value === 'string';
  var length = string && value.length;
  var start = 0;
  var index = -1;
  var column = -1;
  var tabSize = size || 4;
  var results = [];
  var code;
  var add;

  if (!string) {
    throw new Error('detab expected string')
  }

  while (++index < length) {
    code = value.charCodeAt(index);

    if (code === tab$1) {
      add = tabSize - ((column + 1) % tabSize);
      column += add;
      results.push(value.slice(start, index) + repeatString(' ', add));
      start = index + 1;
    } else if (code === lineFeed$1 || code === carriageReturn) {
      column = -1;
    } else {
      column++;
    }
  }

  results.push(value.slice(start));

  return results.join('')
}

var code_1 = code;




function code(h, node) {
  var value = node.value ? detab_1(node.value + '\n') : '';
  var lang = node.lang && node.lang.match(/^[^ \t]+(?=[ \t]|$)/);
  var props = {};

  if (lang) {
    props.className = ['language-' + lang];
  }

  return h(node.position, 'pre', [h(node, 'code', props, [unistBuilder('text', value)])])
}

var _delete = strikethrough;



function strikethrough(h, node) {
  return h(node, 'del', all_1$1(h, node))
}

var emphasis_1 = emphasis;



function emphasis(h, node) {
  return h(node, 'em', all_1$1(h, node))
}

var footnoteReference_1 = footnoteReference;



function footnoteReference(h, node) {
  var footnoteOrder = h.footnoteOrder;
  var identifier = String(node.identifier);

  if (footnoteOrder.indexOf(identifier) === -1) {
    footnoteOrder.push(identifier);
  }

  return h(node.position, 'sup', {id: 'fnref-' + identifier}, [
    h(node, 'a', {href: '#fn-' + identifier, className: ['footnote-ref']}, [
      unistBuilder('text', node.label || identifier)
    ])
  ])
}

var footnote_1 = footnote;



function footnote(h, node) {
  var footnoteById = h.footnoteById;
  var footnoteOrder = h.footnoteOrder;
  var identifier = 1;

  while (identifier in footnoteById) {
    identifier++;
  }

  identifier = String(identifier);

  // No need to check if `identifier` exists in `footnoteOrder`, it’s guaranteed
  // to not exist because we just generated it.
  footnoteOrder.push(identifier);

  footnoteById[identifier] = {
    type: 'footnoteDefinition',
    identifier: identifier,
    children: [{type: 'paragraph', children: node.children}],
    position: node.position
  };

  return footnoteReference_1(h, {
    type: 'footnoteReference',
    identifier: identifier,
    position: node.position
  })
}

var heading_1 = heading;



function heading(h, node) {
  return h(node, 'h' + node.depth, all_1$1(h, node))
}

var html_1$1 = html$3;



// Return either a `raw` node in dangerous mode, otherwise nothing.
function html$3(h, node) {
  return h.dangerous ? h.augment(node, unistBuilder('raw', node.value)) : null
}

var encodeCache = {};


// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i, ch, cache = encodeCache[exclude];
  if (cache) { return cache; }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}


// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode$1(string, exclude, keepEscaped) {
  var i, l, code, nextCode, cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped  = exclude;
    exclude = encode$1.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode$1.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
encode$1.componentChars = "-_.!~*'()";


var encode_1 = encode$1;

var revert_1 = revert;




// Return the content of a reference without definition as Markdown.
function revert(h, node) {
  var subtype = node.referenceType;
  var suffix = ']';
  var contents;
  var head;
  var tail;

  if (subtype === 'collapsed') {
    suffix += '[]';
  } else if (subtype === 'full') {
    suffix += '[' + (node.label || node.identifier) + ']';
  }

  if (node.type === 'imageReference') {
    return unistBuilder('text', '![' + node.alt + suffix)
  }

  contents = all_1$1(h, node);
  head = contents[0];

  if (head && head.type === 'text') {
    head.value = '[' + head.value;
  } else {
    contents.unshift(unistBuilder('text', '['));
  }

  tail = contents[contents.length - 1];

  if (tail && tail.type === 'text') {
    tail.value += suffix;
  } else {
    contents.push(unistBuilder('text', suffix));
  }

  return contents
}

var imageReference_1 = imageReference;




function imageReference(h, node) {
  var def = h.definition(node.identifier);
  var props;

  if (!def) {
    return revert_1(h, node)
  }

  props = {src: encode_1(def.url || ''), alt: node.alt};

  if (def.title !== null && def.title !== undefined) {
    props.title = def.title;
  }

  return h(node, 'img', props)
}

var image_1 = image$1;

function image$1(h, node) {
  var props = {src: encode_1(node.url), alt: node.alt};

  if (node.title !== null && node.title !== undefined) {
    props.title = node.title;
  }

  return h(node, 'img', props)
}

var inlineCode_1 = inlineCode;




function inlineCode(h, node) {
  return h(node, 'code', [unistBuilder('text', collapseWhiteSpace(node.value))])
}

var linkReference_1 = linkReference;





function linkReference(h, node) {
  var def = h.definition(node.identifier);
  var props;

  if (!def) {
    return revert_1(h, node)
  }

  props = {href: encode_1(def.url || '')};

  if (def.title !== null && def.title !== undefined) {
    props.title = def.title;
  }

  return h(node, 'a', props, all_1$1(h, node))
}

var link_1 = link;

function link(h, node) {
  var props = {href: encode_1(node.url)};

  if (node.title !== null && node.title !== undefined) {
    props.title = node.title;
  }

  return h(node, 'a', props, all_1$1(h, node))
}

var listItem_1 = listItem$1;





function listItem$1(h, node, parent) {
  var children = node.children;
  var head = children[0];
  var raw = all_1$1(h, node);
  var loose = parent ? listLoose(parent) : listItemLoose(node);
  var props = {};
  var result;
  var container;
  var index;
  var length;
  var child;

  // Tight lists should not render `paragraph` nodes as `p` elements.
  if (loose) {
    result = raw;
  } else {
    result = [];
    length = raw.length;
    index = -1;

    while (++index < length) {
      child = raw[index];

      if (child.tagName === 'p') {
        result = result.concat(child.children);
      } else {
        result.push(child);
      }
    }
  }

  if (typeof node.checked === 'boolean') {
    if (loose && (!head || head.type !== 'paragraph')) {
      result.unshift(h(null, 'p', []));
    }

    container = loose ? result[0].children : result;

    if (container.length !== 0) {
      container.unshift(unistBuilder('text', ' '));
    }

    container.unshift(
      h(null, 'input', {
        type: 'checkbox',
        checked: node.checked,
        disabled: true
      })
    );

    // According to github-markdown-css, this class hides bullet.
    // See: <https://github.com/sindresorhus/github-markdown-css>.
    props.className = ['task-list-item'];
  }

  if (loose && result.length !== 0) {
    result = wrap_1(result, true);
  }

  return h(node, 'li', props, result)
}

function listLoose(node) {
  var loose = node.spread;
  var children = node.children;
  var length = children.length;
  var index = -1;

  while (!loose && ++index < length) {
    loose = listItemLoose(children[index]);
  }

  return loose
}

function listItemLoose(node) {
  var spread = node.spread;

  return spread === undefined || spread === null
    ? node.children.length > 1
    : spread
}

var paragraph_1 = paragraph;



function paragraph(h, node) {
  return h(node, 'p', all_1$1(h, node))
}

var root_1 = root;





function root(h, node) {
  return h.augment(node, unistBuilder('root', wrap_1(all_1$1(h, node))))
}

var strong_1 = strong;



function strong(h, node) {
  return h(node, 'strong', all_1$1(h, node))
}

var table_1 = table;





function table(h, node) {
  var rows = node.children;
  var index = rows.length;
  var align = node.align;
  var alignLength = align.length;
  var result = [];
  var pos;
  var row;
  var out;
  var name;
  var cell;

  while (index--) {
    row = rows[index].children;
    name = index === 0 ? 'th' : 'td';
    pos = alignLength;
    out = [];

    while (pos--) {
      cell = row[pos];
      out[pos] = h(cell, name, {align: align[pos]}, cell ? all_1$1(h, cell) : []);
    }

    result[index] = h(rows[index], 'tr', wrap_1(out, true));
  }

  return h(
    node,
    'table',
    wrap_1(
      [
        h(result[0].position, 'thead', wrap_1([result[0]], true)),
        h(
          {
            start: unistUtilPosition.start(result[1]),
            end: unistUtilPosition.end(result[result.length - 1])
          },
          'tbody',
          wrap_1(result.slice(1), true)
        )
      ],
      true
    )
  )
}

var trimLines_1 = trimLines;

var ws = /[ \t]*\n+[ \t]*/g;
var newline$1 = '\n';

function trimLines(value) {
  return String(value).replace(ws, newline$1)
}

var text_1$1 = text$1;




function text$1(h, node) {
  return h.augment(node, unistBuilder('text', trimLines_1(node.value)))
}

var handlers$1 = {
  blockquote: blockquote_1,
  break: _break,
  code: code_1,
  delete: _delete,
  emphasis: emphasis_1,
  footnoteReference: footnoteReference_1,
  footnote: footnote_1,
  heading: heading_1,
  html: html_1$1,
  imageReference: imageReference_1,
  image: image_1,
  inlineCode: inlineCode_1,
  linkReference: linkReference_1,
  link: link_1,
  listItem: listItem_1,
  list: list_1,
  paragraph: paragraph_1,
  root: root_1,
  strong: strong_1,
  table: table_1,
  text: text_1$1,
  thematicBreak: thematicBreak_1,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};

// Return nothing for nodes that are ignored.
function ignore() {
  return null
}

var lib$2 = toHast;










var own$6 = {}.hasOwnProperty;

var deprecationWarningIssued = false;

// Factory to transform.
function factory(tree, options) {
  var settings = options || {};

  // Issue a warning if the deprecated tag 'allowDangerousHTML' is used
  if (settings.allowDangerousHTML !== undefined && !deprecationWarningIssued) {
    deprecationWarningIssued = true;
    console.warn(
      'mdast-util-to-hast: deprecation: `allowDangerousHTML` is nonstandard, use `allowDangerousHtml` instead'
    );
  }

  var dangerous = settings.allowDangerousHtml || settings.allowDangerousHTML;
  var footnoteById = {};

  h.dangerous = dangerous;
  h.definition = mdastUtilDefinitions(tree, settings);
  h.footnoteById = footnoteById;
  h.footnoteOrder = [];
  h.augment = augment;
  h.handlers = Object.assign({}, handlers$1, settings.handlers);
  h.unknownHandler = settings.unknownHandler;

  unistUtilVisit(tree, 'footnoteDefinition', onfootnotedefinition);

  return h

  // Finalise the created `right`, a hast node, from `left`, an mdast node.
  function augment(left, right) {
    var data;
    var ctx;

    // Handle `data.hName`, `data.hProperties, `data.hChildren`.
    if (left && 'data' in left) {
      data = left.data;

      if (right.type === 'element' && data.hName) {
        right.tagName = data.hName;
      }

      if (right.type === 'element' && data.hProperties) {
        right.properties = Object.assign({}, right.properties, data.hProperties);
      }

      if (right.children && data.hChildren) {
        right.children = data.hChildren;
      }
    }

    ctx = left && left.position ? left : {position: left};

    if (!unistUtilGenerated(ctx)) {
      right.position = {
        start: unistUtilPosition.start(ctx),
        end: unistUtilPosition.end(ctx)
      };
    }

    return right
  }

  // Create an element for `node`.
  function h(node, tagName, props, children) {
    if (
      (children === undefined || children === null) &&
      typeof props === 'object' &&
      'length' in props
    ) {
      children = props;
      props = {};
    }

    return augment(node, {
      type: 'element',
      tagName: tagName,
      properties: props || {},
      children: children || []
    })
  }

  function onfootnotedefinition(definition) {
    var id = String(definition.identifier).toUpperCase();

    // Mimick CM behavior of link definitions.
    // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8d48e57/index.js#L26>.
    if (!own$6.call(footnoteById, id)) {
      footnoteById[id] = definition;
    }
  }
}

// Transform `tree`, which is an mdast node, to a hast node.
function toHast(tree, options) {
  var h = factory(tree, options);
  var node = one_1$1(h, tree);
  var foot = footer(h);

  if (foot) {
    node.children = node.children.concat(unistBuilder('text', '\n'), foot);
  }

  return node
}

var mdastUtilToHast = lib$2;

var remarkRehype = remark2rehype;

// Attacher.
// If a destination is given, runs the destination with the new hast tree
// (bridge mode).
// Without destination, returns the tree: further plugins run on that tree
// (mutate mode).
function remark2rehype(destination, options) {
  if (destination && !destination.process) {
    options = destination;
    destination = null;
  }

  return destination ? bridge(destination, options) : mutate(options)
}

// Bridge mode.
// Runs the destination with the new hast tree.
function bridge(destination, options) {
  return transformer

  function transformer(node, file, next) {
    destination.run(mdastUtilToHast(node, options), file, done);

    function done(err) {
      next(err);
    }
  }
}

// Mutate-mode.
// Further transformers run on the hast tree.
function mutate(options) {
  return transformer

  function transformer(node) {
    return mdastUtilToHast(node, options)
  }
}

var schema$1 = Schema$2;

var proto$2 = Schema$2.prototype;

proto$2.space = null;
proto$2.normal = {};
proto$2.property = {};

function Schema$2(property, normal, space) {
  this.property = property;
  this.normal = normal;

  if (space) {
    this.space = space;
  }
}

var merge_1 = merge$1;

function merge$1(definitions) {
  var length = definitions.length;
  var property = [];
  var normal = [];
  var index = -1;
  var info;
  var space;

  while (++index < length) {
    info = definitions[index];
    property.push(info.property);
    normal.push(info.normal);
    space = info.space;
  }

  return new schema$1(
    immutable.apply(null, property),
    immutable.apply(null, normal),
    space
  )
}

var normalize_1 = normalize;

function normalize(value) {
  return value.toLowerCase()
}

var info = Info;

var proto$1 = Info.prototype;

proto$1.space = null;
proto$1.attribute = null;
proto$1.property = null;
proto$1.boolean = false;
proto$1.booleanish = false;
proto$1.overloadedBoolean = false;
proto$1.number = false;
proto$1.commaSeparated = false;
proto$1.spaceSeparated = false;
proto$1.commaOrSpaceSeparated = false;
proto$1.mustUseProperty = false;
proto$1.defined = false;

function Info(property, attribute) {
  this.property = property;
  this.attribute = attribute;
}

var powers = 0;

var boolean_1 = increment();
var booleanish$2 = increment();
var overloadedBoolean$1 = increment();
var number$3 = increment();
var spaceSeparated$3 = increment();
var commaSeparated$2 = increment();
var commaOrSpaceSeparated$1 = increment();

function increment() {
  return Math.pow(2, ++powers)
}

var types = {
	boolean: boolean_1,
	booleanish: booleanish$2,
	overloadedBoolean: overloadedBoolean$1,
	number: number$3,
	spaceSeparated: spaceSeparated$3,
	commaSeparated: commaSeparated$2,
	commaOrSpaceSeparated: commaOrSpaceSeparated$1
};

var definedInfo = DefinedInfo;

DefinedInfo.prototype = new info();
DefinedInfo.prototype.defined = true;

var checks = [
  'boolean',
  'booleanish',
  'overloadedBoolean',
  'number',
  'commaSeparated',
  'spaceSeparated',
  'commaOrSpaceSeparated'
];
var checksLength = checks.length;

function DefinedInfo(property, attribute, mask, space) {
  var index = -1;
  var check;

  mark$1(this, 'space', space);

  info.call(this, property, attribute);

  while (++index < checksLength) {
    check = checks[index];
    mark$1(this, check, (mask & types[check]) === types[check]);
  }
}

function mark$1(values, key, value) {
  if (value) {
    values[key] = value;
  }
}

var create_1 = create;

function create(definition) {
  var space = definition.space;
  var mustUseProperty = definition.mustUseProperty || [];
  var attributes = definition.attributes || {};
  var props = definition.properties;
  var transform = definition.transform;
  var property = {};
  var normal = {};
  var prop;
  var info;

  for (prop in props) {
    info = new definedInfo(
      prop,
      transform(attributes, prop),
      props[prop],
      space
    );

    if (mustUseProperty.indexOf(prop) !== -1) {
      info.mustUseProperty = true;
    }

    property[prop] = info;

    normal[normalize_1(prop)] = prop;
    normal[normalize_1(info.attribute)] = prop;
  }

  return new schema$1(property, normal, space)
}

var xlink = create_1({
  space: 'xlink',
  transform: xlinkTransform,
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});

function xlinkTransform(_, prop) {
  return 'xlink:' + prop.slice(5).toLowerCase()
}

var xml = create_1({
  space: 'xml',
  transform: xmlTransform,
  properties: {
    xmlLang: null,
    xmlBase: null,
    xmlSpace: null
  }
});

function xmlTransform(_, prop) {
  return 'xml:' + prop.slice(3).toLowerCase()
}

var caseSensitiveTransform_1 = caseSensitiveTransform;

function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute
}

var caseInsensitiveTransform_1 = caseInsensitiveTransform;

function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform_1(attributes, property.toLowerCase())
}

var xmlns = create_1({
  space: 'xmlns',
  attributes: {
    xmlnsxlink: 'xmlns:xlink'
  },
  transform: caseInsensitiveTransform_1,
  properties: {
    xmlns: null,
    xmlnsXLink: null
  }
});

var booleanish$1 = types.booleanish;
var number$2 = types.number;
var spaceSeparated$2 = types.spaceSeparated;

var aria = create_1({
  transform: ariaTransform,
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish$1,
    ariaAutoComplete: null,
    ariaBusy: booleanish$1,
    ariaChecked: booleanish$1,
    ariaColCount: number$2,
    ariaColIndex: number$2,
    ariaColSpan: number$2,
    ariaControls: spaceSeparated$2,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated$2,
    ariaDetails: null,
    ariaDisabled: booleanish$1,
    ariaDropEffect: spaceSeparated$2,
    ariaErrorMessage: null,
    ariaExpanded: booleanish$1,
    ariaFlowTo: spaceSeparated$2,
    ariaGrabbed: booleanish$1,
    ariaHasPopup: null,
    ariaHidden: booleanish$1,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated$2,
    ariaLevel: number$2,
    ariaLive: null,
    ariaModal: booleanish$1,
    ariaMultiLine: booleanish$1,
    ariaMultiSelectable: booleanish$1,
    ariaOrientation: null,
    ariaOwns: spaceSeparated$2,
    ariaPlaceholder: null,
    ariaPosInSet: number$2,
    ariaPressed: booleanish$1,
    ariaReadOnly: booleanish$1,
    ariaRelevant: null,
    ariaRequired: booleanish$1,
    ariaRoleDescription: spaceSeparated$2,
    ariaRowCount: number$2,
    ariaRowIndex: number$2,
    ariaRowSpan: number$2,
    ariaSelected: booleanish$1,
    ariaSetSize: number$2,
    ariaSort: null,
    ariaValueMax: number$2,
    ariaValueMin: number$2,
    ariaValueNow: number$2,
    ariaValueText: null,
    role: null
  }
});

function ariaTransform(_, prop) {
  return prop === 'role' ? prop : 'aria-' + prop.slice(4).toLowerCase()
}

var boolean$1 = types.boolean;
var overloadedBoolean = types.overloadedBoolean;
var booleanish = types.booleanish;
var number$1 = types.number;
var spaceSeparated$1 = types.spaceSeparated;
var commaSeparated$1 = types.commaSeparated;

var html$2 = create_1({
  space: 'html',
  attributes: {
    acceptcharset: 'accept-charset',
    classname: 'class',
    htmlfor: 'for',
    httpequiv: 'http-equiv'
  },
  transform: caseInsensitiveTransform_1,
  mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated$1,
    acceptCharset: spaceSeparated$1,
    accessKey: spaceSeparated$1,
    action: null,
    allow: null,
    allowFullScreen: boolean$1,
    allowPaymentRequest: boolean$1,
    allowUserMedia: boolean$1,
    alt: null,
    as: null,
    async: boolean$1,
    autoCapitalize: null,
    autoComplete: spaceSeparated$1,
    autoFocus: boolean$1,
    autoPlay: boolean$1,
    capture: boolean$1,
    charSet: null,
    checked: boolean$1,
    cite: null,
    className: spaceSeparated$1,
    cols: number$1,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean$1,
    controlsList: spaceSeparated$1,
    coords: number$1 | commaSeparated$1,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean$1,
    defer: boolean$1,
    dir: null,
    dirName: null,
    disabled: boolean$1,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean$1,
    formTarget: null,
    headers: spaceSeparated$1,
    height: number$1,
    hidden: boolean$1,
    high: number$1,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated$1,
    httpEquiv: spaceSeparated$1,
    id: null,
    imageSizes: null,
    imageSrcSet: commaSeparated$1,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean$1,
    itemId: null,
    itemProp: spaceSeparated$1,
    itemRef: spaceSeparated$1,
    itemScope: boolean$1,
    itemType: spaceSeparated$1,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loop: boolean$1,
    low: number$1,
    manifest: null,
    max: null,
    maxLength: number$1,
    media: null,
    method: null,
    min: null,
    minLength: number$1,
    multiple: boolean$1,
    muted: boolean$1,
    name: null,
    nonce: null,
    noModule: boolean$1,
    noValidate: boolean$1,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextMenu: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean$1,
    optimum: number$1,
    pattern: null,
    ping: spaceSeparated$1,
    placeholder: null,
    playsInline: boolean$1,
    poster: null,
    preload: null,
    readOnly: boolean$1,
    referrerPolicy: null,
    rel: spaceSeparated$1,
    required: boolean$1,
    reversed: boolean$1,
    rows: number$1,
    rowSpan: number$1,
    sandbox: spaceSeparated$1,
    scope: null,
    scoped: boolean$1,
    seamless: boolean$1,
    selected: boolean$1,
    shape: null,
    size: number$1,
    sizes: null,
    slot: null,
    span: number$1,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: commaSeparated$1,
    start: number$1,
    step: null,
    style: null,
    tabIndex: number$1,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean$1,
    useMap: null,
    value: booleanish,
    width: number$1,
    wrap: null,

    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null, // Several. Use CSS `text-align` instead,
    aLink: null, // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated$1, // `<object>`. List of URIs to archives
    axis: null, // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null, // `<body>`. Use CSS `background-image` instead
    bgColor: null, // `<body>` and table elements. Use CSS `background-color` instead
    border: number$1, // `<table>`. Use CSS `border-width` instead,
    borderColor: null, // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number$1, // `<body>`
    cellPadding: null, // `<table>`
    cellSpacing: null, // `<table>`
    char: null, // Several table elements. When `align=char`, sets the character to align on
    charOff: null, // Several table elements. When `char`, offsets the alignment
    classId: null, // `<object>`
    clear: null, // `<br>`. Use CSS `clear` instead
    code: null, // `<object>`
    codeBase: null, // `<object>`
    codeType: null, // `<object>`
    color: null, // `<font>` and `<hr>`. Use CSS instead
    compact: boolean$1, // Lists. Use CSS to reduce space between items instead
    declare: boolean$1, // `<object>`
    event: null, // `<script>`
    face: null, // `<font>`. Use CSS instead
    frame: null, // `<table>`
    frameBorder: null, // `<iframe>`. Use CSS `border` instead
    hSpace: number$1, // `<img>` and `<object>`
    leftMargin: number$1, // `<body>`
    link: null, // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null, // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null, // `<img>`. Use a `<picture>`
    marginHeight: number$1, // `<body>`
    marginWidth: number$1, // `<body>`
    noResize: boolean$1, // `<frame>`
    noHref: boolean$1, // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean$1, // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean$1, // `<td>` and `<th>`
    object: null, // `<applet>`
    profile: null, // `<head>`
    prompt: null, // `<isindex>`
    rev: null, // `<link>`
    rightMargin: number$1, // `<body>`
    rules: null, // `<table>`
    scheme: null, // `<meta>`
    scrolling: booleanish, // `<frame>`. Use overflow in the child context
    standby: null, // `<object>`
    summary: null, // `<table>`
    text: null, // `<body>`. Use CSS `color` instead
    topMargin: number$1, // `<body>`
    valueType: null, // `<param>`
    version: null, // `<html>`. Use a doctype.
    vAlign: null, // Several. Use CSS `vertical-align` instead
    vLink: null, // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number$1, // `<img>` and `<object>`

    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean$1,
    disableRemotePlayback: boolean$1,
    prefix: null,
    property: null,
    results: number$1,
    security: null,
    unselectable: null
  }
});

var html_1 = merge_1([xml, xlink, xmlns, aria, html$2]);

var boolean = types.boolean;
var number = types.number;
var spaceSeparated = types.spaceSeparated;
var commaSeparated = types.commaSeparated;
var commaOrSpaceSeparated = types.commaOrSpaceSeparated;

var svg = create_1({
  space: 'svg',
  attributes: {
    accentHeight: 'accent-height',
    alignmentBaseline: 'alignment-baseline',
    arabicForm: 'arabic-form',
    baselineShift: 'baseline-shift',
    capHeight: 'cap-height',
    className: 'class',
    clipPath: 'clip-path',
    clipRule: 'clip-rule',
    colorInterpolation: 'color-interpolation',
    colorInterpolationFilters: 'color-interpolation-filters',
    colorProfile: 'color-profile',
    colorRendering: 'color-rendering',
    crossOrigin: 'crossorigin',
    dataType: 'datatype',
    dominantBaseline: 'dominant-baseline',
    enableBackground: 'enable-background',
    fillOpacity: 'fill-opacity',
    fillRule: 'fill-rule',
    floodColor: 'flood-color',
    floodOpacity: 'flood-opacity',
    fontFamily: 'font-family',
    fontSize: 'font-size',
    fontSizeAdjust: 'font-size-adjust',
    fontStretch: 'font-stretch',
    fontStyle: 'font-style',
    fontVariant: 'font-variant',
    fontWeight: 'font-weight',
    glyphName: 'glyph-name',
    glyphOrientationHorizontal: 'glyph-orientation-horizontal',
    glyphOrientationVertical: 'glyph-orientation-vertical',
    hrefLang: 'hreflang',
    horizAdvX: 'horiz-adv-x',
    horizOriginX: 'horiz-origin-x',
    horizOriginY: 'horiz-origin-y',
    imageRendering: 'image-rendering',
    letterSpacing: 'letter-spacing',
    lightingColor: 'lighting-color',
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    navDown: 'nav-down',
    navDownLeft: 'nav-down-left',
    navDownRight: 'nav-down-right',
    navLeft: 'nav-left',
    navNext: 'nav-next',
    navPrev: 'nav-prev',
    navRight: 'nav-right',
    navUp: 'nav-up',
    navUpLeft: 'nav-up-left',
    navUpRight: 'nav-up-right',
    onAbort: 'onabort',
    onActivate: 'onactivate',
    onAfterPrint: 'onafterprint',
    onBeforePrint: 'onbeforeprint',
    onBegin: 'onbegin',
    onCancel: 'oncancel',
    onCanPlay: 'oncanplay',
    onCanPlayThrough: 'oncanplaythrough',
    onChange: 'onchange',
    onClick: 'onclick',
    onClose: 'onclose',
    onCopy: 'oncopy',
    onCueChange: 'oncuechange',
    onCut: 'oncut',
    onDblClick: 'ondblclick',
    onDrag: 'ondrag',
    onDragEnd: 'ondragend',
    onDragEnter: 'ondragenter',
    onDragExit: 'ondragexit',
    onDragLeave: 'ondragleave',
    onDragOver: 'ondragover',
    onDragStart: 'ondragstart',
    onDrop: 'ondrop',
    onDurationChange: 'ondurationchange',
    onEmptied: 'onemptied',
    onEnd: 'onend',
    onEnded: 'onended',
    onError: 'onerror',
    onFocus: 'onfocus',
    onFocusIn: 'onfocusin',
    onFocusOut: 'onfocusout',
    onHashChange: 'onhashchange',
    onInput: 'oninput',
    onInvalid: 'oninvalid',
    onKeyDown: 'onkeydown',
    onKeyPress: 'onkeypress',
    onKeyUp: 'onkeyup',
    onLoad: 'onload',
    onLoadedData: 'onloadeddata',
    onLoadedMetadata: 'onloadedmetadata',
    onLoadStart: 'onloadstart',
    onMessage: 'onmessage',
    onMouseDown: 'onmousedown',
    onMouseEnter: 'onmouseenter',
    onMouseLeave: 'onmouseleave',
    onMouseMove: 'onmousemove',
    onMouseOut: 'onmouseout',
    onMouseOver: 'onmouseover',
    onMouseUp: 'onmouseup',
    onMouseWheel: 'onmousewheel',
    onOffline: 'onoffline',
    onOnline: 'ononline',
    onPageHide: 'onpagehide',
    onPageShow: 'onpageshow',
    onPaste: 'onpaste',
    onPause: 'onpause',
    onPlay: 'onplay',
    onPlaying: 'onplaying',
    onPopState: 'onpopstate',
    onProgress: 'onprogress',
    onRateChange: 'onratechange',
    onRepeat: 'onrepeat',
    onReset: 'onreset',
    onResize: 'onresize',
    onScroll: 'onscroll',
    onSeeked: 'onseeked',
    onSeeking: 'onseeking',
    onSelect: 'onselect',
    onShow: 'onshow',
    onStalled: 'onstalled',
    onStorage: 'onstorage',
    onSubmit: 'onsubmit',
    onSuspend: 'onsuspend',
    onTimeUpdate: 'ontimeupdate',
    onToggle: 'ontoggle',
    onUnload: 'onunload',
    onVolumeChange: 'onvolumechange',
    onWaiting: 'onwaiting',
    onZoom: 'onzoom',
    overlinePosition: 'overline-position',
    overlineThickness: 'overline-thickness',
    paintOrder: 'paint-order',
    panose1: 'panose-1',
    pointerEvents: 'pointer-events',
    referrerPolicy: 'referrerpolicy',
    renderingIntent: 'rendering-intent',
    shapeRendering: 'shape-rendering',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strikethroughPosition: 'strikethrough-position',
    strikethroughThickness: 'strikethrough-thickness',
    strokeDashArray: 'stroke-dasharray',
    strokeDashOffset: 'stroke-dashoffset',
    strokeLineCap: 'stroke-linecap',
    strokeLineJoin: 'stroke-linejoin',
    strokeMiterLimit: 'stroke-miterlimit',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    tabIndex: 'tabindex',
    textAnchor: 'text-anchor',
    textDecoration: 'text-decoration',
    textRendering: 'text-rendering',
    typeOf: 'typeof',
    underlinePosition: 'underline-position',
    underlineThickness: 'underline-thickness',
    unicodeBidi: 'unicode-bidi',
    unicodeRange: 'unicode-range',
    unitsPerEm: 'units-per-em',
    vAlphabetic: 'v-alphabetic',
    vHanging: 'v-hanging',
    vIdeographic: 'v-ideographic',
    vMathematical: 'v-mathematical',
    vectorEffect: 'vector-effect',
    vertAdvY: 'vert-adv-y',
    vertOriginX: 'vert-origin-x',
    vertOriginY: 'vert-origin-y',
    wordSpacing: 'word-spacing',
    writingMode: 'writing-mode',
    xHeight: 'x-height',
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: 'playbackorder',
    timelineBegin: 'timelinebegin'
  },
  transform: caseSensitiveTransform_1,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null, // SEMI_COLON_SEPARATED
    keySplines: null, // SEMI_COLON_SEPARATED
    keyTimes: null, // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});

var svg_1 = merge_1([xml, xlink, xmlns, aria, svg]);

var index$2 = [
	"area",
	"base",
	"basefont",
	"bgsound",
	"br",
	"col",
	"command",
	"embed",
	"frame",
	"hr",
	"image",
	"img",
	"input",
	"isindex",
	"keygen",
	"link",
	"menuitem",
	"meta",
	"nextid",
	"param",
	"source",
	"track",
	"wbr"
];

var htmlVoidElements = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': index$2
});

var unistUtilIs = is;

// Assert if `test` passes for `node`.   When a `parent` node is known the
// `index` of node.
// eslint-disable-next-line max-params
function is(test, node, index, parent, context) {
  var hasParent = parent !== null && parent !== undefined;
  var hasIndex = index !== null && index !== undefined;
  var check = convert(test);

  if (
    hasIndex &&
    (typeof index !== 'number' || index < 0 || index === Infinity)
  ) {
    throw new Error('Expected positive finite index or child node')
  }

  if (hasParent && (!is(null, parent) || !parent.children)) {
    throw new Error('Expected parent node')
  }

  if (!node || !node.type || typeof node.type !== 'string') {
    return false
  }

  if (hasParent !== hasIndex) {
    throw new Error('Expected both parent and index')
  }

  return Boolean(check.call(context, node, index, parent))
}

function convert(test) {
  if (typeof test === 'string') {
    return typeFactory(test)
  }

  if (test === null || test === undefined) {
    return ok
  }

  if (typeof test === 'object') {
    return ('length' in test ? anyFactory : matchesFactory)(test)
  }

  if (typeof test === 'function') {
    return test
  }

  throw new Error('Expected function, string, or object as test')
}

function convertAll(tests) {
  var results = [];
  var length = tests.length;
  var index = -1;

  while (++index < length) {
    results[index] = convert(tests[index]);
  }

  return results
}

// Utility assert each property in `test` is represented in `node`, and each
// values are strictly equal.
function matchesFactory(test) {
  return matches

  function matches(node) {
    var key;

    for (key in test) {
      if (node[key] !== test[key]) {
        return false
      }
    }

    return true
  }
}

function anyFactory(tests) {
  var checks = convertAll(tests);
  var length = checks.length;

  return matches

  function matches() {
    var index = -1;

    while (++index < length) {
      if (checks[index].apply(this, arguments)) {
        return true
      }
    }

    return false
  }
}

// Utility to convert a string into a function which checks a given node’s type
// for said string.
function typeFactory(test) {
  return type

  function type(node) {
    return Boolean(node && node.type === test)
  }
}

// Utility to return true.
function ok() {
  return true
}

var hastUtilIsElement = isElement;

// Check if if `node` is an `element` and, if `tagNames` is given, `node`
// matches them `tagNames`.
function isElement(node, tagNames) {
  var name;

  if (
    !(
      tagNames === null ||
      tagNames === undefined ||
      typeof tagNames === 'string' ||
      (typeof tagNames === 'object' && tagNames.length !== 0)
    )
  ) {
    throw new Error(
      'Expected `string` or `Array.<string>` for `tagNames`, not `' +
        tagNames +
        '`'
    )
  }

  if (
    !node ||
    typeof node !== 'object' ||
    node.type !== 'element' ||
    typeof node.tagName !== 'string'
  ) {
    return false
  }

  if (tagNames === null || tagNames === undefined) {
    return true
  }

  name = node.tagName;

  if (typeof tagNames === 'string') {
    return name === tagNames
  }

  return tagNames.indexOf(name) !== -1
}

var hastUtilWhitespace = interElementWhiteSpace;

// HTML white-space expression.
// See <https://html.spec.whatwg.org/#space-character>.
var re = /[ \t\n\f\r]/g;

function interElementWhiteSpace(node) {
  var value;

  if (node && typeof node === 'object' && node.type === 'text') {
    value = node.value || '';
  } else if (typeof node === 'string') {
    value = node;
  } else {
    return false
  }

  return value.replace(re, '') === ''
}

var before$1 = siblings(-1);
var after$2 = siblings(1);

/* Factory to check siblings in a direction. */
function siblings(increment) {
  return sibling

  /* Find applicable siblings in a direction.   */
  function sibling(parent, index, includeWhiteSpace) {
    var siblings = parent && parent.children;
    var next;

    index += increment;
    next = siblings && siblings[index];

    if (!includeWhiteSpace) {
      while (next && hastUtilWhitespace(next)) {
        index += increment;
        next = siblings[index];
      }
    }

    return next
  }
}

var siblings_1 = {
	before: before$1,
	after: after$2
};

var after$1 = siblings_1.after;

var first_1 = first;

/* Get the first child in `parent`. */
function first(parent, includeWhiteSpace) {
  return after$1(parent, -1, includeWhiteSpace)
}

var place_1 = place;

/* Get the position of `node` in `parent`. */
function place(parent, child) {
  return parent && parent.children && parent.children.indexOf(child)
}

var whiteSpaceLeft_1 = whiteSpaceLeft;

/* Check if `node` starts with white-space. */
function whiteSpaceLeft(node) {
  return unistUtilIs('text', node) && hastUtilWhitespace(node.value.charAt(0))
}

var omission_1 = omission$1;

var own$5 = {}.hasOwnProperty;

/* Factory to check if a given node can have a tag omitted. */
function omission$1(handlers) {
  return omit

  /* Check if a given node can have a tag omitted.   */
  function omit(node, index, parent) {
    var name = node.tagName;
    var fn = own$5.call(handlers, name) ? handlers[name] : false;

    return fn ? fn(node, index, parent) : false
  }
}

var after = siblings_1.after;


var optionGroup = 'optgroup';
var options = ['option'].concat(optionGroup);
var dataListItem = ['dt', 'dd'];
var listItem = 'li';
var menuContent = ['menuitem', 'hr', 'menu'];
var ruby = ['rp', 'rt'];
var tableContainer = ['tbody', 'tfoot'];
var tableRow$1 = 'tr';
var tableCell = ['td', 'th'];

var confusingParagraphParent = ['a', 'audio', 'del', 'ins', 'map', 'noscript', 'video'];

var clearParagraphSibling = [
  'address',
  'article',
  'aside',
  'blockquote',
  'details',
  'div',
  'dl',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'header',
  'hgroup',
  'hr',
  'main',
  'menu',
  'nav',
  'ol',
  'p',
  'pre',
  'section',
  'table',
  'ul'
];

var closing$1 = omission_1({
  html: html$1,
  head: headOrColgroupOrCaption,
  body: body$1,
  p: p,
  li: li,
  dt: dt,
  dd: dd,
  rt: rubyElement,
  rp: rubyElement,
  optgroup: optgroup,
  option: option,
  menuitem: menuitem,
  colgroup: headOrColgroupOrCaption,
  caption: headOrColgroupOrCaption,
  thead: thead,
  tbody: tbody$1,
  tfoot: tfoot,
  tr: tr,
  td: cells,
  th: cells
});

/* Macro for `</head>`, `</colgroup>`, and `</caption>`. */
function headOrColgroupOrCaption(node, index, parent) {
  var next = after(parent, index, true);
  return !next || (!unistUtilIs('comment', next) && !whiteSpaceLeft_1(next))
}

/* Whether to omit `</html>`. */
function html$1(node, index, parent) {
  var next = after(parent, index);
  return !next || !unistUtilIs('comment', next)
}

/* Whether to omit `</body>`. */
function body$1(node, index, parent) {
  var next = after(parent, index);
  return !next || !unistUtilIs('comment', next)
}

/* Whether to omit `</p>`. */
function p(node, index, parent) {
  var next = after(parent, index);
  return next ? hastUtilIsElement(next, clearParagraphSibling) : !parent || !hastUtilIsElement(parent, confusingParagraphParent)
}

/* Whether to omit `</li>`. */
function li(node, index, parent) {
  var next = after(parent, index);
  return !next || hastUtilIsElement(next, listItem)
}

/* Whether to omit `</dt>`. */
function dt(node, index, parent) {
  var next = after(parent, index);
  return next && hastUtilIsElement(next, dataListItem)
}

/* Whether to omit `</dd>`. */
function dd(node, index, parent) {
  var next = after(parent, index);
  return !next || hastUtilIsElement(next, dataListItem)
}

/* Whether to omit `</rt>` or `</rp>`. */
function rubyElement(node, index, parent) {
  var next = after(parent, index);
  return !next || hastUtilIsElement(next, ruby)
}

/* Whether to omit `</optgroup>`. */
function optgroup(node, index, parent) {
  var next = after(parent, index);
  return !next || hastUtilIsElement(next, optionGroup)
}

/* Whether to omit `</option>`. */
function option(node, index, parent) {
  var next = after(parent, index);
  return !next || hastUtilIsElement(next, options)
}

/* Whether to omit `</menuitem>`. */
function menuitem(node, index, parent) {
  var next = after(parent, index);
  return !next || hastUtilIsElement(next, menuContent)
}

/* Whether to omit `</thead>`. */
function thead(node, index, parent) {
  var next = after(parent, index);
  return next && hastUtilIsElement(next, tableContainer)
}

/* Whether to omit `</tbody>`. */
function tbody$1(node, index, parent) {
  var next = after(parent, index);
  return !next || hastUtilIsElement(next, tableContainer)
}

/* Whether to omit `</tfoot>`. */
function tfoot(node, index, parent) {
  return !after(parent, index)
}

/* Whether to omit `</tr>`. */
function tr(node, index, parent) {
  var next = after(parent, index);
  return !next || hastUtilIsElement(next, tableRow$1)
}

/* Whether to omit `</td>` or `</th>`. */
function cells(node, index, parent) {
  var next = after(parent, index);
  return !next || hastUtilIsElement(next, tableCell)
}

var before = siblings_1.before;






var own$4 = {}.hasOwnProperty;

var uniqueHeadMetadata = ['title', 'base'];
var meta = ['meta', 'link', 'script', 'style', 'template'];
var tableContainers = ['thead', 'tbody'];
var tableRow = 'tr';

var opening$1 = omission_1({
  html: html,
  head: head,
  body: body,
  colgroup: colgroup,
  tbody: tbody
});

/* Whether to omit `<html>`. */
function html(node) {
  var head = first_1(node);
  return !head || !unistUtilIs('comment', head)
}

/* Whether to omit `<head>`. */
function head(node) {
  var children = node.children;
  var length = children.length;
  var map = {};
  var index = -1;
  var child;
  var name;

  while (++index < length) {
    child = children[index];
    name = child.tagName;

    if (hastUtilIsElement(child, uniqueHeadMetadata)) {
      if (own$4.call(map, name)) {
        return false
      }

      map[name] = true;
    }
  }

  return Boolean(length)
}

/* Whether to omit `<body>`. */
function body(node) {
  var head = first_1(node, true);

  return !head || (!unistUtilIs('comment', head) && !whiteSpaceLeft_1(head) && !hastUtilIsElement(head, meta))
}

/* Whether to omit `<colgroup>`.
 * The spec describes some logic for the opening tag,
 * but it’s easier to implement in the closing tag, to
 * the same effect, so we handle it there instead. */
function colgroup(node, index, parent) {
  var prev = before(parent, index);
  var head = first_1(node, true);

  /* Previous colgroup was already omitted. */
  if (hastUtilIsElement(prev, 'colgroup') && closing$1(prev, place_1(parent, prev), parent)) {
    return false
  }

  return head && hastUtilIsElement(head, 'col')
}

/* Whether to omit `<tbody>`. */
function tbody(node, index, parent) {
  var prev = before(parent, index);
  var head = first_1(node);

  /* Previous table section was already omitted. */
  if (hastUtilIsElement(prev, tableContainers) && closing$1(prev, place_1(parent, prev), parent)) {
    return false
  }

  return head && hastUtilIsElement(head, tableRow)
}

var opening = opening$1;
var closing = closing$1;

var omission = {
	opening: opening,
	closing: closing
};

var index$1 = [
	"script",
	"style",
	"pre",
	"textarea"
];

var htmlWhitespaceSensitiveTagNames = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': index$1
});

var sensitive = getCjsExportFromNamespace(htmlWhitespaceSensitiveTagNames);

var all_1 = all$1;

/* Stringify all children of `parent`. */
function all$1(ctx, parent) {
  var children = parent && parent.children;
  var length = children && children.length;
  var index = -1;
  var results = [];

  let printWidthOffset = 0;
  let innerTextLength = 0;
  while (++index < length) {
    innerTextLength = getInnerTextLength(children[index]);
    results[index] = one_1(ctx, children[index], index, parent, printWidthOffset, innerTextLength);
    printWidthOffset = results[index].replace(/\n+/g, '').length;
  }

  return results.join('')
}

/**
 * Returns the text lenght of the first line of the first child.
 * Whitespace sensitive elements are ignored.
 * @param {*} node
 */
function getInnerTextLength(node) {
  // ignore style, script, pre, textarea elements
  if (sensitive.indexOf(node.tagName) !== -1) {
    return 0
  }

  if (!node.children || !node.children.length) {
    return 0
  }

  var child = node.children[0];

  if (child.type === 'text' || child.type === 'comment') {
    return child.value.split('\n')[0].length
  }

  return 0
}

var text_1 = text;

/* Stringify `text`. */
function text(ctx, node, index, parent) {
  var value = node.value;

  return value
}

var data = 'data';

var find_1 = find;

var valid = /^data[-\w.:]+$/i;
var dash = /-[a-z]/g;
var cap$1 = /[A-Z]/g;

function find(schema, value) {
  var normal = normalize_1(value);
  var prop = value;
  var Type = info;

  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]]
  }

  if (normal.length > 4 && normal.slice(0, 4) === data && valid.test(value)) {
    // Attribute or property.
    if (value.charAt(4) === '-') {
      prop = datasetToProperty(value);
    } else {
      value = datasetToAttribute(value);
    }

    Type = definedInfo;
  }

  return new Type(prop, value)
}

function datasetToProperty(attribute) {
  var value = attribute.slice(5).replace(dash, camelcase);
  return data + value.charAt(0).toUpperCase() + value.slice(1)
}

function datasetToAttribute(property) {
  var value = property.slice(4);

  if (dash.test(value)) {
    return property
  }

  value = value.replace(cap$1, kebab);

  if (value.charAt(0) !== '-') {
    value = '-' + value;
  }

  return data + value
}

function kebab($0) {
  return '-' + $0.toLowerCase()
}

function camelcase($0) {
  return $0.charAt(1).toUpperCase()
}

var parse_1 = parse$2;
var stringify_1 = stringify$2;

var comma = ',';
var space$2 = ' ';
var empty$1 = '';

// Parse comma-separated tokens to an array.
function parse$2(value) {
  var values = [];
  var input = String(value || empty$1);
  var index = input.indexOf(comma);
  var lastIndex = 0;
  var end = false;
  var val;

  while (!end) {
    if (index === -1) {
      index = input.length;
      end = true;
    }

    val = input.slice(lastIndex, index).trim();

    if (val || !end) {
      values.push(val);
    }

    lastIndex = index + 1;
    index = input.indexOf(comma, lastIndex);
  }

  return values
}

// Compile an array to comma-separated tokens.
// `options.padLeft` (default: `true`) pads a space left of each token, and
// `options.padRight` (default: `false`) pads a space to the right of each token.
function stringify$2(values, options) {
  var settings = options || {};
  var left = settings.padLeft === false ? empty$1 : space$2;
  var right = settings.padRight ? space$2 : empty$1;

  // Ensure the last empty entry is seen.
  if (values[values.length - 1] === empty$1) {
    values = values.concat(empty$1);
  }

  return values.join(right + comma + left).trim()
}

var commaSeparatedTokens = {
	parse: parse_1,
	stringify: stringify_1
};

var nbsp = " ";
var iexcl = "¡";
var cent = "¢";
var pound = "£";
var curren = "¤";
var yen = "¥";
var brvbar = "¦";
var sect = "§";
var uml = "¨";
var copy = "©";
var ordf = "ª";
var laquo = "«";
var not = "¬";
var shy = "­";
var reg = "®";
var macr = "¯";
var deg = "°";
var plusmn = "±";
var sup2 = "²";
var sup3 = "³";
var acute = "´";
var micro = "µ";
var para = "¶";
var middot = "·";
var cedil = "¸";
var sup1 = "¹";
var ordm = "º";
var raquo = "»";
var frac14 = "¼";
var frac12 = "½";
var frac34 = "¾";
var iquest = "¿";
var Agrave = "À";
var Aacute = "Á";
var Acirc = "Â";
var Atilde = "Ã";
var Auml = "Ä";
var Aring = "Å";
var AElig = "Æ";
var Ccedil = "Ç";
var Egrave = "È";
var Eacute = "É";
var Ecirc = "Ê";
var Euml = "Ë";
var Igrave = "Ì";
var Iacute = "Í";
var Icirc = "Î";
var Iuml = "Ï";
var ETH = "Ð";
var Ntilde = "Ñ";
var Ograve = "Ò";
var Oacute = "Ó";
var Ocirc = "Ô";
var Otilde = "Õ";
var Ouml = "Ö";
var times = "×";
var Oslash = "Ø";
var Ugrave = "Ù";
var Uacute = "Ú";
var Ucirc = "Û";
var Uuml = "Ü";
var Yacute = "Ý";
var THORN = "Þ";
var szlig = "ß";
var agrave = "à";
var aacute = "á";
var acirc = "â";
var atilde = "ã";
var auml = "ä";
var aring = "å";
var aelig = "æ";
var ccedil = "ç";
var egrave = "è";
var eacute = "é";
var ecirc = "ê";
var euml = "ë";
var igrave = "ì";
var iacute = "í";
var icirc = "î";
var iuml = "ï";
var eth = "ð";
var ntilde = "ñ";
var ograve = "ò";
var oacute = "ó";
var ocirc = "ô";
var otilde = "õ";
var ouml = "ö";
var divide = "÷";
var oslash = "ø";
var ugrave = "ù";
var uacute = "ú";
var ucirc = "û";
var uuml = "ü";
var yacute = "ý";
var thorn = "þ";
var yuml = "ÿ";
var fnof = "ƒ";
var Alpha = "Α";
var Beta = "Β";
var Gamma = "Γ";
var Delta = "Δ";
var Epsilon = "Ε";
var Zeta = "Ζ";
var Eta = "Η";
var Theta = "Θ";
var Iota = "Ι";
var Kappa = "Κ";
var Lambda = "Λ";
var Mu = "Μ";
var Nu = "Ν";
var Xi = "Ξ";
var Omicron = "Ο";
var Pi = "Π";
var Rho = "Ρ";
var Sigma = "Σ";
var Tau = "Τ";
var Upsilon = "Υ";
var Phi = "Φ";
var Chi = "Χ";
var Psi = "Ψ";
var Omega = "Ω";
var alpha = "α";
var beta = "β";
var gamma = "γ";
var delta = "δ";
var epsilon = "ε";
var zeta = "ζ";
var eta = "η";
var theta = "θ";
var iota = "ι";
var kappa = "κ";
var lambda = "λ";
var mu = "μ";
var nu = "ν";
var xi = "ξ";
var omicron = "ο";
var pi = "π";
var rho = "ρ";
var sigmaf = "ς";
var sigma = "σ";
var tau = "τ";
var upsilon = "υ";
var phi = "φ";
var chi = "χ";
var psi = "ψ";
var omega = "ω";
var thetasym = "ϑ";
var upsih = "ϒ";
var piv = "ϖ";
var bull = "•";
var hellip = "…";
var prime = "′";
var Prime = "″";
var oline = "‾";
var frasl = "⁄";
var weierp = "℘";
var image = "ℑ";
var real = "ℜ";
var trade = "™";
var alefsym = "ℵ";
var larr = "←";
var uarr = "↑";
var rarr = "→";
var darr = "↓";
var harr = "↔";
var crarr = "↵";
var lArr = "⇐";
var uArr = "⇑";
var rArr = "⇒";
var dArr = "⇓";
var hArr = "⇔";
var forall = "∀";
var part = "∂";
var exist = "∃";
var empty = "∅";
var nabla = "∇";
var isin = "∈";
var notin = "∉";
var ni = "∋";
var prod = "∏";
var sum = "∑";
var minus = "−";
var lowast = "∗";
var radic = "√";
var prop = "∝";
var infin = "∞";
var ang = "∠";
var and = "∧";
var or = "∨";
var cap = "∩";
var cup = "∪";
var int = "∫";
var there4 = "∴";
var sim = "∼";
var cong = "≅";
var asymp = "≈";
var ne = "≠";
var equiv = "≡";
var le = "≤";
var ge = "≥";
var sub = "⊂";
var sup = "⊃";
var nsub = "⊄";
var sube = "⊆";
var supe = "⊇";
var oplus = "⊕";
var otimes = "⊗";
var perp = "⊥";
var sdot = "⋅";
var lceil = "⌈";
var rceil = "⌉";
var lfloor = "⌊";
var rfloor = "⌋";
var lang = "〈";
var rang = "〉";
var loz = "◊";
var spades = "♠";
var clubs = "♣";
var hearts = "♥";
var diams = "♦";
var quot = "\"";
var amp = "&";
var lt = "<";
var gt = ">";
var OElig = "Œ";
var oelig = "œ";
var Scaron = "Š";
var scaron = "š";
var Yuml = "Ÿ";
var circ = "ˆ";
var tilde = "˜";
var ensp = " ";
var emsp = " ";
var thinsp = " ";
var zwnj = "‌";
var zwj = "‍";
var lrm = "‎";
var rlm = "‏";
var ndash = "–";
var mdash = "—";
var lsquo = "‘";
var rsquo = "’";
var sbquo = "‚";
var ldquo = "“";
var rdquo = "”";
var bdquo = "„";
var dagger = "†";
var Dagger = "‡";
var permil = "‰";
var lsaquo = "‹";
var rsaquo = "›";
var euro = "€";
var index = {
	nbsp: nbsp,
	iexcl: iexcl,
	cent: cent,
	pound: pound,
	curren: curren,
	yen: yen,
	brvbar: brvbar,
	sect: sect,
	uml: uml,
	copy: copy,
	ordf: ordf,
	laquo: laquo,
	not: not,
	shy: shy,
	reg: reg,
	macr: macr,
	deg: deg,
	plusmn: plusmn,
	sup2: sup2,
	sup3: sup3,
	acute: acute,
	micro: micro,
	para: para,
	middot: middot,
	cedil: cedil,
	sup1: sup1,
	ordm: ordm,
	raquo: raquo,
	frac14: frac14,
	frac12: frac12,
	frac34: frac34,
	iquest: iquest,
	Agrave: Agrave,
	Aacute: Aacute,
	Acirc: Acirc,
	Atilde: Atilde,
	Auml: Auml,
	Aring: Aring,
	AElig: AElig,
	Ccedil: Ccedil,
	Egrave: Egrave,
	Eacute: Eacute,
	Ecirc: Ecirc,
	Euml: Euml,
	Igrave: Igrave,
	Iacute: Iacute,
	Icirc: Icirc,
	Iuml: Iuml,
	ETH: ETH,
	Ntilde: Ntilde,
	Ograve: Ograve,
	Oacute: Oacute,
	Ocirc: Ocirc,
	Otilde: Otilde,
	Ouml: Ouml,
	times: times,
	Oslash: Oslash,
	Ugrave: Ugrave,
	Uacute: Uacute,
	Ucirc: Ucirc,
	Uuml: Uuml,
	Yacute: Yacute,
	THORN: THORN,
	szlig: szlig,
	agrave: agrave,
	aacute: aacute,
	acirc: acirc,
	atilde: atilde,
	auml: auml,
	aring: aring,
	aelig: aelig,
	ccedil: ccedil,
	egrave: egrave,
	eacute: eacute,
	ecirc: ecirc,
	euml: euml,
	igrave: igrave,
	iacute: iacute,
	icirc: icirc,
	iuml: iuml,
	eth: eth,
	ntilde: ntilde,
	ograve: ograve,
	oacute: oacute,
	ocirc: ocirc,
	otilde: otilde,
	ouml: ouml,
	divide: divide,
	oslash: oslash,
	ugrave: ugrave,
	uacute: uacute,
	ucirc: ucirc,
	uuml: uuml,
	yacute: yacute,
	thorn: thorn,
	yuml: yuml,
	fnof: fnof,
	Alpha: Alpha,
	Beta: Beta,
	Gamma: Gamma,
	Delta: Delta,
	Epsilon: Epsilon,
	Zeta: Zeta,
	Eta: Eta,
	Theta: Theta,
	Iota: Iota,
	Kappa: Kappa,
	Lambda: Lambda,
	Mu: Mu,
	Nu: Nu,
	Xi: Xi,
	Omicron: Omicron,
	Pi: Pi,
	Rho: Rho,
	Sigma: Sigma,
	Tau: Tau,
	Upsilon: Upsilon,
	Phi: Phi,
	Chi: Chi,
	Psi: Psi,
	Omega: Omega,
	alpha: alpha,
	beta: beta,
	gamma: gamma,
	delta: delta,
	epsilon: epsilon,
	zeta: zeta,
	eta: eta,
	theta: theta,
	iota: iota,
	kappa: kappa,
	lambda: lambda,
	mu: mu,
	nu: nu,
	xi: xi,
	omicron: omicron,
	pi: pi,
	rho: rho,
	sigmaf: sigmaf,
	sigma: sigma,
	tau: tau,
	upsilon: upsilon,
	phi: phi,
	chi: chi,
	psi: psi,
	omega: omega,
	thetasym: thetasym,
	upsih: upsih,
	piv: piv,
	bull: bull,
	hellip: hellip,
	prime: prime,
	Prime: Prime,
	oline: oline,
	frasl: frasl,
	weierp: weierp,
	image: image,
	real: real,
	trade: trade,
	alefsym: alefsym,
	larr: larr,
	uarr: uarr,
	rarr: rarr,
	darr: darr,
	harr: harr,
	crarr: crarr,
	lArr: lArr,
	uArr: uArr,
	rArr: rArr,
	dArr: dArr,
	hArr: hArr,
	forall: forall,
	part: part,
	exist: exist,
	empty: empty,
	nabla: nabla,
	isin: isin,
	notin: notin,
	ni: ni,
	prod: prod,
	sum: sum,
	minus: minus,
	lowast: lowast,
	radic: radic,
	prop: prop,
	infin: infin,
	ang: ang,
	and: and,
	or: or,
	cap: cap,
	cup: cup,
	int: int,
	there4: there4,
	sim: sim,
	cong: cong,
	asymp: asymp,
	ne: ne,
	equiv: equiv,
	le: le,
	ge: ge,
	sub: sub,
	sup: sup,
	nsub: nsub,
	sube: sube,
	supe: supe,
	oplus: oplus,
	otimes: otimes,
	perp: perp,
	sdot: sdot,
	lceil: lceil,
	rceil: rceil,
	lfloor: lfloor,
	rfloor: rfloor,
	lang: lang,
	rang: rang,
	loz: loz,
	spades: spades,
	clubs: clubs,
	hearts: hearts,
	diams: diams,
	quot: quot,
	amp: amp,
	lt: lt,
	gt: gt,
	OElig: OElig,
	oelig: oelig,
	Scaron: Scaron,
	scaron: scaron,
	Yuml: Yuml,
	circ: circ,
	tilde: tilde,
	ensp: ensp,
	emsp: emsp,
	thinsp: thinsp,
	zwnj: zwnj,
	zwj: zwj,
	lrm: lrm,
	rlm: rlm,
	ndash: ndash,
	mdash: mdash,
	lsquo: lsquo,
	rsquo: rsquo,
	sbquo: sbquo,
	ldquo: ldquo,
	rdquo: rdquo,
	bdquo: bdquo,
	dagger: dagger,
	Dagger: Dagger,
	permil: permil,
	lsaquo: lsaquo,
	rsaquo: rsaquo,
	euro: euro
};

var characterEntitiesHtml4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  nbsp: nbsp,
  iexcl: iexcl,
  cent: cent,
  pound: pound,
  curren: curren,
  yen: yen,
  brvbar: brvbar,
  sect: sect,
  uml: uml,
  copy: copy,
  ordf: ordf,
  laquo: laquo,
  not: not,
  shy: shy,
  reg: reg,
  macr: macr,
  deg: deg,
  plusmn: plusmn,
  sup2: sup2,
  sup3: sup3,
  acute: acute,
  micro: micro,
  para: para,
  middot: middot,
  cedil: cedil,
  sup1: sup1,
  ordm: ordm,
  raquo: raquo,
  frac14: frac14,
  frac12: frac12,
  frac34: frac34,
  iquest: iquest,
  Agrave: Agrave,
  Aacute: Aacute,
  Acirc: Acirc,
  Atilde: Atilde,
  Auml: Auml,
  Aring: Aring,
  AElig: AElig,
  Ccedil: Ccedil,
  Egrave: Egrave,
  Eacute: Eacute,
  Ecirc: Ecirc,
  Euml: Euml,
  Igrave: Igrave,
  Iacute: Iacute,
  Icirc: Icirc,
  Iuml: Iuml,
  ETH: ETH,
  Ntilde: Ntilde,
  Ograve: Ograve,
  Oacute: Oacute,
  Ocirc: Ocirc,
  Otilde: Otilde,
  Ouml: Ouml,
  times: times,
  Oslash: Oslash,
  Ugrave: Ugrave,
  Uacute: Uacute,
  Ucirc: Ucirc,
  Uuml: Uuml,
  Yacute: Yacute,
  THORN: THORN,
  szlig: szlig,
  agrave: agrave,
  aacute: aacute,
  acirc: acirc,
  atilde: atilde,
  auml: auml,
  aring: aring,
  aelig: aelig,
  ccedil: ccedil,
  egrave: egrave,
  eacute: eacute,
  ecirc: ecirc,
  euml: euml,
  igrave: igrave,
  iacute: iacute,
  icirc: icirc,
  iuml: iuml,
  eth: eth,
  ntilde: ntilde,
  ograve: ograve,
  oacute: oacute,
  ocirc: ocirc,
  otilde: otilde,
  ouml: ouml,
  divide: divide,
  oslash: oslash,
  ugrave: ugrave,
  uacute: uacute,
  ucirc: ucirc,
  uuml: uuml,
  yacute: yacute,
  thorn: thorn,
  yuml: yuml,
  fnof: fnof,
  Alpha: Alpha,
  Beta: Beta,
  Gamma: Gamma,
  Delta: Delta,
  Epsilon: Epsilon,
  Zeta: Zeta,
  Eta: Eta,
  Theta: Theta,
  Iota: Iota,
  Kappa: Kappa,
  Lambda: Lambda,
  Mu: Mu,
  Nu: Nu,
  Xi: Xi,
  Omicron: Omicron,
  Pi: Pi,
  Rho: Rho,
  Sigma: Sigma,
  Tau: Tau,
  Upsilon: Upsilon,
  Phi: Phi,
  Chi: Chi,
  Psi: Psi,
  Omega: Omega,
  alpha: alpha,
  beta: beta,
  gamma: gamma,
  delta: delta,
  epsilon: epsilon,
  zeta: zeta,
  eta: eta,
  theta: theta,
  iota: iota,
  kappa: kappa,
  lambda: lambda,
  mu: mu,
  nu: nu,
  xi: xi,
  omicron: omicron,
  pi: pi,
  rho: rho,
  sigmaf: sigmaf,
  sigma: sigma,
  tau: tau,
  upsilon: upsilon,
  phi: phi,
  chi: chi,
  psi: psi,
  omega: omega,
  thetasym: thetasym,
  upsih: upsih,
  piv: piv,
  bull: bull,
  hellip: hellip,
  prime: prime,
  Prime: Prime,
  oline: oline,
  frasl: frasl,
  weierp: weierp,
  image: image,
  real: real,
  trade: trade,
  alefsym: alefsym,
  larr: larr,
  uarr: uarr,
  rarr: rarr,
  darr: darr,
  harr: harr,
  crarr: crarr,
  lArr: lArr,
  uArr: uArr,
  rArr: rArr,
  dArr: dArr,
  hArr: hArr,
  forall: forall,
  part: part,
  exist: exist,
  empty: empty,
  nabla: nabla,
  isin: isin,
  notin: notin,
  ni: ni,
  prod: prod,
  sum: sum,
  minus: minus,
  lowast: lowast,
  radic: radic,
  prop: prop,
  infin: infin,
  ang: ang,
  and: and,
  or: or,
  cap: cap,
  cup: cup,
  int: int,
  there4: there4,
  sim: sim,
  cong: cong,
  asymp: asymp,
  ne: ne,
  equiv: equiv,
  le: le,
  ge: ge,
  sub: sub,
  sup: sup,
  nsub: nsub,
  sube: sube,
  supe: supe,
  oplus: oplus,
  otimes: otimes,
  perp: perp,
  sdot: sdot,
  lceil: lceil,
  rceil: rceil,
  lfloor: lfloor,
  rfloor: rfloor,
  lang: lang,
  rang: rang,
  loz: loz,
  spades: spades,
  clubs: clubs,
  hearts: hearts,
  diams: diams,
  quot: quot,
  amp: amp,
  lt: lt,
  gt: gt,
  OElig: OElig,
  oelig: oelig,
  Scaron: Scaron,
  scaron: scaron,
  Yuml: Yuml,
  circ: circ,
  tilde: tilde,
  ensp: ensp,
  emsp: emsp,
  thinsp: thinsp,
  zwnj: zwnj,
  zwj: zwj,
  lrm: lrm,
  rlm: rlm,
  ndash: ndash,
  mdash: mdash,
  lsquo: lsquo,
  rsquo: rsquo,
  sbquo: sbquo,
  ldquo: ldquo,
  rdquo: rdquo,
  bdquo: bdquo,
  dagger: dagger,
  Dagger: Dagger,
  permil: permil,
  lsaquo: lsaquo,
  rsaquo: rsaquo,
  euro: euro,
  'default': index
});

var dangerous$1 = [
	"cent",
	"copy",
	"divide",
	"gt",
	"lt",
	"not",
	"para",
	"times"
];

var dangerous$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': dangerous$1
});

var entities = getCjsExportFromNamespace(characterEntitiesHtml4);

var dangerous = getCjsExportFromNamespace(dangerous$2);

var decimal = isDecimal;



var stringifyEntities = encode;
encode.escape = escape;

var own$3 = {}.hasOwnProperty;

// List of enforced escapes.
var escapes = ['"', "'", '<', '>', '&', '`'];

// Map of characters to names.
var characters = construct();

// Default escapes.
var defaultEscapes = toExpression(escapes);

// Surrogate pairs.
var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;

// Non-ASCII characters.
// eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
var bmp = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;

// Encode special characters in `value`.
function encode(value, options) {
  var settings = options || {};
  var subset = settings.subset;
  var set = subset ? toExpression(subset) : defaultEscapes;
  var escapeOnly = settings.escapeOnly;
  var omit = settings.omitOptionalSemicolons;

  value = value.replace(set, replace);

  if (subset || escapeOnly) {
    return value
  }

  return value
    .replace(surrogatePair, replaceSurrogatePair)
    .replace(bmp, replace)

  function replaceSurrogatePair(pair, pos, val) {
    return toHexReference(
      (pair.charCodeAt(0) - 0xd800) * 0x400 +
        pair.charCodeAt(1) -
        0xdc00 +
        0x10000,
      val.charAt(pos + 2),
      omit
    )
  }

  function replace(char, pos, val) {
    return one$1(char, val.charAt(pos + 1), settings)
  }
}

// Shortcut to escape special characters in HTML.
function escape(value) {
  return encode(value, {escapeOnly: true, useNamedReferences: true})
}

// Encode `char` according to `options`.
function one$1(char, next, options) {
  var shortest = options.useShortestReferences;
  var omit = options.omitOptionalSemicolons;
  var named;
  var code;
  var numeric;
  var decimal;

  if ((shortest || options.useNamedReferences) && own$3.call(characters, char)) {
    named = toNamed(characters[char], next, omit, options.attribute);
  }

  if (shortest || !named) {
    code = char.charCodeAt(0);
    numeric = toHexReference(code, next, omit);

    // Use the shortest numeric reference when requested.
    // A simple algorithm would use decimal for all code points under 100, as
    // those are shorter than hexadecimal:
    //
    // * `&#99;` vs `&#x63;` (decimal shorter)
    // * `&#100;` vs `&#x64;` (equal)
    //
    // However, because we take `next` into consideration when `omit` is used,
    // And it would be possible that decimals are shorter on bigger values as
    // well if `next` is hexadecimal but not decimal, we instead compare both.
    if (shortest) {
      decimal = toDecimalReference(code, next, omit);

      if (decimal.length < numeric.length) {
        numeric = decimal;
      }
    }
  }

  if (named && (!shortest || named.length < numeric.length)) {
    return named
  }

  return numeric
}

// Transform `code` into an entity.
function toNamed(name, next, omit, attribute) {
  var value = '&' + name;

  if (
    omit &&
    own$3.call(legacy, name) &&
    dangerous.indexOf(name) === -1 &&
    (!attribute || (next && next !== '=' && !isAlphanumerical(next)))
  ) {
    return value
  }

  return value + ';'
}

// Transform `code` into a hexadecimal character reference.
function toHexReference(code, next, omit) {
  var value = '&#x' + code.toString(16).toUpperCase();
  return omit && next && !isHexadecimal(next) ? value : value + ';'
}

// Transform `code` into a decimal character reference.
function toDecimalReference(code, next, omit) {
  var value = '&#' + String(code);
  return omit && next && !decimal(next) ? value : value + ';'
}

// Create an expression for `characters`.
function toExpression(characters) {
  return new RegExp('[' + characters.join('') + ']', 'g')
}

// Construct the map.
function construct() {
  var chars = {};
  var name;

  for (name in entities) {
    chars[entities[name]] = name;
  }

  return chars
}

// Characters.
var NULL = '\0';
var AMP = '&';
var SP = ' ';
var TB = '\t';
var GR = '`';
var DQ$1 = '"';
var SQ$1 = "'";
var EQ = '=';
var LT = '<';
var GT = '>';
var SO = '/';
var LF = '\n';
var CR = '\r';
var FF = '\f';

var whitespace = [SP, TB, LF, CR, FF];
// https://html.spec.whatwg.org/#attribute-name-state
var name = whitespace.concat(AMP, SO, GT, EQ);
// https://html.spec.whatwg.org/#attribute-value-(unquoted)-state
var unquoted$1 = whitespace.concat(AMP, GT);
var unquotedSafe = unquoted$1.concat(NULL, DQ$1, SQ$1, LT, EQ, GR);
// https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state
var singleQuoted$1 = [AMP, SQ$1];
// https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state
var doubleQuoted$1 = [AMP, DQ$1];

// Maps of subsets. Each value is a matrix of tuples.
// The first value causes parse errors, the second is valid.
// Of both values, the first value is unsafe, and the second is safe.
var constants = {
  name: [[name, name.concat(DQ$1, SQ$1, GR)], [name.concat(NULL, DQ$1, SQ$1, LT), name.concat(NULL, DQ$1, SQ$1, LT, GR)]],
  unquoted: [[unquoted$1, unquotedSafe], [unquotedSafe, unquotedSafe]],
  single: [
    [singleQuoted$1, singleQuoted$1.concat(DQ$1, GR)],
    [singleQuoted$1.concat(NULL), singleQuoted$1.concat(NULL, DQ$1, GR)]
  ],
  double: [
    [doubleQuoted$1, doubleQuoted$1.concat(SQ$1, GR)],
    [doubleQuoted$1.concat(NULL), doubleQuoted$1.concat(NULL, SQ$1, GR)]
  ]
};

var spaces = spaceSeparatedTokens.stringify;
var commas = commaSeparatedTokens.stringify;





var element_1 = element;

/* Constants. */
var emptyString = '';

/* Characters. */
var space$1 = ' ';
var quotationMark = '"';
var apostrophe$1 = "'";
var equalsTo = '=';
var lessThan$1 = '<';
var greaterThan = '>';
var slash$1 = '/';
var newLine = '\n';

/* Stringify an element `node`. */
function element(ctx, node, index, parent, printWidthOffset, innerTextLength) {
  var parentSchema = ctx.schema;
  var name = node.tagName;
  var value = '';
  var selfClosing;
  var close;
  var omit;
  var root = node;
  var content;
  var attrs;
  var indentLevel = getNodeData(node, 'indentLevel', 0);
  var printContext = {
    offset: printWidthOffset,
    wrapAttributes: false,
    indentLevel
  };
  var isVoid = ctx.voids.indexOf(name) !== -1;
  var ignoreAttrCollapsing =
    getNodeData(node, 'ignore', false) || getNodeData(node, 'preserveAttrWrapping', false);

  if (parentSchema.space === 'html' && name === 'svg') {
    ctx.schema = svg_1;
  }

  if (ctx.schema.space === 'svg') {
    omit = false;
    close = true;
    selfClosing = ctx.closeEmpty;
  } else {
    omit = ctx.omit;
    close = ctx.close;
    selfClosing = isVoid;
  }

  // check for 'selfClosing' property set by hast-util-from-webparser package
  // in order to support custom self-closing elements
  if (selfClosing === false) {
    selfClosing = getNodeData(node, 'selfClosing', false);
  }

  // <
  printContext.offset += lessThan$1.length;

  // tagName length
  printContext.offset += node.tagName.length;

  // / closing tag
  if (selfClosing && !isVoid) {
    printContext.offset += slash$1.length;
  }

  // >
  printContext.offset += greaterThan.length;

  const propertyCount = Object.keys(node.properties).length;

  // force to wrap attributes on multiple lines when the node contains
  // more than one attribute
  if (propertyCount > 1 && ctx.wrapAttributes) {
    printContext.wrapAttributes = true;
  }

  // one space before each attribute
  if (propertyCount) {
    printContext.offset += propertyCount * space$1.length;
  }

  // represent the length of the inner text of the node
  printContext.offset += innerTextLength;

  attrs = attributes(ctx, node.properties, printContext, ignoreAttrCollapsing);

  const shouldCollapse = ignoreAttrCollapsing === false && printContext.wrapAttributes;

  content = all_1(ctx, root);

  /* If the node is categorised as void, but it has
   * children, remove the categorisation.  This
   * enables for example `menuitem`s, which are
   * void in W3C HTML but not void in WHATWG HTML, to
   * be stringified properly. */
  selfClosing = content ? false : selfClosing;

  if (attrs || !omit || !omit.opening(node, index, parent)) {
    value = lessThan$1 + name;

    if (attrs) {
      // add no space after tagName when element is collapsed
      if (shouldCollapse) {
        value += attrs;
      } else {
        value += space$1 + attrs;
      }
    }

    let selfClosed = false;

    // check if the should close self-closing elements
    if (selfClosing && close) {
      if ((!ctx.tightClose || attrs.charAt(attrs.length - 1) === slash$1) && !shouldCollapse) {
        value += space$1;
      }

      if (shouldCollapse) {
        value += newLine + repeatString(ctx.tabWidth, printContext.indentLevel);
      }

      selfClosed = true;
      value += slash$1;
    }

    // allow any element to self close itself except known HTML void elements
    else if (selfClosing && !isVoid) {
      if (shouldCollapse) {
        value += newLine + repeatString(ctx.tabWidth, printContext.indentLevel);
      }

      selfClosed = true;
      value += slash$1;
    }

    // add newline when element should be wrappend on multiple lines and when
    // it's no self-closing element because in that case the newline was already added before the slash (/)
    if (shouldCollapse && !selfClosed) {
      value += newLine + repeatString(ctx.tabWidth, printContext.indentLevel);
    }

    value += greaterThan;
  }

  value += content;

  if (!selfClosing && (!omit || !omit.closing(node, index, parent))) {
    value += lessThan$1 + slash$1 + name + greaterThan;
  }

  ctx.schema = parentSchema;

  return value
}

/* Stringify all attributes. */
function attributes(ctx, props, printContext, ignoreIndent) {
  var values = [];
  var key;
  var value;
  var result;
  var length;
  var index;
  var last;

  for (key in props) {
    value = props[key];

    if (value == null) {
      continue
    }

    result = attribute$1(ctx, key, value);

    printContext.offset += result.length;

    if (ignoreIndent === false && printContext.offset > ctx.printWidth) {
      printContext.wrapAttributes = true;
    }

    if (result) {
      values.push(result);
    }
  }

  length = values.length;
  index = -1;

  while (++index < length) {
    result = values[index];
    last = null;

    /* In tight mode, don’t add a space after quoted attributes. */
    if (last !== quotationMark && last !== apostrophe$1) {
      if (printContext.wrapAttributes) {
        values[index] = newLine + repeatString(ctx.tabWidth, printContext.indentLevel + 1) + result;
      } else if (index !== length - 1) {
        values[index] = result + space$1;
      } else {
        values[index] = result;
      }
    }
  }

  return values.join(emptyString)
}

/* Stringify one attribute. */
function attribute$1(ctx, key, value) {
  var schema = ctx.schema;
  var info = find_1(schema, key);
  var name = info.attribute;

  if (value == null || (typeof value === 'number' && isNaN(value)) || (value === false && info.boolean)) {
    return emptyString
  }

  name = attributeName$1(ctx, name);

  if ((value === true && info.boolean) || (value === true && info.overloadedBoolean)) {
    return name
  }

  return name + attributeValue$1(ctx, key, value, info)
}

/* Stringify the attribute name. */
function attributeName$1(ctx, name) {
  // Always encode without parse errors in non-HTML.
  var valid = ctx.schema.space === 'html' ? ctx.valid : 1;
  var subset = constants.name[valid][ctx.safe];

  return stringifyEntities(name, immutable(ctx.entities, { subset: subset }))
}

/* Stringify the attribute value. */
function attributeValue$1(ctx, key, value, info) {
  var quote = ctx.quote;

  if (typeof value === 'object' && 'length' in value) {
    /* `spaces` doesn’t accept a second argument, but it’s
     * given here just to keep the code cleaner. */
    value = (info.commaSeparated ? commas : spaces)(value, {
      padLeft: !ctx.tightLists
    });
  }

  value = String(value);

  // When attr has no value we avoid quoting
  if (value === '') {
    return value
  } else {
    value = equalsTo + quote + value + quote;
  }

  return value
}

function getNodeData(node, key, defaultValue) {
  let data = node.data || {};
  return data[key] || defaultValue
}

var doctype_1 = doctype;

/* Stringify a doctype `node`. */
function doctype(ctx, node) {
  var sep = ctx.tightDoctype ? '' : ' ';
  var name = node.name;
  var pub = node.public;
  var sys = node.system;
  var val = ['<!doctype'];

  if (name) {
    val.push(sep, name);

    if (pub != null) {
      val.push(' public', sep, smart(pub));
    } else if (sys != null) {
      val.push(' system');
    }

    if (sys != null) {
      val.push(sep, smart(sys));
    }
  }

  return val.join('') + '>'
}

function smart(value) {
  var quote = value.indexOf('"') === -1 ? '"' : "'";
  return quote + value + quote
}

var comment_1 = comment;

/* Stringify a comment `node`. */
function comment(ctx, node) {
  return '<!--' + node.value + '-->'
}

var raw_1 = raw;

/* Stringify `raw`. */
function raw(ctx, node) {
  return node.value
}

var one_1 = one;

var own$2 = {}.hasOwnProperty;

var handlers = {};

handlers.root = all_1;
handlers.text = text_1;
handlers.element = element_1;
handlers.doctype = doctype_1;
handlers.comment = comment_1;
handlers.raw = raw_1;

/* Stringify `node`. */
function one(ctx, node, index, parent, printWidthOffset, innerTextLength) {
  var type = node && node.type;

  if (!type) {
    throw new Error('Expected node, not `' + node + '`')
  }

  if (!own$2.call(handlers, type)) {
    throw new Error('Cannot compile unknown node `' + type + '`')
  }

  return handlers[type](ctx, node, index, parent, printWidthOffset, innerTextLength)
}

var voids = getCjsExportFromNamespace(htmlVoidElements);

var lib$1 = toHTML;

/* Characters. */
var DQ = '"';
var SQ = "'";

/* Stringify the given HAST node. */
function toHTML(node, options) {
  var settings = options || {};
  var quote = settings.singleQuote ? SQ : DQ;
  var printWidth = settings.printWidth === undefined ? 80 : settings.printWidth;
  var useTabs = settings.useTabs;
  var tabWidth = settings.tabWidth || 2;
  var wrapAttributes = settings.wrapAttributes;

  if (useTabs) {
    tabWidth = '\t';
  } else if (typeof tabWidth === 'number') {
    tabWidth = repeatString(' ', tabWidth);
  }

  return one_1(
    {
      valid: settings.allowParseErrors ? 0 : 1,
      safe: settings.allowDangerousCharacters ? 0 : 1,
      schema: settings.space === 'svg' ? svg_1 : html_1,
      omit: settings.omitOptionalTags && omission,
      quote: quote,
      printWidth: printWidth,
      tabWidth: tabWidth,
      wrapAttributes: wrapAttributes,
      tightDoctype: Boolean(settings.tightDoctype),
      tightLists: settings.tightCommaSeparatedLists,
      voids: settings.voids || voids.concat(),
      entities: settings.entities || {},
      close: settings.closeSelfClosing,
      tightClose: settings.tightSelfClosing,
      closeEmpty: settings.closeEmptyElements
    },
    node
  )
}

var prettyhtmlHastToHtml = lib$1;

const void_els = [
	'area',
	'base',
	'br',
	'col',
	'embed',
	'hr',
	'img',
	'input',
	'link',
	'meta',
	'param',
	'source',
	'track',
	'wbr',
];

// these regex don't check if it is a valid svelte tag name
// i want to defer to svelte's compiler errors so i don't end up reimplementing the svelte parser

const RE_SVELTE_TAG = /^<svelte:([a-z]*)[\s\S]*(?:(?:svelte:[a-z]*)|(?:\/))>$/;
const RE_SVELTE_TAG_START = /(^\s*)<([\\/\s])*svelte:/;

function parse_svelte_tag(
	eat,
	value,
	silent
) {
	const is_svelte_tag = RE_SVELTE_TAG_START.exec(value);

	if (is_svelte_tag) {
		if (silent) return true;

		const trimmed_value = value.trim();
		let cbPos = 0;
		let pos = 1;
		let current_tag = '';
		let in_tag_name = false;

		while (cbPos > -1) {
			if (!trimmed_value[pos]) {
				break;
			}

			if (trimmed_value[pos].match(/</)) {
				cbPos++;
				current_tag = '';
				in_tag_name = true;
			}

			if (in_tag_name && trimmed_value[pos].match(/\s/)) {
				in_tag_name = false;
			}

			if (in_tag_name && !trimmed_value[pos].match(/</)) {
				current_tag += trimmed_value[pos];
			}

			const is_void = void_els.includes(current_tag);

			if (
				(is_void && trimmed_value[pos].match(/>/)) ||
				(trimmed_value[pos - 1] + trimmed_value[pos]).match(/\/>/)
			) {
				cbPos--;
			}

			if ((trimmed_value[pos - 1] + trimmed_value[pos]).match(/<\//)) {
				let inner_indent = 0;

				while (inner_indent > -1) {
					if (trimmed_value[pos].match(/>/)) {
						pos++;
						inner_indent -= 1;
						cbPos -= 2;
					} else {
						pos++;
					}
				}
			}

			pos++;
		}

		const match = RE_SVELTE_TAG.exec(trimmed_value.substring(0, pos).trim());

		if (!match) return;

		return eat(is_svelte_tag[1] + match[0])({
			type: 'svelteTag',
			value: match[0],
			name: match[1],
		});
	}
}

// these regex don't check if it is a valid block name
// i want to defer to svelte's compiler errors so i don't end up reimplementing the svelte parser
// 'else if' is a special case due to the annoying whitespace

const RE_SVELTE_BLOCK_START = /(^\s*){[#:/@]/;
const RE_SVELTE_BLOCK = /^{[#:/@](else if|[a-z]+).*}$/;

function parse_svelte_block(
	eat,
	value,
	silent
) {
	const is_svelte_block = RE_SVELTE_BLOCK_START.exec(value);

	if (is_svelte_block) {
		if (silent) return true;

		const trimmed_value = value.trim();
		let cbPos = 0;
		let pos = 1;

		while (cbPos > -1) {
			if (trimmed_value[pos].match(/{/)) cbPos++;
			if (trimmed_value[pos].match(/}/)) cbPos--;
			pos++;
		}

		const match = RE_SVELTE_BLOCK.exec(trimmed_value.substring(0, pos));

		if (!match) return;

		return eat(is_svelte_block[1] + match[0])({
			type: 'svelteBlock',
			value: `${is_svelte_block[1]}${match[0]}`,
			name: match[1],
		});
	}
}

const dotAllPolyfill = '[\0-\uFFFF]';

const attributeName = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
const unquoted = '[^"\'=<>`\\u0000-\\u0020]+';
const singleQuoted = "'[^']*'";
const doubleQuoted = '"[^"]*"';
const jsProps = '{.*}'.replace('.', dotAllPolyfill);
const attributeValue =
	'(?:' +
	unquoted +
	'|' +
	singleQuoted +
	'|' +
	doubleQuoted +
	'|' +
	jsProps +
	')';
const attribute =
	'(?:\\s+' + attributeName + '(?:\\s*=\\s*' + attributeValue + ')?)';
const openTag = '<[A-Za-z]*[A-Za-z0-9\\.\\-]*' + attribute + '*\\s*\\/?>';
const closeTag = '<\\/[A-Za-z][A-Za-z0-9\\.\\-]*\\s*>';

const openCloseTag = new RegExp('^(?:' + openTag + '|' + closeTag + ')');

const tab = '\t';
const space = ' ';
const lineFeed = '\n';
const lessThan = '<';

const rawOpenExpression = /^<(script|pre|style)(?=(\s|>|$))/i;
const rawCloseExpression = /<\/(script|pre|style)>/i;
const commentOpenExpression = /^<!--/;
const commentCloseExpression = /-->/;
const instructionOpenExpression = /^<\?/;
const instructionCloseExpression = /\?>/;
const directiveOpenExpression = /^<![A-Za-z]/;
const directiveCloseExpression = />/;
const cdataOpenExpression = /^<!\[CDATA\[/;
const cdataCloseExpression = /\]\]>/;
const elementCloseExpression = /^$/;
const otherElementOpenExpression = new RegExp(openCloseTag.source + '\\s*$');
const fragmentOpenExpression = /^<>/;

//@ts-ignore
function blockHtml(
	eat,
	value,
	silent
) {
	const blocks = '[a-z\\.]*(\\.){0,1}[a-z][a-z0-9\\.]*';
	const elementOpenExpression = new RegExp(
		'^</?(' + blocks + ')(?=(\\s|/?>|$))',
		'i'
	);

	const length = value.length;
	let index = 0;
	let next;
	let line;
	let offset;
	let character;
	let sequence;

	const sequences = [
		[rawOpenExpression, rawCloseExpression, true],
		[commentOpenExpression, commentCloseExpression, true],
		[instructionOpenExpression, instructionCloseExpression, true],
		[directiveOpenExpression, directiveCloseExpression, true],
		[cdataOpenExpression, cdataCloseExpression, true],
		[elementOpenExpression, elementCloseExpression, true],
		[fragmentOpenExpression, elementCloseExpression, true],
		[otherElementOpenExpression, elementCloseExpression, false],
	];

	// Eat initial spacing.
	while (index < length) {
		character = value.charAt(index);

		if (character !== tab && character !== space) {
			break;
		}

		index++;
	}

	if (value.charAt(index) !== lessThan) {
		return;
	}

	next = value.indexOf(lineFeed, index + 1);
	next = next === -1 ? length : next;
	line = value.slice(index, next);
	offset = -1;
	const count = sequences.length;

	while (++offset < count) {
		if (sequences[offset][0].test(line)) {
			sequence = sequences[offset];
			break;
		}
	}

	if (!sequence) {
		return;
	}

	if (silent) {
		return sequence[2];
	}

	index = next;

	if (!sequence[1].test(line)) {
		while (index < length) {
			next = value.indexOf(lineFeed, index + 1);
			next = next === -1 ? length : next;
			line = value.slice(index + 1, next);

			if (sequence[1].test(line)) {
				if (line) {
					index = next;
				}

				break;
			}

			index = next;
		}
	}

	const subvalue = value.slice(0, index);

	return eat(subvalue)({ type: 'html', value: subvalue });
}

function mdsvex_parser() {
	const Parser = this.Parser;
	const block_tokenizers = Parser.prototype.blockTokenizers;
	const methods = Parser.prototype.blockMethods;

	block_tokenizers.svelteBlock = parse_svelte_block;
	block_tokenizers.svelteTag = parse_svelte_tag;
	block_tokenizers.html = blockHtml;
	block_tokenizers.indentedCode = indentedCode;

	methods.splice(methods.indexOf('html'), 0, 'svelteBlock');
	methods.splice(methods.indexOf('html'), 0, 'svelteTag');
}

function indentedCode() {
	return true;
}

// Expose a frozen processor.
var unified_1 = unified().freeze();

var slice = [].slice;
var own$1 = {}.hasOwnProperty;

// Process pipeline.
var pipeline = trough_1()
  .use(pipelineParse)
  .use(pipelineRun)
  .use(pipelineStringify);

function pipelineParse(p, ctx) {
  ctx.tree = p.parse(ctx.file);
}

function pipelineRun(p, ctx, next) {
  p.run(ctx.tree, ctx.file, done);

  function done(err, tree, file) {
    if (err) {
      next(err);
    } else {
      ctx.tree = tree;
      ctx.file = file;
      next();
    }
  }
}

function pipelineStringify(p, ctx) {
  ctx.file.contents = p.stringify(ctx.tree, ctx.file);
}

// Function to create the first processor.
function unified() {
  var attachers = [];
  var transformers = trough_1();
  var namespace = {};
  var frozen = false;
  var freezeIndex = -1;

  // Data management.
  processor.data = data;

  // Lock.
  processor.freeze = freeze;

  // Plugins.
  processor.attachers = attachers;
  processor.use = use;

  // API.
  processor.parse = parse;
  processor.stringify = stringify;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process;
  processor.processSync = processSync;

  // Expose.
  return processor

  // Create a new processor based on the processor in the current scope.
  function processor() {
    var destination = unified();
    var length = attachers.length;
    var index = -1;

    while (++index < length) {
      destination.use.apply(null, attachers[index]);
    }

    destination.data(extend$2(true, {}, namespace));

    return destination
  }

  // Freeze: used to signal a processor that has finished configuration.
  //
  // For example, take unified itself: it’s frozen.
  // Plugins should not be added to it.
  // Rather, it should be extended, by invoking it, before modifying it.
  //
  // In essence, always invoke this when exporting a processor.
  function freeze() {
    var values;
    var plugin;
    var options;
    var transformer;

    if (frozen) {
      return processor
    }

    while (++freezeIndex < attachers.length) {
      values = attachers[freezeIndex];
      plugin = values[0];
      options = values[1];
      transformer = null;

      if (options === false) {
        continue
      }

      if (options === true) {
        values[1] = undefined;
      }

      transformer = plugin.apply(processor, values.slice(1));

      if (typeof transformer === 'function') {
        transformers.use(transformer);
      }
    }

    frozen = true;
    freezeIndex = Infinity;

    return processor
  }

  // Data management.
  // Getter / setter for processor-specific informtion.
  function data(key, value) {
    if (typeof key === 'string') {
      // Set `key`.
      if (arguments.length === 2) {
        assertUnfrozen('data', frozen);

        namespace[key] = value;

        return processor
      }

      // Get `key`.
      return (own$1.call(namespace, key) && namespace[key]) || null
    }

    // Set space.
    if (key) {
      assertUnfrozen('data', frozen);
      namespace = key;
      return processor
    }

    // Get space.
    return namespace
  }

  // Plugin management.
  //
  // Pass it:
  // *   an attacher and options,
  // *   a preset,
  // *   a list of presets, attachers, and arguments (list of attachers and
  //     options).
  function use(value) {
    var settings;

    assertUnfrozen('use', frozen);

    if (value === null || value === undefined) ; else if (typeof value === 'function') {
      addPlugin.apply(null, arguments);
    } else if (typeof value === 'object') {
      if ('length' in value) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new Error('Expected usable value, not `' + value + '`')
    }

    if (settings) {
      namespace.settings = extend$2(namespace.settings || {}, settings);
    }

    return processor

    function addPreset(result) {
      addList(result.plugins);

      if (result.settings) {
        settings = extend$2(settings || {}, result.settings);
      }
    }

    function add(value) {
      if (typeof value === 'function') {
        addPlugin(value);
      } else if (typeof value === 'object') {
        if ('length' in value) {
          addPlugin.apply(null, value);
        } else {
          addPreset(value);
        }
      } else {
        throw new Error('Expected usable value, not `' + value + '`')
      }
    }

    function addList(plugins) {
      var length;
      var index;

      if (plugins === null || plugins === undefined) ; else if (typeof plugins === 'object' && 'length' in plugins) {
        length = plugins.length;
        index = -1;

        while (++index < length) {
          add(plugins[index]);
        }
      } else {
        throw new Error('Expected a list of plugins, not `' + plugins + '`')
      }
    }

    function addPlugin(plugin, value) {
      var entry = find(plugin);

      if (entry) {
        if (isPlainObj(entry[1]) && isPlainObj(value)) {
          value = extend$2(entry[1], value);
        }

        entry[1] = value;
      } else {
        attachers.push(slice.call(arguments));
      }
    }
  }

  function find(plugin) {
    var length = attachers.length;
    var index = -1;
    var entry;

    while (++index < length) {
      entry = attachers[index];

      if (entry[0] === plugin) {
        return entry
      }
    }
  }

  // Parse a file (in string or vfile representation) into a unist node using
  // the `Parser` on the processor.
  function parse(doc) {
    var file = vfile(doc);
    var Parser;

    freeze();
    Parser = processor.Parser;
    assertParser('parse', Parser);

    if (newable(Parser, 'parse')) {
      return new Parser(String(file), file).parse()
    }

    return Parser(String(file), file) // eslint-disable-line new-cap
  }

  // Run transforms on a unist node representation of a file (in string or
  // vfile representation), async.
  function run(node, file, cb) {
    assertNode(node);
    freeze();

    if (!cb && typeof file === 'function') {
      cb = file;
      file = null;
    }

    if (!cb) {
      return new Promise(executor)
    }

    executor(null, cb);

    function executor(resolve, reject) {
      transformers.run(node, vfile(file), done);

      function done(err, tree, file) {
        tree = tree || node;
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(tree);
        } else {
          cb(null, tree, file);
        }
      }
    }
  }

  // Run transforms on a unist node representation of a file (in string or
  // vfile representation), sync.
  function runSync(node, file) {
    var complete = false;
    var result;

    run(node, file, done);

    assertDone('runSync', 'run', complete);

    return result

    function done(err, tree) {
      complete = true;
      bail_1(err);
      result = tree;
    }
  }

  // Stringify a unist node representation of a file (in string or vfile
  // representation) into a string using the `Compiler` on the processor.
  function stringify(node, doc) {
    var file = vfile(doc);
    var Compiler;

    freeze();
    Compiler = processor.Compiler;
    assertCompiler('stringify', Compiler);
    assertNode(node);

    if (newable(Compiler, 'compile')) {
      return new Compiler(node, file).compile()
    }

    return Compiler(node, file) // eslint-disable-line new-cap
  }

  // Parse a file (in string or vfile representation) into a unist node using
  // the `Parser` on the processor, then run transforms on that node, and
  // compile the resulting node using the `Compiler` on the processor, and
  // store that result on the vfile.
  function process(doc, cb) {
    freeze();
    assertParser('process', processor.Parser);
    assertCompiler('process', processor.Compiler);

    if (!cb) {
      return new Promise(executor)
    }

    executor(null, cb);

    function executor(resolve, reject) {
      var file = vfile(doc);

      pipeline.run(processor, {file: file}, done);

      function done(err) {
        if (err) {
          reject(err);
        } else if (resolve) {
          resolve(file);
        } else {
          cb(null, file);
        }
      }
    }
  }

  // Process the given document (in string or vfile representation), sync.
  function processSync(doc) {
    var complete = false;
    var file;

    freeze();
    assertParser('processSync', processor.Parser);
    assertCompiler('processSync', processor.Compiler);
    file = vfile(doc);

    process(file, done);

    assertDone('processSync', 'process', complete);

    return file

    function done(err) {
      complete = true;
      bail_1(err);
    }
  }
}

// Check if `value` is a constructor.
function newable(value, name) {
  return (
    typeof value === 'function' &&
    value.prototype &&
    // A function with keys in its prototype is probably a constructor.
    // Classes’ prototype methods are not enumerable, so we check if some value
    // exists in the prototype.
    (keys(value.prototype) || name in value.prototype)
  )
}

// Check if `value` is an object with keys.
function keys(value) {
  var key;
  for (key in value) {
    return true
  }

  return false
}

// Assert a parser is available.
function assertParser(name, Parser) {
  if (typeof Parser !== 'function') {
    throw new Error('Cannot `' + name + '` without `Parser`')
  }
}

// Assert a compiler is available.
function assertCompiler(name, Compiler) {
  if (typeof Compiler !== 'function') {
    throw new Error('Cannot `' + name + '` without `Compiler`')
  }
}

// Assert the processor is not frozen.
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      'Cannot invoke `' +
        name +
        '` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.'
    )
  }
}

// Assert `node` is a unist node.
function assertNode(node) {
  if (!node || typeof node.type !== 'string') {
    throw new Error('Expected node, got `' + node + '`')
  }
}

// Assert that `complete` is `true`.
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      '`' + name + '` finished async. Use `' + asyncName + '` instead'
    )
  }
}

var nlcstToString_1 = nlcstToString;

// Stringify one nlcst node or list of nodes.
function nlcstToString(node, separator) {
  var sep = separator || '';
  var values;
  var length;
  var children;

  if (!node || (!('length' in node) && !node.type)) {
    throw new Error('Expected node, not `' + node + '`')
  }

  if (typeof node.value === 'string') {
    return node.value
  }

  children = 'length' in node ? node : node.children;
  length = children.length;

  // Shortcut: This is pretty common, and a small performance win.
  if (length === 1 && 'value' in children[0]) {
    return children[0].value
  }

  values = [];

  while (length--) {
    values[length] = nlcstToString(children[length], sep);
  }

  return values.join(sep)
}

var tokenizer = tokenizerFactory;

// Factory to create a tokenizer based on a given `expression`.
function tokenizerFactory(childType, expression) {
  return tokenizer

  // A function that splits.
  function tokenizer(node) {
    var children = [];
    var tokens = node.children;
    var type = node.type;
    var length = tokens.length;
    var index = -1;
    var lastIndex = length - 1;
    var start = 0;
    var first;
    var last;
    var parent;

    while (++index < length) {
      if (
        index === lastIndex ||
        (tokens[index].type === childType &&
          expression.test(nlcstToString_1(tokens[index])))
      ) {
        first = tokens[start];
        last = tokens[index];

        parent = {
          type: type,
          children: tokens.slice(start, index + 1)
        };

        if (first.position && last.position) {
          parent.position = {
            start: first.position.start,
            end: last.position.end
          };
        }

        children.push(parent);

        start = index + 1;
      }
    }

    return children
  }
}

var parser = parserFactory;

// Construct a parser based on `options`.
function parserFactory(options) {
  var type = options.type;
  var tokenizerProperty = options.tokenizer;
  var delimiter = options.delimiter;
  var tokenize = delimiter && tokenizer(options.delimiterType, delimiter);

  return parser

  function parser(value) {
    var children = this[tokenizerProperty](value);

    return {
      type: type,
      children: tokenize ? tokenize(children) : children
    }
  }
}

// This module is generated by `script/build-expressions.js`.

var expressions = {
  affixSymbol: /^([\)\]\}\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63]|["'\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21]|[!\.\?\u2026\u203D])\1*$/,
  newLine: /^[ \t]*((\r?\n|\r)[\t ]*)+$/,
  newLineMulti: /^[ \t]*((\r?\n|\r)[\t ]*){2,}$/,
  terminalMarker: /^((?:[!\.\?\u2026\u203D])+)$/,
  wordSymbolInner: /^((?:[&'\x2D\.:=\?@\xAD\xB7\u2010\u2011\u2019\u2027])|(?:_)+)$/,
  numerical: /^(?:[0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D58-\u0D5E\u0D66-\u0D78\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDD30-\uDD39\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2]|\uD807[\uDC50-\uDC6C\uDD50-\uDD59\uDDA0-\uDDA9\uDFC0-\uDFD4]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C])+$/,
  digitStart: /^\d/,
  lowerInitial: /^(?:[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0560-\u0588\u10D0-\u10FA\u10FD-\u10FF\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7AF\uA7B5\uA7B7\uA7B9\uA7BB\uA7BD\uA7BF\uA7C3\uA7FA\uAB30-\uAB5A\uAB60-\uAB67\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43])/,
  surrogates: /[\uD800-\uDFFF]/,
  punctuation: /[!"'-\),-\/:;\?\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u201F\u2022-\u2027\u2032-\u203A\u203C-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/,
  word: /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D3-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09F4-\u09F9\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BF2\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7E\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D63\u0D66-\u0D78\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F33\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u17F0-\u17F9\u180B-\u180D\u1810-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABE\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u20D0-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BA\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA672\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA827\uA830-\uA835\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE6\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD27\uDD30-\uDD39\uDE60-\uDE7E\uDF00-\uDF27\uDF30-\uDF54\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC52-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD46\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E\uDC5F\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF3B]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCF2\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/,
  whiteSpace: /[\t-\r \x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/
};

var arrayIterate = iterate;

var own = {}.hasOwnProperty;

function iterate(values, callback, context) {
  var index = -1;
  var result;

  if (!values) {
    throw new Error('Iterate requires that |this| not be ' + values)
  }

  if (!own.call(values, 'length')) {
    throw new Error('Iterate requires that |this| has a `length`')
  }

  if (typeof callback !== 'function') {
    throw new Error('`callback` must be a function')
  }

  // The length might change, so we do not cache it.
  while (++index < values.length) {
    // Skip missing values.
    if (!(index in values)) {
      continue
    }

    result = callback.call(context, values[index], index, values);

    // If `callback` returns a `number`, move `index` over to `number`.
    if (typeof result === 'number') {
      // Make sure that negative numbers do not break the loop.
      if (result < 0) {
        index = 0;
      }

      index = result - 1;
    }
  }
}

var unistUtilModifyChildren = modifierFactory;

// Turn `callback` into a child-modifier accepting a parent.  See
// `array-iterate` for more info.
function modifierFactory(callback) {
  return iteratorFactory(wrapperFactory(callback))
}

// Turn `callback` into a `iterator' accepting a parent.
function iteratorFactory(callback) {
  return iterator

  function iterator(parent) {
    var children = parent && parent.children;

    if (!children) {
      throw new Error('Missing children in `parent` for `modifier`')
    }

    return arrayIterate(children, callback, parent)
  }
}

// Pass the context as the third argument to `callback`.
function wrapperFactory(callback) {
  return wrapper

  function wrapper(value, index) {
    return callback(value, index, this)
  }
}

var mergeInitialWordSymbol_1 = unistUtilModifyChildren(mergeInitialWordSymbol);

// Merge certain punctuation marks into their following words.
function mergeInitialWordSymbol(child, index, parent) {
  var children;
  var next;

  if (
    (child.type !== 'SymbolNode' && child.type !== 'PunctuationNode') ||
    nlcstToString_1(child) !== '&'
  ) {
    return
  }

  children = parent.children;

  next = children[index + 1];

  // If either a previous word, or no following word, exists, exit early.
  if (
    (index !== 0 && children[index - 1].type === 'WordNode') ||
    !(next && next.type === 'WordNode')
  ) {
    return
  }

  // Remove `child` from parent.
  children.splice(index, 1);

  // Add the punctuation mark at the start of the next node.
  next.children.unshift(child);

  // Update position.
  if (next.position && child.position) {
    next.position.start = child.position.start;
  }

  // Next, iterate over the node at the previous position, as it's now adjacent
  // to a following word.
  return index - 1
}

var mergeFinalWordSymbol_1 = unistUtilModifyChildren(mergeFinalWordSymbol$1);

// Merge certain punctuation marks into their preceding words.
function mergeFinalWordSymbol$1(child, index, parent) {
  var children;
  var prev;
  var next;

  if (
    index !== 0 &&
    (child.type === 'SymbolNode' || child.type === 'PunctuationNode') &&
    nlcstToString_1(child) === '-'
  ) {
    children = parent.children;

    prev = children[index - 1];
    next = children[index + 1];

    if (
      (!next || next.type !== 'WordNode') &&
      prev &&
      prev.type === 'WordNode'
    ) {
      // Remove `child` from parent.
      children.splice(index, 1);

      // Add the punctuation mark at the end of the previous node.
      prev.children.push(child);

      // Update position.
      if (prev.position && child.position) {
        prev.position.end = child.position.end;
      }

      // Next, iterate over the node *now* at the current position (which was
      // the next node).
      return index
    }
  }
}

var mergeInnerWordSymbol_1 = unistUtilModifyChildren(mergeInnerWordSymbol);

// Symbols part of surrounding words.
var wordSymbolInner = expressions.wordSymbolInner;

// Merge words joined by certain punctuation marks.
function mergeInnerWordSymbol(child, index, parent) {
  var siblings;
  var sibling;
  var prev;
  var last;
  var position;
  var tokens;
  var queue;

  if (
    index !== 0 &&
    (child.type === 'SymbolNode' || child.type === 'PunctuationNode')
  ) {
    siblings = parent.children;
    prev = siblings[index - 1];

    if (prev && prev.type === 'WordNode') {
      position = index - 1;

      tokens = [];
      queue = [];

      // -   If a token which is neither word nor inner word symbol is found,
      //     the loop is broken
      // -   If an inner word symbol is found,  it’s queued
      // -   If a word is found, it’s queued (and the queue stored and emptied)
      while (siblings[++position]) {
        sibling = siblings[position];

        if (sibling.type === 'WordNode') {
          tokens = tokens.concat(queue, sibling.children);

          queue = [];
        } else if (
          (sibling.type === 'SymbolNode' ||
            sibling.type === 'PunctuationNode') &&
          wordSymbolInner.test(nlcstToString_1(sibling))
        ) {
          queue.push(sibling);
        } else {
          break
        }
      }

      if (tokens.length !== 0) {
        // If there is a queue, remove its length from `position`.
        if (queue.length !== 0) {
          position -= queue.length;
        }

        // Remove every (one or more) inner-word punctuation marks and children
        // of words.
        siblings.splice(index, position - index);

        // Add all found tokens to `prev`s children.
        prev.children = prev.children.concat(tokens);

        last = tokens[tokens.length - 1];

        // Update position.
        if (prev.position && last.position) {
          prev.position.end = last.position.end;
        }

        // Next, iterate over the node *now* at the current position.
        return index
      }
    }
  }
}

var mergeInnerWordSlash_1 = unistUtilModifyChildren(mergeInnerWordSlash);

var slash = '/';

// Merge words joined by certain punctuation marks.
function mergeInnerWordSlash(child, index, parent) {
  var siblings = parent.children;
  var prev;
  var next;
  var prevValue;
  var nextValue;
  var queue;
  var tail;
  var count;

  prev = siblings[index - 1];
  next = siblings[index + 1];

  if (
    prev &&
    prev.type === 'WordNode' &&
    (child.type === 'SymbolNode' || child.type === 'PunctuationNode') &&
    nlcstToString_1(child) === slash
  ) {
    prevValue = nlcstToString_1(prev);
    tail = child;
    queue = [child];
    count = 1;

    if (next && next.type === 'WordNode') {
      nextValue = nlcstToString_1(next);
      tail = next;
      queue = queue.concat(next.children);
      count++;
    }

    if (prevValue.length < 3 && (!nextValue || nextValue.length < 3)) {
      // Add all found tokens to `prev`s children.
      prev.children = prev.children.concat(queue);

      siblings.splice(index, count);

      // Update position.
      if (prev.position && tail.position) {
        prev.position.end = tail.position.end;
      }

      // Next, iterate over the node *now* at the current position.
      return index
    }
  }
}

var mergeInitialisms_1 = unistUtilModifyChildren(mergeInitialisms);

var numerical = expressions.numerical;

// Merge initialisms.
function mergeInitialisms(child, index, parent) {
  var siblings;
  var prev;
  var children;
  var length;
  var position;
  var otherChild;
  var isAllDigits;
  var value;

  if (index !== 0 && nlcstToString_1(child) === '.') {
    siblings = parent.children;

    prev = siblings[index - 1];
    children = prev.children;

    length = children && children.length;

    if (prev.type === 'WordNode' && length !== 1 && length % 2 !== 0) {
      position = length;

      isAllDigits = true;

      while (children[--position]) {
        otherChild = children[position];

        value = nlcstToString_1(otherChild);

        if (position % 2 === 0) {
          // Initialisms consist of one character values.
          if (value.length > 1) {
            return
          }

          if (!numerical.test(value)) {
            isAllDigits = false;
          }
        } else if (value !== '.') {
          if (position < length - 2) {
            break
          } else {
            return
          }
        }
      }

      if (!isAllDigits) {
        // Remove `child` from parent.
        siblings.splice(index, 1);

        // Add child to the previous children.
        children.push(child);

        // Update position.
        if (prev.position && child.position) {
          prev.position.end = child.position.end;
        }

        // Next, iterate over the node *now* at the current position.
        return index
      }
    }
  }
}

var mergeWords = unistUtilModifyChildren(mergeFinalWordSymbol);

// Merge multiple words. This merges the children of adjacent words, something
// which should not occur naturally by parse-latin, but might happen when custom
// tokens were passed in.
function mergeFinalWordSymbol(child, index, parent) {
  var siblings = parent.children;
  var next;

  if (child.type === 'WordNode') {
    next = siblings[index + 1];

    if (next && next.type === 'WordNode') {
      // Remove `next` from parent.
      siblings.splice(index + 1, 1);

      // Add the punctuation mark at the end of the previous node.
      child.children = child.children.concat(next.children);

      // Update position.
      if (next.position && child.position) {
        child.position.end = next.position.end;
      }

      // Next, re-iterate the current node.
      return index
    }
  }
}

var unistUtilVisitChildren = visitChildren;

function visitChildren(callback) {
  return visitor

  // Visit `parent`, invoking `callback` for each child.
  function visitor(parent) {
    var index = -1;
    var children = parent && parent.children;

    if (!children) {
      throw new Error('Missing children in `parent` for `visitor`')
    }

    while (++index in children) {
      callback(children[index], index, parent);
    }
  }
}

var patchPosition_1 = unistUtilVisitChildren(patchPosition);

// Patch the position on a parent node based on its first and last child.
function patchPosition(child, index, node) {
  var siblings = node.children;

  if (!child.position) {
    return
  }

  if (
    index === 0 &&
    (!node.position || /* istanbul ignore next */ !node.position.start)
  ) {
    patch(node);
    node.position.start = child.position.start;
  }

  if (index === siblings.length - 1 && (!node.position || !node.position.end)) {
    patch(node);
    node.position.end = child.position.end;
  }
}

// Add a `position` object when it does not yet exist on `node`.
function patch(node) {
  if (!node.position) {
    node.position = {};
  }
}

var mergeNonWordSentences_1 = unistUtilModifyChildren(mergeNonWordSentences);

// Merge a sentence into the following sentence, when the sentence does not
// contain word tokens.
function mergeNonWordSentences(child, index, parent) {
  var children = child.children;
  var position = -1;
  var prev;
  var next;

  while (children[++position]) {
    if (children[position].type === 'WordNode') {
      return
    }
  }

  prev = parent.children[index - 1];

  if (prev) {
    prev.children = prev.children.concat(children);

    // Remove the child.
    parent.children.splice(index, 1);

    // Patch position.
    if (prev.position && child.position) {
      prev.position.end = child.position.end;
    }

    // Next, iterate over the node *now* at the current position (which was the
    // next node).
    return index
  }

  next = parent.children[index + 1];

  if (next) {
    next.children = children.concat(next.children);

    // Patch position.
    if (next.position && child.position) {
      next.position.start = child.position.start;
    }

    // Remove the child.
    parent.children.splice(index, 1);
  }
}

var mergeAffixSymbol_1 = unistUtilModifyChildren(mergeAffixSymbol);

// Closing or final punctuation, or terminal markers that should still be
// included in the previous sentence, even though they follow the sentence’s
// terminal marker.
var affixSymbol = expressions.affixSymbol;

// Move certain punctuation following a terminal marker (thus in the next
// sentence) to the previous sentence.
function mergeAffixSymbol(child, index, parent) {
  var children = child.children;
  var first;
  var second;
  var prev;

  if (children && children.length !== 0 && index !== 0) {
    first = children[0];
    second = children[1];
    prev = parent.children[index - 1];

    if (
      (first.type === 'SymbolNode' || first.type === 'PunctuationNode') &&
      affixSymbol.test(nlcstToString_1(first))
    ) {
      prev.children.push(children.shift());

      // Update position.
      if (first.position && prev.position) {
        prev.position.end = first.position.end;
      }

      if (second && second.position && child.position) {
        child.position.start = second.position.start;
      }

      // Next, iterate over the previous node again.
      return index - 1
    }
  }
}

var mergeInitialLowerCaseLetterSentences_1 = unistUtilModifyChildren(mergeInitialLowerCaseLetterSentences);

// Initial lowercase letter.
var lowerInitial = expressions.lowerInitial;

// Merge a sentence into its previous sentence, when the sentence starts with a
// lower case letter.
function mergeInitialLowerCaseLetterSentences(child, index, parent) {
  var children = child.children;
  var position;
  var node;
  var siblings;
  var prev;

  if (children && children.length !== 0 && index !== 0) {
    position = -1;

    while (children[++position]) {
      node = children[position];

      if (node.type === 'WordNode') {
        if (!lowerInitial.test(nlcstToString_1(node))) {
          return
        }

        siblings = parent.children;

        prev = siblings[index - 1];

        prev.children = prev.children.concat(children);

        siblings.splice(index, 1);

        // Update position.
        if (prev.position && child.position) {
          prev.position.end = child.position.end;
        }

        // Next, iterate over the node *now* at the current position.
        return index
      }

      if (node.type === 'SymbolNode' || node.type === 'PunctuationNode') {
        return
      }
    }
  }
}

var mergeInitialDigitSentences_1 = unistUtilModifyChildren(mergeInitialDigitSentences);

// Initial lowercase letter.
var digit = expressions.digitStart;

// Merge a sentence into its previous sentence, when the sentence starts with a
// lower case letter.
function mergeInitialDigitSentences(child, index, parent) {
  var children = child.children;
  var siblings = parent.children;
  var prev = siblings[index - 1];
  var head = children[0];

  if (prev && head && head.type === 'WordNode' && digit.test(nlcstToString_1(head))) {
    prev.children = prev.children.concat(children);
    siblings.splice(index, 1);

    // Update position.
    if (prev.position && child.position) {
      prev.position.end = child.position.end;
    }

    // Next, iterate over the node *now* at the current position.
    return index
  }
}

var mergePrefixExceptions_1 = unistUtilModifyChildren(mergePrefixExceptions);

// Blacklist of full stop characters that should not be treated as terminal
// sentence markers: A case-insensitive abbreviation.
var abbreviationPrefix = new RegExp(
  '^(' +
    '[0-9]{1,3}|' +
    '[a-z]|' +
    // Common Latin Abbreviations:
    // Based on: <https://en.wikipedia.org/wiki/List_of_Latin_abbreviations>.
    // Where only the abbreviations written without joining full stops,
    // but with a final full stop, were extracted.
    //
    // circa, capitulus, confer, compare, centum weight, eadem, (et) alii,
    // et cetera, floruit, foliis, ibidem, idem, nemine && contradicente,
    // opere && citato, (per) cent, (per) procurationem, (pro) tempore,
    // sic erat scriptum, (et) sequentia, statim, videlicet. */
    'al|ca|cap|cca|cent|cf|cit|con|cp|cwt|ead|etc|ff|' +
    'fl|ibid|id|nem|op|pro|seq|sic|stat|tem|viz' +
    ')$'
);

// Merge a sentence into its next sentence, when the sentence ends with a
// certain word.
function mergePrefixExceptions(child, index, parent) {
  var children = child.children;
  var period;
  var node;
  var next;

  if (children && children.length > 1) {
    period = children[children.length - 1];

    if (period && nlcstToString_1(period) === '.') {
      node = children[children.length - 2];

      if (
        node &&
        node.type === 'WordNode' &&
        abbreviationPrefix.test(nlcstToString_1(node).toLowerCase())
      ) {
        // Merge period into abbreviation.
        node.children.push(period);
        children.pop();

        // Update position.
        if (period.position && node.position) {
          node.position.end = period.position.end;
        }

        // Merge sentences.
        next = parent.children[index + 1];

        if (next) {
          child.children = children.concat(next.children);

          parent.children.splice(index + 1, 1);

          // Update position.
          if (next.position && child.position) {
            child.position.end = next.position.end;
          }

          // Next, iterate over the current node again.
          return index - 1
        }
      }
    }
  }
}

var mergeAffixExceptions_1 = unistUtilModifyChildren(mergeAffixExceptions);

// Merge a sentence into its previous sentence, when the sentence starts with a
// comma.
function mergeAffixExceptions(child, index, parent) {
  var children = child.children;
  var node;
  var position;
  var value;
  var previousChild;

  if (!children || children.length === 0 || index === 0) {
    return
  }

  position = -1;

  while (children[++position]) {
    node = children[position];

    if (node.type === 'WordNode') {
      return
    }

    if (node.type === 'SymbolNode' || node.type === 'PunctuationNode') {
      value = nlcstToString_1(node);

      if (value !== ',' && value !== ';') {
        return
      }

      previousChild = parent.children[index - 1];

      previousChild.children = previousChild.children.concat(children);

      // Update position.
      if (previousChild.position && child.position) {
        previousChild.position.end = child.position.end;
      }

      parent.children.splice(index, 1);

      // Next, iterate over the node *now* at the current position.
      return index
    }
  }
}

var mergeRemainingFullStops_1 = unistUtilVisitChildren(mergeRemainingFullStops);

// Blacklist of full stop characters that should not be treated as terminal
// sentence markers: A case-insensitive abbreviation.
var terminalMarker = expressions.terminalMarker;

// Merge non-terminal-marker full stops into the previous word (if available),
// or the next word (if available).
function mergeRemainingFullStops(child) {
  var children = child.children;
  var position = children.length;
  var hasFoundDelimiter = false;
  var grandchild;
  var prev;
  var next;
  var nextNext;

  while (children[--position]) {
    grandchild = children[position];

    if (
      grandchild.type !== 'SymbolNode' &&
      grandchild.type !== 'PunctuationNode'
    ) {
      // This is a sentence without terminal marker, so we 'fool' the code to
      // make it think we have found one.
      if (grandchild.type === 'WordNode') {
        hasFoundDelimiter = true;
      }

      continue
    }

    // Exit when this token is not a terminal marker.
    if (!terminalMarker.test(nlcstToString_1(grandchild))) {
      continue
    }

    // Ignore the first terminal marker found (starting at the end), as it
    // should not be merged.
    if (!hasFoundDelimiter) {
      hasFoundDelimiter = true;

      continue
    }

    // Only merge a single full stop.
    if (nlcstToString_1(grandchild) !== '.') {
      continue
    }

    prev = children[position - 1];
    next = children[position + 1];

    if (prev && prev.type === 'WordNode') {
      nextNext = children[position + 2];

      // Continue when the full stop is followed by a space and another full
      // stop, such as: `{.} .`
      if (
        next &&
        nextNext &&
        next.type === 'WhiteSpaceNode' &&
        nlcstToString_1(nextNext) === '.'
      ) {
        continue
      }

      // Remove `child` from parent.
      children.splice(position, 1);

      // Add the punctuation mark at the end of the previous node.
      prev.children.push(grandchild);

      // Update position.
      if (grandchild.position && prev.position) {
        prev.position.end = grandchild.position.end;
      }

      position--;
    } else if (next && next.type === 'WordNode') {
      // Remove `child` from parent.
      children.splice(position, 1);

      // Add the punctuation mark at the start of the next node.
      next.children.unshift(grandchild);

      if (grandchild.position && next.position) {
        next.position.start = grandchild.position.start;
      }
    }
  }
}

var makeInitialWhiteSpaceSiblings_1 = unistUtilVisitChildren(makeInitialWhiteSpaceSiblings);

// Move white space starting a sentence up, so they are the siblings of
// sentences.
function makeInitialWhiteSpaceSiblings(child, index, parent) {
  var children = child.children;
  var next;

  if (
    children &&
    children.length !== 0 &&
    children[0].type === 'WhiteSpaceNode'
  ) {
    parent.children.splice(index, 0, children.shift());
    next = children[0];

    if (next && next.position && child.position) {
      child.position.start = next.position.start;
    }
  }
}

var makeFinalWhiteSpaceSiblings_1 = unistUtilModifyChildren(makeFinalWhiteSpaceSiblings);

// Move white space ending a paragraph up, so they are the siblings of
// paragraphs.
function makeFinalWhiteSpaceSiblings(child, index, parent) {
  var children = child.children;
  var prev;

  if (
    children &&
    children.length !== 0 &&
    children[children.length - 1].type === 'WhiteSpaceNode'
  ) {
    parent.children.splice(index + 1, 0, child.children.pop());
    prev = children[children.length - 1];

    if (prev && prev.position && child.position) {
      child.position.end = prev.position.end;
    }

    // Next, iterate over the current node again.
    return index
  }
}

var breakImplicitSentences_1 = unistUtilModifyChildren(breakImplicitSentences);

// Two or more new line characters.
var multiNewLine = expressions.newLineMulti;

// Break a sentence if a white space with more than one new-line is found.
function breakImplicitSentences(child, index, parent) {
  var children;
  var position;
  var length;
  var tail;
  var head;
  var end;
  var insertion;
  var node;

  if (child.type !== 'SentenceNode') {
    return
  }

  children = child.children;

  // Ignore first and last child.
  length = children.length - 1;
  position = 0;

  while (++position < length) {
    node = children[position];

    if (node.type !== 'WhiteSpaceNode' || !multiNewLine.test(nlcstToString_1(node))) {
      continue
    }

    child.children = children.slice(0, position);

    insertion = {
      type: 'SentenceNode',
      children: children.slice(position + 1)
    };

    tail = children[position - 1];
    head = children[position + 1];

    parent.children.splice(index + 1, 0, node, insertion);

    if (child.position && tail.position && head.position) {
      end = child.position.end;

      child.position.end = tail.position.end;

      insertion.position = {
        start: head.position.start,
        end: end
      };
    }

    return index + 1
  }
}

var removeEmptyNodes_1 = unistUtilModifyChildren(removeEmptyNodes);

// Remove empty children.
function removeEmptyNodes(child, index, parent) {
  if ('children' in child && child.children.length === 0) {
    parent.children.splice(index, 1);

    // Next, iterate over the node *now* at the current position (which was the
    // next node).
    return index
  }
}

var lib = ParseLatin;

// PARSE LATIN

// Transform Latin-script natural language into an NLCST-tree.
function ParseLatin(doc, file) {
  var value = file || doc;

  if (!(this instanceof ParseLatin)) {
    return new ParseLatin(doc, file)
  }

  this.doc = value ? String(value) : null;
}

// Quick access to the prototype.
var proto = ParseLatin.prototype;

// Default position.
proto.position = true;

// Create text nodes.
proto.tokenizeSymbol = createTextFactory('Symbol');
proto.tokenizeWhiteSpace = createTextFactory('WhiteSpace');
proto.tokenizePunctuation = createTextFactory('Punctuation');
proto.tokenizeSource = createTextFactory('Source');
proto.tokenizeText = createTextFactory('Text');

// Expose `run`.
proto.run = run;

// Inject `plugins` to modifiy the result of the method at `key` on the operated
// on context.
proto.use = useFactory(function(context, key, plugins) {
  context[key] = context[key].concat(plugins);
});

// Inject `plugins` to modifiy the result of the method at `key` on the operated
// on context, before any other.
proto.useFirst = useFactory(function(context, key, plugins) {
  context[key] = plugins.concat(context[key]);
});

// Easy access to the document parser. This additionally supports retext-style
// invocation: where an instance is created for each file, and the file is given
// on construction.
proto.parse = function(value) {
  return this.tokenizeRoot(value || this.doc)
};

// Transform a `value` into a list of `NLCSTNode`s.
proto.tokenize = function(value) {
  return tokenize(this, value)
};

// PARENT NODES
//
// All these nodes are `pluggable`: they come with a `use` method which accepts
// a plugin (`function(NLCSTNode)`).
// Every time one of these methods are called, the plugin is invoked with the
// node, allowing for easy modification.
//
// In fact, the internal transformation from `tokenize` (a list of words, white
// space, punctuation, and symbols) to `tokenizeRoot` (an NLCST tree), is also
// implemented through this mechanism.

// Create a `WordNode` with its children set to a single `TextNode`, its value
// set to the given `value`.
pluggable(ParseLatin, 'tokenizeWord', function(value, eat) {
  var add = (eat || noopEat)('');
  var parent = {type: 'WordNode', children: []};

  this.tokenizeText(value, eat, parent);

  return add(parent)
});

// Create a `SentenceNode` with its children set to `Node`s, their values set
// to the tokenized given `value`.
//
// Unless plugins add new nodes, the sentence is populated by `WordNode`s,
// `SymbolNode`s, `PunctuationNode`s, and `WhiteSpaceNode`s.
pluggable(
  ParseLatin,
  'tokenizeSentence',
  parser({
    type: 'SentenceNode',
    tokenizer: 'tokenize'
  })
);

// Create a `ParagraphNode` with its children set to `Node`s, their values set
// to the tokenized given `value`.
//
// Unless plugins add new nodes, the paragraph is populated by `SentenceNode`s
// and `WhiteSpaceNode`s.
pluggable(
  ParseLatin,
  'tokenizeParagraph',
  parser({
    type: 'ParagraphNode',
    delimiter: expressions.terminalMarker,
    delimiterType: 'PunctuationNode',
    tokenizer: 'tokenizeSentence'
  })
);

// Create a `RootNode` with its children set to `Node`s, their values set to the
// tokenized given `value`.
pluggable(
  ParseLatin,
  'tokenizeRoot',
  parser({
    type: 'RootNode',
    delimiter: expressions.newLine,
    delimiterType: 'WhiteSpaceNode',
    tokenizer: 'tokenizeParagraph'
  })
);

// PLUGINS

proto.use('tokenizeSentence', [
  mergeInitialWordSymbol_1,
  mergeFinalWordSymbol_1,
  mergeInnerWordSymbol_1,
  mergeInnerWordSlash_1,
  mergeInitialisms_1,
  mergeWords,
  patchPosition_1
]);

proto.use('tokenizeParagraph', [
  mergeNonWordSentences_1,
  mergeAffixSymbol_1,
  mergeInitialLowerCaseLetterSentences_1,
  mergeInitialDigitSentences_1,
  mergePrefixExceptions_1,
  mergeAffixExceptions_1,
  mergeRemainingFullStops_1,
  makeInitialWhiteSpaceSiblings_1,
  makeFinalWhiteSpaceSiblings_1,
  breakImplicitSentences_1,
  removeEmptyNodes_1,
  patchPosition_1
]);

proto.use('tokenizeRoot', [
  makeInitialWhiteSpaceSiblings_1,
  makeFinalWhiteSpaceSiblings_1,
  removeEmptyNodes_1,
  patchPosition_1
]);

// TEXT NODES

// Factory to create a `Text`.
function createTextFactory(type) {
  type += 'Node';

  return createText

  // Construct a `Text` from a bound `type`
  function createText(value, eat, parent) {
    if (value === null || value === undefined) {
      value = '';
    }

    return (eat || noopEat)(value)(
      {
        type: type,
        value: String(value)
      },
      parent
    )
  }
}

// Run transform plug-ins for `key` on `nodes`.
function run(key, nodes) {
  var wareKey = key + 'Plugins';
  var plugins = this[wareKey];
  var index = -1;

  if (plugins) {
    while (plugins[++index]) {
      plugins[index](nodes);
    }
  }

  return nodes
}

// Make a method “pluggable”.
function pluggable(Constructor, key, callback) {
  // Set a pluggable version of `callback` on `Constructor`.
  Constructor.prototype[key] = function() {
    return this.run(key, callback.apply(this, arguments))
  };
}

// Factory to inject `plugins`. Takes `callback` for the actual inserting.
function useFactory(callback) {
  return use

  // Validate if `plugins` can be inserted.
  // Invokes the bound `callback` to do the actual inserting.
  function use(key, plugins) {
    var self = this;
    var wareKey;

    // Throw if the method is not pluggable.
    if (!(key in self)) {
      throw new Error(
        'Illegal Invocation: Unsupported `key` for ' +
          '`use(key, plugins)`. Make sure `key` is a ' +
          'supported function'
      )
    }

    // Fail silently when no plugins are given.
    if (!plugins) {
      return
    }

    wareKey = key + 'Plugins';

    // Make sure `plugins` is a list.
    if (typeof plugins === 'function') {
      plugins = [plugins];
    } else {
      plugins = plugins.concat();
    }

    // Make sure `wareKey` exists.
    if (!self[wareKey]) {
      self[wareKey] = [];
    }

    // Invoke callback with the ware key and plugins.
    callback(self, wareKey, plugins);
  }
}

// CLASSIFY

// Match a word character.
var wordRe = expressions.word;

// Match a surrogate character.
var surrogatesRe = expressions.surrogates;

// Match a punctuation character.
var punctuationRe = expressions.punctuation;

// Match a white space character.
var whiteSpaceRe = expressions.whiteSpace;

// Transform a `value` into a list of `NLCSTNode`s.
function tokenize(parser, value) {
  var tokens;
  var offset;
  var line;
  var column;
  var index;
  var length;
  var character;
  var queue;
  var prev;
  var left;
  var right;
  var eater;

  if (value === null || value === undefined) {
    value = '';
  } else if (value instanceof String) {
    value = value.toString();
  }

  if (typeof value !== 'string') {
    // Return the given nodes if this is either an empty array, or an array with
    // a node as a first child.
    if ('length' in value && (!value[0] || value[0].type)) {
      return value
    }

    throw new Error(
      "Illegal invocation: '" +
        value +
        "' is not a valid argument for 'ParseLatin'"
    )
  }

  tokens = [];

  if (!value) {
    return tokens
  }

  index = 0;
  offset = 0;
  line = 1;
  column = 1;

  // Eat mechanism to use.
  eater = parser.position ? eat : noPositionEat;

  length = value.length;
  prev = '';
  queue = '';

  while (index < length) {
    character = value.charAt(index);

    if (whiteSpaceRe.test(character)) {
      right = 'WhiteSpace';
    } else if (punctuationRe.test(character)) {
      right = 'Punctuation';
    } else if (wordRe.test(character)) {
      right = 'Word';
    } else {
      right = 'Symbol';
    }

    tick();

    prev = character;
    character = '';
    left = right;
    right = null;

    index++;
  }

  tick();

  return tokens

  // Check one character.
  function tick() {
    if (
      left === right &&
      (left === 'Word' ||
        left === 'WhiteSpace' ||
        character === prev ||
        surrogatesRe.test(character))
    ) {
      queue += character;
    } else {
      // Flush the previous queue.
      if (queue) {
        parser['tokenize' + left](queue, eater);
      }

      queue = character;
    }
  }

  // Remove `subvalue` from `value`.
  // Expects `subvalue` to be at the start from `value`, and applies no
  // validation.
  function eat(subvalue) {
    var pos = position();

    update(subvalue);

    return apply

    // Add the given arguments, add `position` to the returned node, and return
    // the node.
    function apply() {
      return pos(add.apply(null, arguments))
    }
  }

  // Remove `subvalue` from `value`.
  // Does not patch positional information.
  function noPositionEat() {
    return apply

    // Add the given arguments and return the node.
    function apply() {
      return add.apply(null, arguments)
    }
  }

  // Add mechanism.
  function add(node, parent) {
    if (parent) {
      parent.children.push(node);
    } else {
      tokens.push(node);
    }

    return node
  }

  // Mark position and patch `node.position`.
  function position() {
    var before = now();

    // Add the position to a node.
    function patch(node) {
      node.position = new Position(before);

      return node
    }

    return patch
  }

  // Update line and column based on `value`.
  function update(subvalue) {
    var subvalueLength = subvalue.length;
    var character = -1;
    var lastIndex = -1;

    offset += subvalueLength;

    while (++character < subvalueLength) {
      if (subvalue.charAt(character) === '\n') {
        lastIndex = character;
        line++;
      }
    }

    if (lastIndex === -1) {
      column += subvalueLength;
    } else {
      column = subvalueLength - lastIndex;
    }
  }

  // Store position information for a node.
  function Position(start) {
    this.start = start;
    this.end = now();
  }

  // Get the current position.
  function now() {
    return {
      line: line,
      column: column,
      offset: offset
    }
  }
}

// Add mechanism used when text-tokenisers are called directly outside of the
// `tokenize` function.
function noopAdd(node, parent) {
  if (parent) {
    parent.children.push(node);
  }

  return node
}

// Eat and add mechanism without adding positional information, used when
// text-tokenisers are called directly outside of the `tokenize` function.
function noopEat() {
  return noopAdd
}

var parseLatin = lib;

var retextLatin = parse$1;
parse$1.Parser = parseLatin;

function parse$1() {
  this.Parser = unherit_1(parseLatin);
}

var retextStringify = stringify$1;

function stringify$1() {
  this.Compiler = compiler;
}

function compiler(tree) {
  return nlcstToString_1(tree)
}

var retext = unified_1()
  .use(retextLatin)
  .use(retextStringify)
  .freeze();

var retextSmartypants = smartypants;

var punctuation = 'PunctuationNode';
var symbol = 'SymbolNode';
var word = 'WordNode';
var whiteSpace = 'WhiteSpaceNode';

var decadeExpression = /^\d\ds$/;
var threeFullStopsExpression = /^\.{3,}$/;
var fullStopsExpression = /^\.+$/;
var threeDashes = '---';
var twoDashes = '--';
var emDash = '—';
var enDash = '–';
var ellipsis = '…';
var twoBackticks = '``';
var backtick = '`';
var twoSingleQuotes = "''";
var singleQuote = "'";
var apostrophe = '’';
var doubleQuote = '"';
var openingDoubleQuote = '“';
var closingDoubleQuote = '”';
var openingSingleQuote = '‘';
var closingSingleQuote = '’';
var closingQuotes = {};
var openingQuotes = {};

openingQuotes[doubleQuote] = openingDoubleQuote;
closingQuotes[doubleQuote] = closingDoubleQuote;
openingQuotes[singleQuote] = openingSingleQuote;
closingQuotes[singleQuote] = closingSingleQuote;

var educators = {};

// Expose educators.
educators.dashes = {
  true: dashes,
  oldschool: oldschool,
  inverted: inverted
};

educators.backticks = {
  true: backticks,
  all: all
};

educators.ellipses = {
  true: ellipses
};

educators.quotes = {
  true: quotes
};

// Attacher.
function smartypants(options) {
  var methods = [];
  var quotes;
  var ellipses;
  var backticks;
  var dashes;

  if (!options) {
    options = {};
  }

  if ('quotes' in options) {
    quotes = options.quotes;

    if (quotes !== Boolean(quotes)) {
      throw new TypeError(
        'Illegal invocation: `' +
          quotes +
          '` ' +
          'is not a valid value for `quotes` in ' +
          '`smartypants`'
      )
    }
  } else {
    quotes = true;
  }

  if ('ellipses' in options) {
    ellipses = options.ellipses;

    if (ellipses !== Boolean(ellipses)) {
      throw new TypeError(
        'Illegal invocation: `' +
          ellipses +
          '` ' +
          'is not a valid value for `ellipses` in ' +
          '`smartypants`'
      )
    }
  } else {
    ellipses = true;
  }

  if ('backticks' in options) {
    backticks = options.backticks;

    if (backticks !== Boolean(backticks) && backticks !== 'all') {
      throw new TypeError(
        'Illegal invocation: `' +
          backticks +
          '` ' +
          'is not a valid value for `backticks` in ' +
          '`smartypants`'
      )
    }

    if (backticks === 'all' && quotes === true) {
      throw new TypeError(
        'Illegal invocation: `backticks: ' +
          backticks +
          '` is not a valid value ' +
          'when `quotes: ' +
          quotes +
          '` in ' +
          '`smartypants`'
      )
    }
  } else {
    backticks = true;
  }

  if ('dashes' in options) {
    dashes = options.dashes;

    if (
      dashes !== Boolean(dashes) &&
      dashes !== 'oldschool' &&
      dashes !== 'inverted'
    ) {
      throw new TypeError(
        'Illegal invocation: `' +
          dashes +
          '` ' +
          'is not a valid value for `dahes` in ' +
          '`smartypants`'
      )
    }
  } else {
    dashes = true;
  }

  if (quotes !== false) {
    methods.push(educators.quotes[quotes]);
  }

  if (ellipses !== false) {
    methods.push(educators.ellipses[ellipses]);
  }

  if (backticks !== false) {
    methods.push(educators.backticks[backticks]);
  }

  if (dashes !== false) {
    methods.push(educators.dashes[dashes]);
  }

  return transformFactory(methods)
}

// Create a transformer for the bound methods.
function transformFactory(methods) {
  var length = methods.length;

  return transformer

  // Transformer.
  function transformer(tree) {
    unistUtilVisit(tree, visitor);
  }

  function visitor(node, position, parent) {
    var index = -1;

    if (node.type === punctuation || node.type === symbol) {
      while (++index < length) {
        methods[index](node, position, parent);
      }
    }
  }
}

// Transform three dahes into an em-dash, and two into an en-dash.
function oldschool(node) {
  if (node.value === threeDashes) {
    node.value = emDash;
  } else if (node.value === twoDashes) {
    node.value = enDash;
  }
}

// Transform two dahes into an em-dash.
function dashes(node) {
  if (node.value === twoDashes) {
    node.value = emDash;
  }
}

// Transform three dahes into an en-dash, and two into an em-dash.
function inverted(node) {
  if (node.value === threeDashes) {
    node.value = enDash;
  } else if (node.value === twoDashes) {
    node.value = emDash;
  }
}

// Transform double backticks and single quotes into smart quotes.
function backticks(node) {
  if (node.value === twoBackticks) {
    node.value = openingDoubleQuote;
  } else if (node.value === twoSingleQuotes) {
    node.value = closingDoubleQuote;
  }
}

// Transform single and double backticks and single quotes into smart quotes.
function all(node) {
  backticks(node);

  if (node.value === backtick) {
    node.value = openingSingleQuote;
  } else if (node.value === singleQuote) {
    node.value = closingSingleQuote;
  }
}

// Transform multiple dots into unicode ellipses.
function ellipses(node, index, parent) {
  var value = node.value;
  var siblings = parent.children;
  var position;
  var nodes;
  var sibling;
  var type;
  var count;
  var queue;

  // Simple node with three dots and without white-space.
  if (threeFullStopsExpression.test(node.value)) {
    node.value = ellipsis;
    return
  }

  if (!fullStopsExpression.test(value)) {
    return
  }

  // Search for dot-nodes with white-space between.
  nodes = [];
  position = index;
  count = 1;

  // It’s possible that the node is merged with an adjacent word-node.  In that
  // code, we cannot transform it because there’s no reference to the
  // grandparent.
  while (--position > 0) {
    sibling = siblings[position];

    if (sibling.type !== whiteSpace) {
      break
    }

    queue = sibling;
    sibling = siblings[--position];
    type = sibling && sibling.type;

    if (
      sibling &&
      (type === punctuation || type === symbol) &&
      fullStopsExpression.test(sibling.value)
    ) {
      nodes.push(queue, sibling);

      count++;

      continue
    }

    break
  }

  if (count < 3) {
    return
  }

  siblings.splice(index - nodes.length, nodes.length);

  node.value = ellipsis;
}

// Transform straight single- and double quotes into smart quotes.
// eslint-disable-next-line complexity
function quotes(node, index, parent) {
  var siblings = parent.children;
  var value = node.value;
  var next;
  var nextNext;
  var prev;
  var nextValue;

  if (value !== doubleQuote && value !== singleQuote) {
    return
  }

  prev = siblings[index - 1];
  next = siblings[index + 1];
  nextNext = siblings[index + 2];
  nextValue = next && nlcstToString_1(next);

  if (
    next &&
    nextNext &&
    (next.type === punctuation || next.type === symbol) &&
    nextNext.type !== word
  ) {
    // Special case if the very first character is a quote followed by
    // punctuation at a non-word-break. Close the quotes by brute force.
    node.value = closingQuotes[value];
  } else if (
    nextNext &&
    (nextValue === doubleQuote || nextValue === singleQuote) &&
    nextNext.type === word
  ) {
    // Special case for double sets of quotes:
    // `He said, "'Quoted' words in a larger quote."`
    node.value = openingQuotes[value];
    next.value = openingQuotes[nextValue];
  } else if (next && decadeExpression.test(nextValue)) {
    // Special case for decade abbreviations: `the '80s`
    node.value = closingQuotes[value];
  } else if (
    prev &&
    next &&
    (prev.type === whiteSpace ||
      prev.type === punctuation ||
      prev.type === symbol) &&
    next.type === word
  ) {
    // Get most opening single quotes.
    node.value = openingQuotes[value];
  } else if (
    prev &&
    prev.type !== whiteSpace &&
    prev.type !== symbol &&
    prev.type !== punctuation
  ) {
    // Closing quotes.
    node.value = closingQuotes[value];
  } else if (
    !next ||
    next.type === whiteSpace ||
    ((value === singleQuote || value === apostrophe) && nextValue === 's')
  ) {
    node.value = closingQuotes[value];
  } else {
    node.value = openingQuotes[value];
  }
}

function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


var isNothing_1      = isNothing;
var isObject_1       = isObject;
var toArray_1        = toArray;
var repeat_1         = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1         = extend;

var common = {
	isNothing: isNothing_1,
	isObject: isObject_1,
	toArray: toArray_1,
	repeat: repeat_1,
	isNegativeZero: isNegativeZero_1,
	extend: extend_1
};

// YAML error class. http://stackoverflow.com/questions/8458984

function YAMLException$1(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;


YAMLException$1.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


var exception = YAMLException$1;

function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


var mark = Mark;

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type$1(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

var type = Type$1;

/*eslint-disable max-len*/






function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema$1(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema$1.DEFAULT = null;


Schema$1.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema$1.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new exception('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema$1; })) {
    throw new exception('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type$1) { return type$1 instanceof type; })) {
    throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema$1({
    include: schemas,
    explicit: types
  });
};


var schema = Schema$1;

var str = new type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});

var seq = new type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});

var map = new type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});

var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

var _null = new type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

var bool = new type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

var int_1 = new type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // 20:59
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;

  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

var float_1 = new type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

var json = new schema({
  include: [
    failsafe
  ],
  implicit: [
    _null,
    bool,
    int_1,
    float_1
  ]
});

var core = new schema({
  include: [
    json
  ]
});

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

var timestamp = new type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

var merge = new type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require$1 = commonjsRequire;
  NodeBuffer = _require$1('buffer').Buffer;
} catch (__) {}




// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

var binary = new type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString$2.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

var omap = new type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

var _toString$1 = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString$1.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

var pairs = new type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

var set = new type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

var default_safe = new schema({
  include: [
    core
  ],
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

var _undefined = new type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

var regexp = new type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = commonjsRequire;
  esprima = _require('esprima');
} catch (_) {
  /* eslint-disable no-redeclare */
  /* global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}



function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
          ast.body[0].expression.type !== 'FunctionExpression')) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
        ast.body[0].expression.type !== 'FunctionExpression')) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === 'BlockStatement') {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  }
  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.
  /*eslint-disable no-new-func*/
  return new Function(params, 'return ' + source.slice(body[0], body[1]));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

var _function = new type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});

var default_full = schema.DEFAULT = new schema({
  include: [
    default_safe
  ],
  explicit: [
    _undefined,
    regexp,
    _function
  ]
});

/*eslint-disable max-len,no-use-before-define*/








var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State$1(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || default_full;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;
  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new exception(
    message,
    new mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty$1.call(overridableKeys, keyNode) &&
        _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      // Implicit resolving is not allowed for non-scalar types, and '?'
      // non-specific tag is only automatically assigned to plain scalars.
      //
      // We only need to check kind conformity in case user explicitly assigns '?'
      // tag, for example like this: "!<?> [0]"
      //
      if (state.result !== null && state.kind !== 'scalar') {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }

      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State$1(input, options);

  var nullpos = input.indexOf('\0');

  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, 'null byte is not allowed in input');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  var documents = loadDocuments(input, options);

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load$1(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception('expected a single document in the stream, but found more');
}


function safeLoadAll$1(input, iterator, options) {
  if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  return loadAll$1(input, iterator, common.extend({ schema: default_safe }, options));
}


function safeLoad$1(input, options) {
  return load$1(input, common.extend({ schema: default_safe }, options));
}


var loadAll_1     = loadAll$1;
var load_1        = load$1;
var safeLoadAll_1 = safeLoadAll$1;
var safeLoad_1    = safeLoad$1;

var loader = {
	loadAll: loadAll_1,
	load: load_1,
	safeLoadAll: safeLoadAll_1,
	safeLoad: safeLoad_1
};

/*eslint-disable no-use-before-define*/






var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_EQUALS               = 0x3D; /* = */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema        = options['schema'] || default_full;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// [24] b-line-feed       ::=     #xA    /* LF */
// [25] b-carriage-return ::=     #xD    /* CR */
// [3]  c-byte-order-mark ::=     #xFEFF
function isNsChar(c) {
  return isPrintable(c) && !isWhitespace(c)
    // byte-order-mark
    && c !== 0xFEFF
    // b-char
    && c !== CHAR_CARRIAGE_RETURN
    && c !== CHAR_LINE_FEED;
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c, prev) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
    // - c-flow-indicator
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // - ":" - "#"
    // /* An ns-char preceding */ "#"
    && c !== CHAR_COLON
    && ((c !== CHAR_SHARP) || (prev && isNsChar(prev)));
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_EQUALS
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | “%” | “@” | “`”)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char, prev_char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && isPlainSafe(char, prev_char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode &&
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {

    pairBuffer = '';
    if (index !== 0) pairBuffer += ', ';

    if (state.condenseFlow) pairBuffer += '"';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new exception('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;
      if (block && (state.dump.length !== 0)) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new exception('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump$1(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

  return '';
}

function safeDump$1(input, options) {
  return dump$1(input, common.extend({ schema: default_safe }, options));
}

var dump_1     = dump$1;
var safeDump_1 = safeDump$1;

var dumper = {
	dump: dump_1,
	safeDump: safeDump_1
};

function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


var Type                = type;
var Schema              = schema;
var FAILSAFE_SCHEMA     = failsafe;
var JSON_SCHEMA         = json;
var CORE_SCHEMA         = core;
var DEFAULT_SAFE_SCHEMA = default_safe;
var DEFAULT_FULL_SCHEMA = default_full;
var load                = loader.load;
var loadAll             = loader.loadAll;
var safeLoad            = loader.safeLoad;
var safeLoadAll         = loader.safeLoadAll;
var dump                = dumper.dump;
var safeDump            = dumper.safeDump;
var YAMLException       = exception;

// Deprecated schema names from JS-YAML 2.0.x
var MINIMAL_SCHEMA = failsafe;
var SAFE_SCHEMA    = default_safe;
var DEFAULT_SCHEMA = default_full;

// Deprecated functions from JS-YAML 1.x.x
var scan           = deprecated('scan');
var parse          = deprecated('parse');
var compose        = deprecated('compose');
var addConstructor = deprecated('addConstructor');

var jsYaml$1 = {
	Type: Type,
	Schema: Schema,
	FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
	JSON_SCHEMA: JSON_SCHEMA,
	CORE_SCHEMA: CORE_SCHEMA,
	DEFAULT_SAFE_SCHEMA: DEFAULT_SAFE_SCHEMA,
	DEFAULT_FULL_SCHEMA: DEFAULT_FULL_SCHEMA,
	load: load,
	loadAll: loadAll,
	safeLoad: safeLoad,
	safeLoadAll: safeLoadAll,
	dump: dump,
	safeDump: safeDump,
	YAMLException: YAMLException,
	MINIMAL_SCHEMA: MINIMAL_SCHEMA,
	SAFE_SCHEMA: SAFE_SCHEMA,
	DEFAULT_SCHEMA: DEFAULT_SCHEMA,
	scan: scan,
	parse: parse,
	compose: compose,
	addConstructor: addConstructor
};

var jsYaml = jsYaml$1;

/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */

/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Module exports.
 * @public
 */

var escapeHtml_1 = escapeHtml;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;';
        break;
      case 38: // &
        escape = '&amp;';
        break;
      case 39: // '
        escape = '&#39;';
        break;
      case 60: // <
        escape = '&lt;';
        break;
      case 62: // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index
    ? html + str.substring(lastIndex, index)
    : html;
}

function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }















// this needs a big old cleanup

const newline = '\n';
// extract the yaml from 'yaml' nodes and put them in the vfil for later use

function default_frontmatter(
	value,
	messages
) {
	try {
		return jsYaml.safeLoad(value) ;
	} catch (e) {
		messages.push(new vfileMessage('YAML failed to parse'));
	}
}

function parse_frontmatter({
	parse,
	type,
}) {
	const transformer = (tree, vFile) => {
		unistUtilVisit(tree, type, (node) => {
			const data = parse(node.value, vFile.messages);
			if (data) {
				// @ts-ignore
				vFile.data.fm = data;
			}
		});
	};

	return transformer;
}

// in code nodes replace the character witrh the html entities
// maybe I'll need more of these

const entites = [
	[/</g, '&lt;'],
	[/>/g, '&gt;'],
	[/{/g, '&#123;'],
	[/}/g, '&#125;'],
];

function escape_code({ blocks }) {
	return function (tree) {
		if (!blocks) {
			unistUtilVisit(tree, 'code', escape);
		}

		unistUtilVisit(tree, 'inlineCode', escape);

		function escape(node) {
			for (let i = 0; i < entites.length; i += 1) {
				node.value = node.value.replace(entites[i][0], entites[i][1]);
			}
		}
	};
}

// special case - process nodes with retext and smartypants
// retext plugins can't work generally due to the difficulties in converting between the two trees

function smartypants_transformer(options = {}) {
	const processor = retext().use(retextSmartypants, options);

	return function (tree) {
		unistUtilVisit(tree, 'text', (node) => {
			node.value = String(processor.processSync(node.value));
		});
	};
}

// regex for scripts and attributes

const attrs = `(?:\\s{0,1}[a-zA-z]+=(?:"){0,1}[a-zA-Z0-9]+(?:"){0,1})*`;
const context = `(?:\\s{0,1}context)=(?:"){0,1}module(?:"){0,1}`;

const RE_BLANK = /^\n+$|^\s+$/;

const RE_SCRIPT = new RegExp(`^(<script` + attrs + `>)`);

const RE_MODULE_SCRIPT = new RegExp(
	`^(<script` + attrs + context + attrs + `>)`
);

function extract_parts(nodes) {
	// since we are wrapping and replacing we need to keep track of the different component 'parts'
	// many special tags cannot be wrapped nor can style or script tags
	const parts = {
		special: [],
		html: [],
		instance: [],
		module: [],
		css: [],
	};

	// iterate through all top level child nodes and assign them to the correct 'part'
	// anything that is a normal HAST node gets stored as HTML untouched
	// everything else gets parsed by the svelte parser

	children: for (let i = 0; i < nodes.length; i += 1) {
		const empty_node =
			nodes[i].type === 'text' && RE_BLANK.exec(nodes[i].value );

		// i no longer knwo why i did this

		if (empty_node || !nodes[i].value) {
			if (
				!parts.html.length ||
				!(
					RE_BLANK.exec(nodes[i].value ) &&
					RE_BLANK.exec(parts.html[parts.html.length - 1].value )
				)
			) {
				parts.html.push(nodes[i]);
			}

			continue children;
		}

		let result










;
		try {
			result = parse$8(nodes[i].value );
		} catch (e) {
			parts.html.push(nodes[i]);
			continue children;
		}

		// svelte special tags that have to be top level
		if (!result.html || !result.html.children) return parts;

		const _parts

 = result.html.children.map((v) => {
			if (
				v.type === 'Options' ||
				v.type === 'Head' ||
				v.type === 'Window' ||
				v.type === 'Body'
			) {
				return ['special', v.start, v.end];
			} else {
				return ['html', v.start, v.end];
			}
		});

		results: for (const key in result) {
			if (key === 'html' || !result[key ])
				continue results;
			_parts.push([
				key ,
				result[key ].start,
				result[key ].end,
			]);
		}

		// sort them to ensure the array is in the order they appear in the source, no gaps
		// this might not be necessary any more, i forget
		const sorted = _parts.sort((a, b) => a[1] - b[1]);

		// push the nodes into the correct 'part' since they are sorted everything should be in the correct order
		sorted.forEach((next) => {
			parts[next[0]].push({
				type: 'raw',
				value: (nodes[i].value ).substring(next[1], next[2]),
			});
		});
	}

	return parts;
}

function map_layout_to_path(
	filename,
	layout_map
) {
	const match = Object.keys(layout_map).find((l) =>
		new RegExp(`\\` + `${path__default.sep}${l}` + `\\` + `${path__default.sep}`).test(
			path__default.normalize(filename).replace(process.cwd(), '')
		)
	);

	if (match) {
		return layout_map[match];
	} else {
		return layout_map['_'] ? layout_map['_'] : undefined;
	}
}

function generate_layout_import(
	layout
) {
	if (!layout) return false;

	return `import Layout_MDSVEX_DEFAULT${
		layout.components.length ? `, * as Components` : ''
	} from '${layout.path}';`;
}

function generate_layout({
	frontmatter_layout,
	layout_options,
	layout_mode,
	filename,
}




) {
	let selected_layout;
	const error = { reason: '' };

	if (!layout_options || frontmatter_layout === false) {
		return [false, false, false];
	} else if (layout_mode === 'single') {
		selected_layout = layout_options.__mdsvex_default;
		if (frontmatter_layout)
			error.reason = `You attempted to apply a named layout in the front-matter of "${filename}", but did not provide any named layouts as options to the preprocessor. `;
	} else if (frontmatter_layout) {
		selected_layout = layout_options[frontmatter_layout];
		if (!selected_layout)
			error.reason = `Could not find a layout with the name "${frontmatter_layout}" and no fall back layout ("_") was provided.`;
	} else {
		selected_layout = map_layout_to_path(filename, layout_options);
	}

	return [
		generate_layout_import(selected_layout),
		selected_layout !== undefined &&
			selected_layout.components.length > 0 &&
			selected_layout.components,
		error.reason ? error : false,
	];
}

function transform_hast({
	layout,
	layout_mode,
}


) {
	return function transformer(tree, vFile) {
		// we need to keep { and } intact for svelte, so reverse the escaping in links and images
		// if anyone actually uses these characters for any other reason i'll probably just cry
		unistUtilVisit(tree, 'element', (node) => {
			if (
				node.tagName === 'a' &&
				node.properties &&
				typeof node.properties.href === 'string'
			) {
				node.properties.href = node.properties.href
					.replace(/%7B/g, '{')
					.replace(/%7D/g, '}');
			}

			if (
				node.tagName === 'img' &&
				node.properties &&
				typeof node.properties.src === 'string'
			) {
				node.properties.src = node.properties.src
					.replace(/%7B/g, '{')
					.replace(/%7D/g, '}');
			}
		});

		// the rest only applies to layouts and front matter
		// this  breaks position data
		// svelte preprocessors don't currently support sourcemaps
		// i'll fix this when they do

		//@ts-ignore
		if (!layout && !vFile.data.fm) return tree;

		unistUtilVisit(tree, 'root', (node) => {
			const { special, html, instance, module: _module, css } = extract_parts(
				node.children 
			);

			const { fm: metadata } = vFile.data ;

			// Workaround for script and style tags in strings
			// https://github.com/sveltejs/svelte/issues/5292
			const stringified =
				metadata &&
				JSON.stringify(metadata).replace(/<(\/?script|\/?style)/g, '<"+"$1');

			const fm =
				metadata &&
				`export const metadata = ${stringified};${newline}` +
					`\tconst { ${Object.keys(metadata).join(', ')} } = metadata;`;

			const frontmatter_layout =
				metadata && (metadata.layout );

			const [import_script, components, error] = generate_layout({
				frontmatter_layout,
				layout_options: layout,
				layout_mode,
				//@ts-ignore
				filename: vFile.filename,
			});

			if (error) vFile.messages.push(new vfileMessage(error.reason));

			if (components) {
				for (let i = 0; i < components.length; i++) {
					unistUtilVisit(tree, 'element', (node) => {
						if (node.tagName === components[i]) {
							node.tagName = `Components.${components[i]}`;
						}
					});
				}
			}

			// add the layout if we are using one, reusing the existing script if one exists
			if (import_script && !instance[0]) {
				instance.push({
					type: 'raw',
					value: `${newline}<script>${newline}\t${import_script}${newline}</script>${newline}`,
				});
			} else if (import_script) {
				instance[0].value = (instance[0].value ).replace(
					RE_SCRIPT,
					`$1${newline}\t${import_script}`
				);
			}

			// inject the frontmatter into the module script if there is any, reusing the existing module script if one exists
			if (!_module[0] && fm) {
				_module.push({
					type: 'raw',
					value: `<script context="module">${newline}\t${fm}${newline}</script>`,
				});
			} else if (fm) {
				// @ts-ignore
				_module[0].value = _module[0].value.replace(
					RE_MODULE_SCRIPT,
					`$1${newline}\t${fm}`
				);
			}

			// smoosh it all together in an order that makes sense,
			// if using a layout we only wrap the html and nothing else
			//@ts-ignore
			node.children = [
				//@ts-ignore
				..._module,
				//@ts-ignore
				{ type: 'raw', value: _module[0] ? newline : '' },
				//@ts-ignore
				...instance,
				//@ts-ignore
				{ type: 'raw', value: instance[0] ? newline : '' },
				//@ts-ignore
				...css,
				//@ts-ignore
				{ type: 'raw', value: css[0] ? newline : '' },
				//@ts-ignore
				...special,
				//@ts-ignore
				{ type: 'raw', value: special[0] ? newline : '' },

				{
					//@ts-ignore
					type: 'raw',
					value: import_script
						? `<Layout_MDSVEX_DEFAULT {...$$props}${
								fm ? ' {...metadata}' : ''
						  }>`
						: '',
				},
				//@ts-ignore
				{ type: 'raw', value: newline },
				//@ts-ignore
				...html,
				//@ts-ignore
				{ type: 'raw', value: newline },
				//@ts-ignore
				{ type: 'raw', value: import_script ? '</Layout_MDSVEX_DEFAULT>' : '' },
			];
		});
	};
}

// highlighting stuff

// { [lang]: { path, deps: pointer to key } }
const langs = {};
let Prism;

const make_path = (base_path, id) =>
	base_path.replace('{id}', id);

// we need to get all language metadata
// also track if they depend on other languages so we can autoload without breaking
// i don't actually know what the require key means but it sounds important

function get_lang_info(
	name,
	lang_meta,
	base_path
) {
	const _lang_meta = {
		name,
		path: `prismjs/${make_path(base_path, name)}`,
		deps: new Set(),
	};

	const aliases = new Set();

	// TODO: DRY this up, it is literally identical

	if (lang_meta.require) {
		if (Array.isArray(lang_meta.require)) {
			lang_meta.require.forEach((id) => _lang_meta.deps.add(id));
		} else {
			_lang_meta.deps.add(lang_meta.require);
		}
	}

	if (lang_meta.peerDependencies) {
		if (Array.isArray(lang_meta.peerDependencies)) {
			lang_meta.peerDependencies.forEach((id) => _lang_meta.deps.add(id));
		} else {
			_lang_meta.deps.add(lang_meta.peerDependencies);
		}
	}

	if (lang_meta.alias) {
		if (Array.isArray(lang_meta.alias)) {
			lang_meta.alias.forEach((id) => aliases.add(id));
		} else {
			aliases.add(lang_meta.alias);
		}
	}

	return [{ ..._lang_meta, aliases }, aliases];
}

// workaround for ts weirdness - intersection types work better with interfaces vs object literals




function load_language_metadata() {
	if (!(process ).browser) {
		const {
			meta,
			...languages
		}
 = require('prismjs/components.json').languages;

		for (const lang in languages) {
			const [lang_info, aliases] = get_lang_info(
				lang,
				languages[lang],
				meta.path
			);

			langs[lang] = lang_info;
			aliases.forEach((_n) => {
				langs[_n] = langs[lang];
			});
		}

		const svelte_meta = {
			name: 'svelte',
			aliases: new Set(['sv']),
			path: 'prism-svelte',
			deps: new Set(['javscript', 'css']),
		};

		langs.svelte = svelte_meta;
		langs.sv = svelte_meta;
	}
}

function load_language(lang) {
	if (!(process ).browser) {
		if (!langs[lang]) return;

		langs[lang].deps.forEach((name) => load_language(name));

		require(langs[lang].path);
	}
}

function highlight_blocks({
	highlighter: highlight_fn,
	alias,
}


 = {}) {
	if (highlight_fn && !(process ).browser) {
		load_language_metadata();

		if (alias) {
			for (const lang in alias) {
				langs[lang] = langs[alias[lang]];
			}
		}
	}

	return async function (tree) {
		if (highlight_fn) {
			const nodes = [];
			unistUtilVisit(tree, 'code', (node) => {
				nodes.push(node);
			});

			await Promise.all(
				nodes.map(async (node) => {
					(node ).type = 'html';
					node.value = await highlight_fn(
						node.value,
						(node ).lang,
						(node ).meta
					);
				})
			);
		}
	};
}
// escape curlies, backtick, \t, \r, \n to avoid breaking output of {@html `here`} in .svelte
const escape_svelty = (str) =>
	str
		.replace(
			/[{}`]/g,
			//@ts-ignore
			(c) => ({ '{': '&#123;', '}': '&#125;', '`': '&#96;' }[c])
		)
		.replace(/\\([trn])/g, '&#92;$1');

const code_highlight = (code, lang) => {
	const normalised_lang = _optionalChain([lang, 'optionalAccess', _ => _.toLowerCase, 'call', _2 => _2()]);
	if (!(process ).browser) {
		let _lang = !!normalised_lang && langs[normalised_lang];

		if (!Prism) Prism = require('prismjs');

		if (_lang && !Prism.languages[_lang.name]) {
			load_language(_lang.name);
		}

		if (!_lang && normalised_lang && Prism.languages[normalised_lang]) {
			langs[normalised_lang] = { name: lang } ;
			_lang = langs[normalised_lang];
		}
		const highlighted = escape_svelty(
			_lang
				? Prism.highlight(code, Prism.languages[_lang.name], _lang.name)
				: escapeHtml_1(code)
		);
		return `<pre class="language-${normalised_lang}">{@html \`<code class="language-${normalised_lang}">${highlighted}</code>\`}</pre>`;
	} else {
		const highlighted = escape_svelty(escapeHtml_1(code));
		return `<pre class="language-${normalised_lang}">{@html \`<code class="language-${normalised_lang}">${highlighted}</code>\`}</pre>`;
	}
};

function stringify( options = {}) {
	this.Compiler = compiler;

	function compiler(tree) {
		return prettyhtmlHastToHtml(tree, options);
	}
}

const apply_plugins = (plugins, parser) => {
	(plugins ).forEach((plugin) => {
		if (Array.isArray(plugin)) {
			if (plugin[1] && plugin[1]) parser.use(plugin[0], plugin[1]);
			else parser.use(plugin[0]);
		} else {
			parser.use(plugin);
		}
	});

	return parser;
};

function transform(
	{
		remarkPlugins = [],
		rehypePlugins = [],
		frontmatter,
		smartypants,
		layout,
		layout_mode,
		highlight,
	} = { layout_mode: 'single' }
) {
	const fm_opts = frontmatter
		? frontmatter
		: { parse: default_frontmatter, type: 'yaml', marker: '-' };
	const toMDAST = unified_1$1()
		.use(remarkParse)
		.use(mdsvex_parser)
		.use(remarkExternalLinks, { target: false, rel: ['nofollow'] })
		.use(escape_code, { blocks: !!highlight })
		.use(remarkFrontmatter, [{ type: fm_opts.type, marker: fm_opts.marker }])
		.use(parse_frontmatter, { parse: fm_opts.parse, type: fm_opts.type });

	if (smartypants) {
		toMDAST.use(
			smartypants_transformer,
			typeof smartypants === 'boolean' ? {} : smartypants
		);
	}

	apply_plugins(remarkPlugins, toMDAST).use(highlight_blocks, highlight || {});

	const toHAST = toMDAST
		.use(remarkRehype, {
			// @ts-ignore
			allowDangerousHtml: true,
			allowDangerousCharacters: true,
		})
		.use(transform_hast, { layout, layout_mode });

	apply_plugins(rehypePlugins, toHAST);

	const processor = toHAST.use(stringify, {
		allowDangerousHtml: true,
		allowDangerousCharacters: true,
	});

	return processor;
}

const defaults = {
	remarkPlugins: [],
	rehypePlugins: [],
	smartypants: true,
	extension: '.svx',
	highlight: { highlighter: code_highlight },
};

function to_posix(_path) {
	const isExtendedLengthPath = /^\\\\\?\\/.test(_path);
	const hasNonAscii = /[^\u0000-\u0080]+/.test(_path);

	if (isExtendedLengthPath || hasNonAscii) {
		return _path;
	}

	return _path.replace(/\\/g, '/');
}

function resolve_layout(layout_path) {
	try {
		return to_posix(require.resolve(layout_path));
	} catch (e) {
		try {
			const _path = join$1(process.cwd(), layout_path);
			return to_posix(require.resolve(_path));
		} catch (e) {
			throw new Error(
				`The layout path you provided couldn't be found at either ${layout_path} or ${join$1(
					process.cwd(),
					layout_path
				)}. Please double-check it and try again.`
			);
		}
	}
}

// handle custom components

function process_layouts(layouts) {
	const _layouts = layouts;

	for (const key in _layouts) {
		const layout = fs__default.readFileSync(_layouts[key].path, { encoding: 'utf8' });
		let ast;
		try {
			ast = parse$8(layout);
		} catch (e) {
			throw new Error(e.toString() + `\n	at ${_layouts[key].path}`);
		}

		if (ast.module) {
			const component_exports = ast.module.content.body.filter(
				(node) => node.type === 'ExportNamedDeclaration'
			) ;

			if (component_exports.length) {
				_layouts[key].components = [];

				for (let i = 0; i < component_exports.length; i++) {
					if (
						component_exports[i].specifiers &&
						component_exports[i].specifiers.length
					) {
						for (let j = 0; j < component_exports[i].specifiers.length; j++) {
							_layouts[key].components.push(
								component_exports[i].specifiers[j].exported.name
							);
						}
						//@ts-ignore
					} else if (component_exports[i].declaration.declarations) {
						//@ts-ignore
						const declarations = component_exports[i].declaration.declarations;

						for (let j = 0; j < declarations.length; j++) {
							_layouts[key].components.push(declarations[j].id.name);
						}
					} else if (component_exports[i].declaration) {
						_layouts[key].components.push(
							//@ts-ignore
							component_exports[i].declaration.id.name
						);
					}
				}
			}
		}
	}
	return _layouts;
}

/**
 * The svelte preprocessor for use with svelte.preprocess
 *
 * **options** - An options object with the following properties, all are optional.
 *
 * - `extension` - The extension to use for mdsvex files
 * - `extensions` - The extensions to use for mdsvex files
 * - `layout` - Layouts to apply to mdsvex documents
 * - `frontmatter` - frontmatter options for documents
 * - `highlight` - syntax highlighting options
 * - `smartypants` - smart typography options
 * - `remarkPlugins` - remark plugins to apply to the markdown
 * - `rehypePlugins` - rehype plugins to apply to the rendered html
 *
 */

const mdsvex = (options = defaults) => {
	const {
		remarkPlugins = [],
		rehypePlugins = [],
		smartypants = true,
		extension = '.svx',
		extensions,
		layout = false,
		highlight = { highlighter: code_highlight },
		frontmatter,
	} = options;

	//@ts-ignore
	if (options.layouts) {
		throw new Error(
			`mdsvex: "layouts" is not a valid option. Did you mean "layout"?`
		);
	}

	const unknown_opts = [];
	const known_opts = [
		'filename',
		'remarkPlugins',
		'rehypePlugins',
		'smartypants',
		'extension',
		'extensions',
		'layout',
		'highlight',
		'frontmatter',
	];

	for (const opt in options) {
		if (!known_opts.includes(opt)) unknown_opts.push(opt);
	}

	if (unknown_opts.length) {
		console.warn(
			`mdsvex: Received unknown options: ${unknown_opts.join(
				', '
			)}. Valid options are: ${known_opts.join(', ')}.`
		);
	}

	let _layout = {};
	let layout_mode = 'single';

	if (typeof layout === 'string') {
		_layout.__mdsvex_default = { path: resolve_layout(layout), components: [] };
	} else if (typeof layout === 'object') {
		layout_mode = 'named';
		for (const name in layout) {
			_layout[name] = { path: resolve_layout(layout[name]), components: [] };
		}
	}
	if (highlight && highlight.highlighter === undefined) {
		highlight.highlighter = code_highlight;
	}

	_layout = process_layouts(_layout);
	const parser = transform({
		remarkPlugins,
		rehypePlugins,
		smartypants,
		layout: _layout,
		layout_mode,
		highlight,
		frontmatter,
	});

	return {
		name: 'mdsvex',
		markup: async ({ content, filename }) => {
			const extensionsParts = (extensions || [extension]).map((ext) =>
				ext.split('.').pop()
			);
			if (!extensionsParts.includes(filename.split('.').pop())) return;

			const parsed = await parser.process({ contents: content, filename });
			return {
				code: parsed.contents ,
				data: parsed.data ,
				map: '',
			};
		},
	};
};

/**
 * The standalone compile function.
 *
 * - **source** - the source code to convert.
 * - **options** - An options object with the following properties, all are optional.
 *
 * - `filename` - The filename of the generated file
 * - `extension` - The extension to use for mdsvex files
 * - `extensions` - The extensions to use for mdsvex files
 * - `layout` - Layouts to apply to mdsvex documents
 * - `frontmatter` - frontmatter options for documents
 * - `highlight` - syntax highlighting options
 * - `smartypants` - smart typography options
 * - `remarkPlugins` - remark plugins to apply to the markdown
 * - `rehypePlugins` - rehype plugins to apply to the rendered html
 */

const _compile = (
	source,
	opts
) =>
	mdsvex(opts).markup({
		content: source,
		filename:
			(opts && opts.filename) ||
			`file${
				(opts && ((opts.extensions && opts.extensions[0]) || opts.extension)) ||
				'.svx'
			}`,
	});

async function markdownToHtml(markdown) {
  const options = {
    smartypants: {
      dashes: "oldschool",
      backticks: true,
      ellipses: true,
      quotes: true
    },
    highlight: {
      highlighter: async (code, lang) => {
        lang = lang || "text";
        const html = await shiki.getHighlighter({ themes: ["material-theme-darker", "github-dark"] }).then((highlighter) => highlighter.codeToHtml(code, { lang }));
        let escapedHtml = escape_svelty(html);
        escapedHtml = escapedHtml.replaceAll("background-color: #212121", "");
        const language = lang;
        const codeWithHeader = `
                <div class="variant-ghost-primary rounded-md lg:w-3/6">
                    <header
                        class="tracking-widest text-sm uppercase flex justify-between items-center my-auto px-4"
                    >
                        <span class="codeblock-language font-monospace">${language}</span>
                        <button class="btn btn-sm variant-soft-surface my-1" onclick="copyCode(this)">Copy</button>
                    </header>
                    ${escapedHtml}
                </div>`;
        return codeWithHeader;
      }
    },
    // @ts-ignore - this is a valid remark plugin
    remarkPlugins: [remarkGfm, remarkGithub],
    rehypePlugins: [
      // @ts-ignore - this is a valid remark plugin
      [rehypeExternalLinks, { rel: ["nofollow"], target: ["_blank"] }]
    ]
  };
  let transformed_code = await _compile(markdown, options).then((result) => {
    return result?.code;
  });
  return transformed_code;
}

export { markdownToHtml as m };
//# sourceMappingURL=markdownToHtml-447e9943.js.map
