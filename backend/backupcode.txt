pub async fn create(&self, payload: UserCreatePayload) -> Result<User, sqlx::Error>{
        let user = sqlx::query_as::<_, User>(
            r#"
                INSERT INTO users (username, password, email)
                VALUES ($1, $2, $3)
                RETURNING id, username, password, email, first_name, last_name, is_active, is_superuser
            "#,
        )
        .bind(payload.username)
        .bind(payload.password)
        .bind(payload.email)
        .fetch_one(&self.pool)
        .await?;

        Ok(user)
    }

    pub async fn get_all(&self) -> Result<Vec<User>, sqlx::Error>{
        let users = sqlx::query_as::<_, User>(
            r#"
                SELECT id, username, password, email, first_name, last_name, is_active, is_superuser
                FROM users
            "#,
        )
        .fetch_all(&self.pool)
        .await?;

        Ok(users)
    }

    pub async fn get_by_id(&self, id: i32) -> Result<User, sqlx::Error>{
        let user = sqlx::query_as::<_, User>(
            r#"
                SELECT id, username, password, email, first_name, last_name, is_active, is_superuser
                FROM users
                WHERE id = $1
            "#,
        )
        .bind(id)
        .fetch_one(&self.pool)
        .await?;

        Ok(user)
    }

    pub async fn update(&self, id: i32, payload: UserUpdatePayload) -> Result<User, sqlx::Error>{
        let user = sqlx::query_as::<_, User>(
            r#"
                UPDATE users
                SET username = $1, password = $2, email = $3, first_name = $4, last_name = $5
                WHERE id = $6
                RETURNING id, username, password, email, first_name, last_name, is_active, is_superuser
            "#,
        )
        .bind(payload.username)
        .bind(payload.password)
        .bind(payload.email)
        .bind(payload.first_name)
        .bind(payload.last_name)
        .bind(id)
        .fetch_one(&self.pool)
        .await?;

        Ok(user)
    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

impl IntoResponse {
    let user = state.login(payload).await;
    match user {
        Ok(user) => {
            println!("--> {:<12} : LOGIN USER", "HANDLER");

            let username = user.username.clone();
            let token = generate_token(username)
                .map_err(|e| match e {
                    Error::InternalServerFailure => Error::InternalServerFailure,
                    _ => Error::TokenCreationFailed,
                })
                .unwrap();

            axum::http::Response::builder()
                .status(axum::http::StatusCode::OK)
                .header("content-type", "application/json")
                .header(
                    axum::http::header::AUTHORIZATION,
                    axum::http::HeaderValue::from_str(&token).unwrap(),
                )
                .body(serde_json::to_string(&user).unwrap())
                .unwrap()
        }
        Err(e) => {
            println!("--> {:<12} : LOGIN USER - {:?}", "ERROR", e);

            axum::http::Response::builder()
                .status(axum::http::StatusCode::UNAUTHORIZED)
                .header("content-type", "application/json")
                .body(
                    json!({
                        "Error":
                            format!(
                                "{:?}",
                                match e {
                                    Error::InvalidQuery(_) => Error::InternalServerFailure,
                                    _ => {
                                        e
                                    }
                                }
                            )
                    })
                    .to_string(),
                )
                .unwrap()
        }
    }
}